   1              		.file	"prim_rx_nb.c"
   9              	.Ltext0:
  10              		.global	nb_sched_set
  11              		.section	.rodata
  12              		.align	2
  15              	nb_sched_set:
  16 0000 00000000 		.word	l1s_nb_cmd
  17 0004 00       		.byte	0
  18 0005 00       		.byte	0
  19 0006 0000     		.space	2
  20 0008 0000     		.short	0
  21 000a 0300     		.short	3
  22 000c 00000000 		.word	0
  23 0010 00       		.byte	0
  24 0011 00       		.byte	0
  25 0012 00000000 		.space	6
  25      0000
  26 0018 00000000 		.word	l1s_nb_cmd
  27 001c 00       		.byte	0
  28 001d 01       		.byte	1
  29 001e 0000     		.space	2
  30 0020 0000     		.short	0
  31 0022 0300     		.short	3
  32 0024 00000000 		.word	0
  33 0028 00       		.byte	0
  34 0029 00       		.byte	0
  35 002a 00000000 		.space	6
  35      0000
  36 0030 00000000 		.word	l1s_nb_resp
  37 0034 00       		.byte	0
  38 0035 00       		.byte	0
  39 0036 0000     		.space	2
  40 0038 FCFF     		.short	-4
  41 003a 0000     		.short	0
  42 003c 00000000 		.word	l1s_nb_cmd
  43 0040 00       		.byte	0
  44 0041 02       		.byte	2
  45 0042 0000     		.space	2
  46 0044 0000     		.short	0
  47 0046 0300     		.short	3
  48 0048 00000000 		.word	0
  49 004c 00       		.byte	0
  50 004d 00       		.byte	0
  51 004e 00000000 		.space	6
  51      0000
  52 0054 00000000 		.word	l1s_nb_resp
  53 0058 00       		.byte	0
  54 0059 01       		.byte	1
  55 005a 0000     		.space	2
  56 005c FCFF     		.short	-4
  57 005e 0000     		.short	0
  58 0060 00000000 		.word	l1s_nb_cmd
  59 0064 00       		.byte	0
  60 0065 03       		.byte	3
  61 0066 0000     		.space	2
  62 0068 0000     		.short	0
  63 006a 0300     		.short	3
  64 006c 00000000 		.word	0
  65 0070 00       		.byte	0
  66 0071 00       		.byte	0
  67 0072 00000000 		.space	6
  67      0000
  68 0078 00000000 		.word	l1s_nb_resp
  69 007c 00       		.byte	0
  70 007d 02       		.byte	2
  71 007e 0000     		.space	2
  72 0080 FCFF     		.short	-4
  73 0082 0000     		.short	0
  74 0084 00000000 		.word	0
  75 0088 00       		.byte	0
  76 0089 00       		.byte	0
  77 008a 00000000 		.space	6
  77      0000
  78 0090 00000000 		.word	l1s_nb_resp
  79 0094 00       		.byte	0
  80 0095 03       		.byte	3
  81 0096 0000     		.space	2
  82 0098 FCFF     		.short	-4
  83 009a 0000     		.short	0
  84 009c 00000000 		.word	0
  85 00a0 00       		.byte	0
  86 00a1 00       		.byte	0
  87 00a2 00000000 		.space	6
  87      0000
  88 00a8 00000000 		.word	tdma_end_set
  89 00ac 00       		.byte	0
  90 00ad 00       		.byte	0
  91 00ae 00000000 		.space	6
  91      0000
  92              		.section	.text.msgb_tailroom,"ax",%progbits
  93              		.align	2
  95              	msgb_tailroom:
  96              	.LFB38:
  97              		.file 1 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
  98              		.loc 1 151 0
  99              		@ args = 0, pretend = 0, frame = 0
 100              		@ frame_needed = 0, uses_anonymous_args = 0
 101              		@ link register save eliminated.
 102              	.LVL0:
 103 0000 B423D0E1 		ldrh	r2, [r0, #52]
 104 0004 383090E5 		ldr	r3, [r0, #56]
 105 0008 3C0090E5 		ldr	r0, [r0, #60]
 106              	.LVL1:
 107 000c 023083E0 		add	r3, r3, r2
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 108              		.loc 1 153 0
 109 0010 030060E0 		rsb	r0, r0, r3
 110              		.loc 1 151 0
 111              		@ lr needed for prologue
 112              		.loc 1 153 0
 113 0014 1EFF2FE1 		bx	lr
 114              	.LFE38:
 116              		.section	.rodata.str1.4,"aMS",%progbits,1
 117              		.align	2
 118              	.LC0:
 119 0000 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 119      28257029 
 119      3A204E6F 
 119      7420656E 
 119      6F756768 
 120 0032 00       		.ascii	"\000"
 121              		.section	.text.msgb_put,"ax",%progbits
 122              		.align	2
 124              	msgb_put:
 125              	.LFB40:
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 126              		.loc 1 180 0
 127              		@ args = 0, pretend = 0, frame = 0
 128              		@ frame_needed = 0, uses_anonymous_args = 0
 129              	.LVL2:
 130 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 131              	.LCFI0:
 132              		.loc 1 180 0
 133 0004 0150A0E1 		mov	r5, r1
 134 0008 0040A0E1 		mov	r4, r0
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 135              		.loc 1 182 0
 136 000c FEFFFFEB 		bl	msgb_tailroom
 137              	.LVL3:
 138 0010 050050E1 		cmp	r0, r5
 139 0014 0020A0E1 		mov	r2, r0
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 140              		.loc 1 183 0
 141 0018 0410A0E1 		mov	r1, r4
 142 001c 28009FE5 		ldr	r0, .L7
 143 0020 0530A0E1 		mov	r3, r5
 144              		.loc 1 181 0
 145 0024 3C6094E5 		ldr	r6, [r4, #60]
 146              	.LVL4:
 147              		.loc 1 182 0
 148              	.LVL5:
 149              		.loc 1 183 0
 150 0028 FEFFFFBB 		bllt	osmo_panic
 151              	.LVL6:
 152              	.L4:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 153              		.loc 1 185 0
 154 002c 3C2094E5 		ldr	r2, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 155              		.loc 1 186 0
 156 0030 B633D4E1 		ldrh	r3, [r4, #54]
 157              		.loc 1 185 0
 158 0034 052082E0 		add	r2, r2, r5
 159              		.loc 1 186 0
 160 0038 053083E0 		add	r3, r3, r5
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 161              		.loc 1 188 0
 162 003c 0600A0E1 		mov	r0, r6
 163              		.loc 1 186 0
 164 0040 B633C4E1 		strh	r3, [r4, #54]	@ movhi
 165              		.loc 1 185 0
 166 0044 3C2084E5 		str	r2, [r4, #60]
 167              		.loc 1 188 0
 168 0048 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 169              	.L8:
 170              		.align	2
 171              	.L7:
 172 004c 00000000 		.word	.LC0
 173              	.LFE40:
 175              		.section	.rodata.str1.4
 176 0033 00       		.align	2
 177              	.LC1:
 178 0034 454D5054 		.ascii	"EMPTY\012\000"
 178      590A00
 179 003b 00       		.align	2
 180              	.LC2:
 181 003c 42555253 		.ascii	"BURST ID %u!=%u\012\000"
 181      54204944 
 181      20257521 
 181      3D25750A 
 181      00
 182              		.section	.text.l1s_nb_resp,"ax",%progbits
 183              		.align	2
 185              	l1s_nb_resp:
 186              	.LFB67:
 187              		.file 2 "layer1/prim_rx_nb.c"
   1:layer1/prim_rx_nb.c **** /* Layer 1 - Receiving Normal Bursts */
   2:layer1/prim_rx_nb.c **** 
   3:layer1/prim_rx_nb.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:layer1/prim_rx_nb.c ****  *
   5:layer1/prim_rx_nb.c ****  * All Rights Reserved
   6:layer1/prim_rx_nb.c ****  *
   7:layer1/prim_rx_nb.c ****  * This program is free software; you can redistribute it and/or modify
   8:layer1/prim_rx_nb.c ****  * it under the terms of the GNU General Public License as published by
   9:layer1/prim_rx_nb.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:layer1/prim_rx_nb.c ****  * (at your option) any later version.
  11:layer1/prim_rx_nb.c ****  *
  12:layer1/prim_rx_nb.c ****  * This program is distributed in the hope that it will be useful,
  13:layer1/prim_rx_nb.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:layer1/prim_rx_nb.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:layer1/prim_rx_nb.c ****  * GNU General Public License for more details.
  16:layer1/prim_rx_nb.c ****  *
  17:layer1/prim_rx_nb.c ****  * You should have received a copy of the GNU General Public License along
  18:layer1/prim_rx_nb.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:layer1/prim_rx_nb.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:layer1/prim_rx_nb.c ****  *
  21:layer1/prim_rx_nb.c ****  */
  22:layer1/prim_rx_nb.c **** 
  23:layer1/prim_rx_nb.c **** #include <stdint.h>
  24:layer1/prim_rx_nb.c **** #include <stdio.h>
  25:layer1/prim_rx_nb.c **** #include <string.h>
  26:layer1/prim_rx_nb.c **** #include <stdlib.h>
  27:layer1/prim_rx_nb.c **** 
  28:layer1/prim_rx_nb.c **** #include <defines.h>
  29:layer1/prim_rx_nb.c **** #include <debug.h>
  30:layer1/prim_rx_nb.c **** #include <memory.h>
  31:layer1/prim_rx_nb.c **** #include <byteorder.h>
  32:layer1/prim_rx_nb.c **** #include <rffe.h>
  33:layer1/prim_rx_nb.c **** #include <osmocom/gsm/gsm_utils.h>
  34:layer1/prim_rx_nb.c **** #include <osmocom/core/msgb.h>
  35:layer1/prim_rx_nb.c **** #include <calypso/dsp_api.h>
  36:layer1/prim_rx_nb.c **** #include <calypso/irq.h>
  37:layer1/prim_rx_nb.c **** #include <calypso/tpu.h>
  38:layer1/prim_rx_nb.c **** #include <calypso/tsp.h>
  39:layer1/prim_rx_nb.c **** #include <calypso/dsp.h>
  40:layer1/prim_rx_nb.c **** #include <calypso/timer.h>
  41:layer1/prim_rx_nb.c **** #include <comm/sercomm.h>
  42:layer1/prim_rx_nb.c **** 
  43:layer1/prim_rx_nb.c **** #include <layer1/sync.h>
  44:layer1/prim_rx_nb.c **** #include <layer1/afc.h>
  45:layer1/prim_rx_nb.c **** #include <layer1/toa.h>
  46:layer1/prim_rx_nb.c **** #include <layer1/tdma_sched.h>
  47:layer1/prim_rx_nb.c **** #include <layer1/mframe_sched.h>
  48:layer1/prim_rx_nb.c **** #include <layer1/tpu_window.h>
  49:layer1/prim_rx_nb.c **** #include <layer1/l23_api.h>
  50:layer1/prim_rx_nb.c **** #include <layer1/rfch.h>
  51:layer1/prim_rx_nb.c **** #include <layer1/prim.h>
  52:layer1/prim_rx_nb.c **** #include <layer1/agc.h>
  53:layer1/prim_rx_nb.c **** 
  54:layer1/prim_rx_nb.c **** #include <l1ctl_proto.h>
  55:layer1/prim_rx_nb.c **** 
  56:layer1/prim_rx_nb.c **** struct l1s_rxnb_state {
  57:layer1/prim_rx_nb.c **** 	struct l1s_meas_hdr meas[4];
  58:layer1/prim_rx_nb.c **** 
  59:layer1/prim_rx_nb.c **** 	struct msgb *msg;
  60:layer1/prim_rx_nb.c **** 	struct l1ctl_info_dl *dl;
  61:layer1/prim_rx_nb.c **** 	struct l1ctl_data_ind *di;
  62:layer1/prim_rx_nb.c **** };
  63:layer1/prim_rx_nb.c **** 
  64:layer1/prim_rx_nb.c **** static struct l1s_rxnb_state rxnb;
  65:layer1/prim_rx_nb.c **** 
  66:layer1/prim_rx_nb.c **** static int l1s_nb_resp(__unused uint8_t p1, uint8_t burst_id, uint16_t p3)
  67:layer1/prim_rx_nb.c **** {
 188              		.loc 2 67 0
 189              		@ args = 0, pretend = 0, frame = 16
 190              		@ frame_needed = 0, uses_anonymous_args = 0
 191              	.LVL7:
 192 0000 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 193              	.LCFI1:
  68:layer1/prim_rx_nb.c **** 	struct gsm_time rx_time;
  69:layer1/prim_rx_nb.c **** 	uint8_t mf_task_id = p3 & 0xff;
  70:layer1/prim_rx_nb.c **** 	uint8_t mf_task_flags = p3 >> 8;
  71:layer1/prim_rx_nb.c **** 	uint16_t rf_arfcn;
  72:layer1/prim_rx_nb.c **** 	uint8_t tsc, tn;
  73:layer1/prim_rx_nb.c **** 
  74:layer1/prim_rx_nb.c **** 	putchart('n');
  75:layer1/prim_rx_nb.c **** 
  76:layer1/prim_rx_nb.c **** 	/* just for debugging, d_task_d should not be 0 */
  77:layer1/prim_rx_nb.c **** 	if (dsp_api.db_r->d_task_d == 0) {
 194              		.loc 2 77 0
 195 0004 E0829FE5 		ldr	r8, .L32
 196 0008 040098E5 		ldr	r0, [r8, #4]
 197              	.LVL8:
 198 000c B030D0E1 		ldrh	r3, [r0, #0]
 199              		.loc 2 67 0
 200 0010 0228A0E1 		mov	r2, r2, asl #16
 201              	.LVL9:
 202              		.loc 2 77 0
 203 0014 000053E3 		cmp	r3, #0
 204              		.loc 2 67 0
 205 0018 2238A0E1 		mov	r3, r2, lsr #16
 206              	.LVL10:
 207 001c 10D04DE2 		sub	sp, sp, #16
 208              	.LCFI2:
 209              	.LVL11:
 210              		.loc 2 67 0
 211 0020 FF7001E2 		and	r7, r1, #255
 212              		.loc 2 69 0
 213 0024 FF9003E2 		and	r9, r3, #255
 214              	.LVL12:
 215              		.loc 2 70 0
 216 0028 22ACA0E1 		mov	sl, r2, lsr #24
 217              	.LVL13:
 218              		.loc 2 77 0
 219 002c 0D00001A 		bne	.L10
 220              	.LVL14:
  78:layer1/prim_rx_nb.c **** 		puts("EMPTY\n");
 221              		.loc 2 78 0
 222 0030 B8029FE5 		ldr	r0, .L32+4
 223 0034 FEFFFFEB 		bl	puts
 224              	.LVL15:
 225 0038 B60000EA 		b	.L12
 226              	.LVL16:
 227              	.L10:
  79:layer1/prim_rx_nb.c **** 		return 0;
  80:layer1/prim_rx_nb.c **** 	}
  81:layer1/prim_rx_nb.c **** 
  82:layer1/prim_rx_nb.c **** 	/* DSP burst ID needs to correspond with what we expect */
  83:layer1/prim_rx_nb.c **** 	if (dsp_api.db_r->d_burst_d != burst_id) {
 228              		.loc 2 83 0
 229 003c B210D0E1 		ldrh	r1, [r0, #2]
 230 0040 070051E1 		cmp	r1, r7
 231 0044 1400000A 		beq	.L13
  84:layer1/prim_rx_nb.c **** 		printf("BURST ID %u!=%u\n", dsp_api.db_r->d_burst_d, burst_id);
 232              		.loc 2 84 0
 233 0048 0720A0E1 		mov	r2, r7
 234 004c A0029FE5 		ldr	r0, .L32+8
 235 0050 FEFFFFEB 		bl	printf
 236              	.LVL17:
 237 0054 B60000EA 		b	.L12
 238              	.LVL18:
 239              	.L13:
  85:layer1/prim_rx_nb.c **** 		return 0;
  86:layer1/prim_rx_nb.c **** 	}
  87:layer1/prim_rx_nb.c **** 
  88:layer1/prim_rx_nb.c **** 	/* get radio parameters for _this_ burst */
  89:layer1/prim_rx_nb.c **** 	gsm_fn2gsmtime(&rx_time, l1s.current_time.fn - 1);
 240              		.loc 2 89 0
 241 0058 98329FE5 		ldr	r3, .L32+12
 242              	.LVL19:
 243 005c 001093E5 		ldr	r1, [r3, #0]
 244 0060 0D00A0E1 		mov	r0, sp
 245 0064 011041E2 		sub	r1, r1, #1
 246 0068 FEFFFFEB 		bl	gsm_fn2gsmtime
  90:layer1/prim_rx_nb.c **** 	rfch_get_params(&rx_time, &rf_arfcn, &tsc, &tn);
 247              		.loc 2 90 0
 248 006c 0C108DE2 		add	r1, sp, #12
 249 0070 0D00A0E1 		mov	r0, sp
 250 0074 0F208DE2 		add	r2, sp, #15
 251 0078 0E308DE2 		add	r3, sp, #14
 252 007c FEFFFFEB 		bl	rfch_get_params
  91:layer1/prim_rx_nb.c **** 
  92:layer1/prim_rx_nb.c **** 	/* collect measurements */
  93:layer1/prim_rx_nb.c **** 	rxnb.meas[burst_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 253              		.loc 2 93 0
 254 0080 043098E5 		ldr	r3, [r8, #4]
 255 0084 70629FE5 		ldr	r6, .L32+16
 256 0088 B021D3E1 		ldrh	r2, [r3, #16]
 257 008c 8751A0E1 		mov	r5, r7, asl #3
 258 0090 064085E0 		add	r4, r5, r6
 259 0094 B220C4E1 		strh	r2, [r4, #2]	@ movhi
  94:layer1/prim_rx_nb.c **** 	rxnb.meas[burst_id].pm_dbm8 =
 260              		.loc 2 94 0
 261 0098 B201D3E1 		ldrh	r0, [r3, #18]
 262 009c A001A0E1 		mov	r0, r0, lsr #3
 263 00a0 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
  95:layer1/prim_rx_nb.c **** 		agc_inp_dbm8_by_pm(dsp_api.db_r->a_serv_demod[D_PM] >> 3);
  96:layer1/prim_rx_nb.c **** 	rxnb.meas[burst_id].freq_err =
 264              		.loc 2 96 0
 265 00a4 041098E5 		ldr	r1, [r8, #4]
 266              		.loc 2 94 0
 267 00a8 B400C4E1 		strh	r0, [r4, #4]	@ movhi
 268              		.loc 2 96 0
 269 00ac 4C329FE5 		ldr	r3, .L32+20
 270 00b0 F421D1E1 		ldrsh	r2, [r1, #20]
 271 00b4 920303E0 		mul	r3, r2, r3
 272 00b8 FF2C83E2 		add	r2, r3, #65280
 273 00bc FF2082E2 		add	r2, r2, #255
 274 00c0 000053E3 		cmp	r3, #0
 275 00c4 0230A0B1 		movlt	r3, r2
 276              		.loc 2 94 0
 277 00c8 044084E2 		add	r4, r4, #4
 278              		.loc 2 96 0
 279 00cc 4338A0E1 		mov	r3, r3, asr #16
 280 00d0 B230C4E1 		strh	r3, [r4, #2]	@ movhi
  97:layer1/prim_rx_nb.c **** 			ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
  98:layer1/prim_rx_nb.c **** 	rxnb.meas[burst_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 281              		.loc 2 98 0
 282 00d4 B631D1E1 		ldrh	r3, [r1, #22]
 283 00d8 B200D4E1 		ldrh	r0, [r4, #2]
  99:layer1/prim_rx_nb.c **** 
 100:layer1/prim_rx_nb.c **** 	/* feed computed frequency error into AFC loop */
 101:layer1/prim_rx_nb.c **** 	if (rxnb.meas[burst_id].snr > AFC_SNR_THRESHOLD)
 284              		.loc 2 101 0
 285 00dc 0A0C53E3 		cmp	r3, #2560
 102:layer1/prim_rx_nb.c **** 		afc_input(rxnb.meas[burst_id].freq_err, rf_arfcn, 1);
 286              		.loc 2 102 0
 287 00e0 0008A081 		movhi	r0, r0, asl #16
 103:layer1/prim_rx_nb.c **** 	else
 104:layer1/prim_rx_nb.c **** 		afc_input(rxnb.meas[burst_id].freq_err, rf_arfcn, 0);
 288              		.loc 2 104 0
 289 00e4 0008A091 		movls	r0, r0, asl #16
 290              		.loc 2 102 0
 291 00e8 4008A081 		movhi	r0, r0, asr #16
 292 00ec 0120A083 		movhi	r2, #1
 293              		.loc 2 104 0
 294 00f0 4008A091 		movls	r0, r0, asr #16
 295 00f4 0020A093 		movls	r2, #0
 296              		.loc 2 98 0
 297 00f8 B63085E1 		strh	r3, [r5, r6]	@ movhi
 298              	.LVL20:
 299 00fc BC10DDE1 		ldrh	r1, [sp, #12]
 105:layer1/prim_rx_nb.c **** 
 106:layer1/prim_rx_nb.c **** 	/* feed computed TOA into TA loop */
 107:layer1/prim_rx_nb.c **** 	toa_input(rxnb.meas[burst_id].toa_qbit << 2, rxnb.meas[burst_id].snr);
 300              		.loc 2 107 0
 301 0100 F4519FE5 		ldr	r5, .L32+16
 302              		.loc 2 104 0
 303 0104 FEFFFFEB 		bl	afc_input
 304              		.loc 2 107 0
 305 0108 8731A0E1 		mov	r3, r7, asl #3
 306 010c 054083E0 		add	r4, r3, r5
 307 0110 F200D4E1 		ldrsh	r0, [r4, #2]
 308 0114 B51093E1 		ldrh	r1, [r3, r5]
 309 0118 0001A0E1 		mov	r0, r0, asl #2
 310 011c FEFFFFEB 		bl	toa_input
 108:layer1/prim_rx_nb.c **** 
 109:layer1/prim_rx_nb.c **** 	/* Tell the RF frontend to set the gain appropriately */
 110:layer1/prim_rx_nb.c **** 	rffe_compute_gain(rxnb.meas[burst_id].pm_dbm8/8, CAL_DSP_TGT_BB_LVL);
 311              		.loc 2 110 0
 312 0120 F400D4E1 		ldrsh	r0, [r4, #4]
 313 0124 073080E2 		add	r3, r0, #7
 314 0128 000050E3 		cmp	r0, #0
 315 012c 0300A0B1 		movlt	r0, r3
 316 0130 C001A0E1 		mov	r0, r0, asr #3
 317 0134 5010A0E3 		mov	r1, #80
 318 0138 FEFFFFEB 		bl	rffe_compute_gain
 111:layer1/prim_rx_nb.c **** 
 112:layer1/prim_rx_nb.c **** 	/* 4th burst, get frame data */
 113:layer1/prim_rx_nb.c **** 	if (dsp_api.db_r->d_burst_d == 3) {
 319              		.loc 2 113 0
 320 013c A8319FE5 		ldr	r3, .L32
 321 0140 043093E5 		ldr	r3, [r3, #4]
 322 0144 B230D3E1 		ldrh	r3, [r3, #2]
 323 0148 030053E3 		cmp	r3, #3
 324 014c B300001A 		bne	.L18
 325              	.LBB2:
 114:layer1/prim_rx_nb.c **** 		uint8_t i;
 115:layer1/prim_rx_nb.c **** 		uint16_t num_biterr;
 116:layer1/prim_rx_nb.c **** 		uint32_t avg_snr = 0;
 117:layer1/prim_rx_nb.c **** 		int32_t avg_dbm8 = 0;
 118:layer1/prim_rx_nb.c **** 
 119:layer1/prim_rx_nb.c **** 		/* Get radio parameters for the first burst */
 120:layer1/prim_rx_nb.c **** 		gsm_fn2gsmtime(&rx_time, l1s.current_time.fn - 4);
 326              		.loc 2 120 0
 327 0150 A0319FE5 		ldr	r3, .L32+12
 328 0154 001093E5 		ldr	r1, [r3, #0]
 329 0158 0D00A0E1 		mov	r0, sp
 330 015c 041041E2 		sub	r1, r1, #4
 331 0160 FEFFFFEB 		bl	gsm_fn2gsmtime
 121:layer1/prim_rx_nb.c **** 		rfch_get_params(&rx_time, &rf_arfcn, &tsc, &tn);
 332              		.loc 2 121 0
 333 0164 0F208DE2 		add	r2, sp, #15
 334 0168 0E308DE2 		add	r3, sp, #14
 335 016c 0D00A0E1 		mov	r0, sp
 336 0170 0C108DE2 		add	r1, sp, #12
 337 0174 FEFFFFEB 		bl	rfch_get_params
 338              	.LVL21:
 122:layer1/prim_rx_nb.c **** 
 123:layer1/prim_rx_nb.c **** 		/* Set Channel Number depending on MFrame Task ID */
 124:layer1/prim_rx_nb.c **** 		rxnb.dl->chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 339              		.loc 2 124 0
 340 0178 0E10DDE5 		ldrb	r1, [sp, #14]	@ zero_extendqisi2
 341 017c 0900A0E1 		mov	r0, r9
 342 0180 244095E5 		ldr	r4, [r5, #36]
 343 0184 FEFFFFEB 		bl	mframe_task2chan_nr
 344 0188 0000C4E5 		strb	r0, [r4, #0]
 125:layer1/prim_rx_nb.c **** 
 126:layer1/prim_rx_nb.c **** 		/* Set SACCH indication in Link IDentifier */
 127:layer1/prim_rx_nb.c **** 		if (mf_task_flags & MF_F_SACCH)
 345              		.loc 2 127 0
 346 018c 01301AE2 		ands	r3, sl, #1
 347 0190 242095E5 		ldr	r2, [r5, #36]
 128:layer1/prim_rx_nb.c **** 			rxnb.dl->link_id = 0x40;
 348              		.loc 2 128 0
 349 0194 4030A013 		movne	r3, #64
 129:layer1/prim_rx_nb.c **** 		else
 130:layer1/prim_rx_nb.c **** 			rxnb.dl->link_id = 0x00;
 350              		.loc 2 130 0
 351 0198 0130C2E5 		strb	r3, [r2, #1]
 352              	.LBB3:
 353              	.LBB4:
 354              		.file 3 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
 355              		.loc 3 51 0
 356 019c BC30DDE1 		ldrh	r3, [sp, #12]
 357              	.LBE4:
 358              	.LBE3:
 131:layer1/prim_rx_nb.c **** 
 132:layer1/prim_rx_nb.c **** 		rxnb.dl->band_arfcn = htons(rf_arfcn);
 359              		.loc 2 132 0
 360 01a0 54E19FE5 		ldr	lr, .L32+16
 361 01a4 2324A0E1 		mov	r2, r3, lsr #8
 362 01a8 FF3003E2 		and	r3, r3, #255
 363 01ac 24109EE5 		ldr	r1, [lr, #36]
 364 01b0 032482E1 		orr	r2, r2, r3, asl #8
 365 01b4 2234A0E1 		mov	r3, r2, lsr #8
 366 01b8 0330C1E5 		strb	r3, [r1, #3]
 367 01bc 0220C1E5 		strb	r2, [r1, #2]
 133:layer1/prim_rx_nb.c **** 
 134:layer1/prim_rx_nb.c **** 		rxnb.dl->frame_nr = htonl(rx_time.fn);
 368              		.loc 2 134 0
 369 01c0 00209DE5 		ldr	r2, [sp, #0]
 370              	.LBB5:
 371              	.LBB6:
 372              	.LBB7:
 373              	.LBB8:
 374              		.file 4 "include/asm/swab.h"
   1:include/asm/swab.h **** /*
   2:include/asm/swab.h ****  *  arch/arm/include/asm/byteorder.h
   3:include/asm/swab.h ****  *
   4:include/asm/swab.h ****  * ARM Endian-ness.  In little endian mode, the data bus is connected such
   5:include/asm/swab.h ****  * that byte accesses appear as:
   6:include/asm/swab.h ****  *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
   7:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
   8:include/asm/swab.h ****  *  d0...d31
   9:include/asm/swab.h ****  *
  10:include/asm/swab.h ****  * When in big endian mode, byte accesses appear as:
  11:include/asm/swab.h ****  *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
  12:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
  13:include/asm/swab.h ****  *  d0...d31
  14:include/asm/swab.h ****  */
  15:include/asm/swab.h **** #ifndef __ASM_ARM_SWAB_H
  16:include/asm/swab.h **** #define __ASM_ARM_SWAB_H
  17:include/asm/swab.h **** 
  18:include/asm/swab.h **** #include <stdint.h>
  19:include/asm/swab.h **** #include <defines.h>
  20:include/asm/swab.h **** 
  21:include/asm/swab.h **** static inline uint32_t __arch_swab32(uint32_t x)
  22:include/asm/swab.h **** {
  23:include/asm/swab.h **** 	uint32_t t;
  24:include/asm/swab.h **** 
  25:include/asm/swab.h **** #ifndef __thumb__
  26:include/asm/swab.h **** 	if (!__builtin_constant_p(x)) {
  27:include/asm/swab.h **** 		/*
  28:include/asm/swab.h **** 		 * The compiler needs a bit of a hint here to always do the
  29:include/asm/swab.h **** 		 * right thing and not screw it up to different degrees
  30:include/asm/swab.h **** 		 * depending on the gcc version.
  31:include/asm/swab.h **** 		 */
  32:include/asm/swab.h **** 		asm ("eor\t%0, %1, %1, ror #16" : "=r" (t) : "r" (x));
 375              		.loc 4 32 0
 376 01c4 623822E0 		eor	r3, r2, r2, ror #16
 377              	.LVL22:
 378              	.LBE8:
 379              	.LBE7:
 380              	.LBE6:
 381              	.LBE5:
 382              		.loc 2 134 0
 383 01c8 FF38C3E3 		bic	r3, r3, #16711680
 384              	.LVL23:
 385 01cc 2334A0E1 		mov	r3, r3, lsr #8
 386 01d0 623423E0 		eor	r3, r3, r2, ror #8
 387 01d4 24209EE5 		ldr	r2, [lr, #36]
 388 01d8 23C8A0E1 		mov	ip, r3, lsr #16
 389 01dc 231CA0E1 		mov	r1, r3, lsr #24
 390 01e0 2304A0E1 		mov	r0, r3, lsr #8
 391 01e4 06C0C2E5 		strb	ip, [r2, #6]
 392 01e8 0710C2E5 		strb	r1, [r2, #7]
 393 01ec 00C0A0E3 		mov	ip, #0
 394              	.LVL24:
 395 01f0 0430C2E5 		strb	r3, [r2, #4]
 396 01f4 0500C2E5 		strb	r0, [r2, #5]
 397 01f8 0C00A0E1 		mov	r0, ip
 398              	.LVL25:
 399              	.L23:
 135:layer1/prim_rx_nb.c **** 
 136:layer1/prim_rx_nb.c **** 		/* compute average snr and rx level */
 137:layer1/prim_rx_nb.c **** 		for (i = 0; i < 4; ++i) {
 400              		.loc 2 137 0
 401 01fc 00219FE5 		ldr	r2, .L32+24
 138:layer1/prim_rx_nb.c **** 			avg_snr += rxnb.meas[i].snr;
 402              		.loc 2 138 0
 403 0200 B030DEE1 		ldrh	r3, [lr, #0]
 139:layer1/prim_rx_nb.c **** 			avg_dbm8 += rxnb.meas[i].pm_dbm8;
 404              		.loc 2 139 0
 405 0204 F410DEE1 		ldrsh	r1, [lr, #4]
 406 0208 08E08EE2 		add	lr, lr, #8
 407              		.loc 2 137 0
 408 020c 02005EE1 		cmp	lr, r2
 409              		.loc 2 138 0
 410 0210 030080E0 		add	r0, r0, r3
 411              		.loc 2 139 0
 412 0214 01C08CE0 		add	ip, ip, r1
 413              		.loc 2 137 0
 414 0218 7D00001A 		bne	.L23
 140:layer1/prim_rx_nb.c **** 		}
 141:layer1/prim_rx_nb.c **** 		rxnb.dl->snr = avg_snr / 4;
 415              		.loc 2 141 0
 416 021c D8509FE5 		ldr	r5, .L32+16
 417 0220 242095E5 		ldr	r2, [r5, #36]
 142:layer1/prim_rx_nb.c **** 		rxnb.dl->rx_level = dbm2rxlev(avg_dbm8 / (8*4));
 418              		.loc 2 142 0
 419 0224 00005CE3 		cmp	ip, #0
 420              		.loc 2 141 0
 421 0228 2031A0E1 		mov	r3, r0, lsr #2
 422 022c 0930C2E5 		strb	r3, [r2, #9]
 423              		.loc 2 142 0
 424 0230 1F008CE2 		add	r0, ip, #31
 425              	.LVL26:
 426 0234 0C00A0A1 		movge	r0, ip
 427 0238 C002A0E1 		mov	r0, r0, asr #5
 428 023c 244095E5 		ldr	r4, [r5, #36]
 429 0240 FEFFFFEB 		bl	dbm2rxlev
 430              	.LVL27:
 143:layer1/prim_rx_nb.c **** 
 144:layer1/prim_rx_nb.c **** 		num_biterr = dsp_api.ndb->a_cd[2] & 0xffff;
 431              		.loc 2 144 0
 432 0244 A0309FE5 		ldr	r3, .L32
 433              		.loc 2 142 0
 434 0248 0800C4E5 		strb	r0, [r4, #8]
 435              		.loc 2 144 0
 436 024c 002093E5 		ldr	r2, [r3, #0]
 437 0250 023CA0E3 		mov	r3, #512
 438 0254 B33092E1 		ldrh	r3, [r2, r3]
 439              	.LVL28:
 440 0258 242095E5 		ldr	r2, [r5, #36]
 145:layer1/prim_rx_nb.c **** 		if (num_biterr > 0xff)
 441              		.loc 2 145 0
 442 025c FF0053E3 		cmp	r3, #255
 146:layer1/prim_rx_nb.c **** 			rxnb.dl->num_biterr = 0xff;
 443              		.loc 2 146 0
 444 0260 0030E083 		mvnhi	r3, #0
 445              	.LVL29:
 446              	.LVL30:
 147:layer1/prim_rx_nb.c **** 		else
 148:layer1/prim_rx_nb.c **** 			rxnb.dl->num_biterr = num_biterr;
 447              		.loc 2 148 0
 448 0264 0A30C2E5 		strb	r3, [r2, #10]
 149:layer1/prim_rx_nb.c **** 
 150:layer1/prim_rx_nb.c **** 		rxnb.dl->fire_crc = ((dsp_api.ndb->a_cd[0] & 0xffff) & ((1 << B_FIRE1) | (1 << B_FIRE0))) >> B_FI
 449              		.loc 2 150 0
 450 0268 7C509FE5 		ldr	r5, .L32
 451 026c 002095E5 		ldr	r2, [r5, #0]
 452 0270 7F3FA0E3 		mov	r3, #508
 453              	.LVL31:
 454 0274 80409FE5 		ldr	r4, .L32+16
 455 0278 B33092E1 		ldrh	r3, [r2, r3]
 456 027c 242094E5 		ldr	r2, [r4, #36]
 457 0280 603003E2 		and	r3, r3, #96
 458 0284 C332A0E1 		mov	r3, r3, asr #5
 459 0288 0B30C2E5 		strb	r3, [r2, #11]
 151:layer1/prim_rx_nb.c **** 
 152:layer1/prim_rx_nb.c **** 		/* update rx level for pm report */
 153:layer1/prim_rx_nb.c **** 		pu_update_rx_level(rxnb.dl->rx_level);
 460              		.loc 2 153 0
 461 028c 243094E5 		ldr	r3, [r4, #36]
 462 0290 0800D3E5 		ldrb	r0, [r3, #8]	@ zero_extendqisi2
 463 0294 FEFFFFEB 		bl	pu_update_rx_level
 154:layer1/prim_rx_nb.c **** 
 155:layer1/prim_rx_nb.c **** 		/* copy actual data, skipping the information block [0,1,2] */
 156:layer1/prim_rx_nb.c **** 		dsp_memcpy_from_api(rxnb.di->data, &dsp_api.ndb->a_cd[3], 23, 0);
 464              		.loc 2 156 0
 465 0298 001095E5 		ldr	r1, [r5, #0]
 466 029c 7F1F81E2 		add	r1, r1, #508
 467 02a0 1720A0E3 		mov	r2, #23
 468 02a4 0030A0E3 		mov	r3, #0
 469 02a8 061081E2 		add	r1, r1, #6
 470 02ac 280094E5 		ldr	r0, [r4, #40]
 471 02b0 FEFFFFEB 		bl	dsp_memcpy_from_api
 157:layer1/prim_rx_nb.c **** 
 158:layer1/prim_rx_nb.c **** 		l1_queue_for_l2(rxnb.msg);
 472              		.loc 2 158 0
 473 02b4 200094E5 		ldr	r0, [r4, #32]
 474 02b8 FEFFFFEB 		bl	l1_queue_for_l2
 159:layer1/prim_rx_nb.c **** 		rxnb.msg = NULL; rxnb.dl = NULL; rxnb.di = NULL;
 160:layer1/prim_rx_nb.c **** 
 161:layer1/prim_rx_nb.c **** 		/* clear downlink task */
 162:layer1/prim_rx_nb.c **** 		dsp_api.db_w->d_task_d = 0;
 475              		.loc 2 162 0
 476 02bc 082095E5 		ldr	r2, [r5, #8]
 477              		.loc 2 159 0
 478 02c0 0030A0E3 		mov	r3, #0
 479              		.loc 2 162 0
 480 02c4 B030C2E1 		strh	r3, [r2, #0]	@ movhi
 481              		.loc 2 159 0
 482 02c8 283084E5 		str	r3, [r4, #40]
 483 02cc 203084E5 		str	r3, [r4, #32]
 484 02d0 243084E5 		str	r3, [r4, #36]
 485              	.L18:
 486              	.LBE2:
 163:layer1/prim_rx_nb.c **** 	}
 164:layer1/prim_rx_nb.c **** 
 165:layer1/prim_rx_nb.c **** 	/* mark READ page as being used */
 166:layer1/prim_rx_nb.c **** 	dsp_api.r_page_used = 1;
 487              		.loc 2 166 0
 488 02d4 10309FE5 		ldr	r3, .L32
 489 02d8 0120A0E3 		mov	r2, #1
 490 02dc 182083E5 		str	r2, [r3, #24]
 491              	.L12:
 167:layer1/prim_rx_nb.c **** 
 168:layer1/prim_rx_nb.c **** 	return 0;
 169:layer1/prim_rx_nb.c **** }
 492              		.loc 2 169 0
 493 02e0 0000A0E3 		mov	r0, #0
 494 02e4 10D08DE2 		add	sp, sp, #16
 495 02e8 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 496              	.L33:
 497              		.align	2
 498              	.L32:
 499 02ec 00000000 		.word	dsp_api
 500 02f0 34000000 		.word	.LC1
 501 02f4 3C000000 		.word	.LC2
 502 02f8 00000000 		.word	l1s
 503 02fc 00000000 		.word	rxnb
 504 0300 C0500100 		.word	86208
 505 0304 20000000 		.word	rxnb+32
 506              	.LFE67:
 508              		.section	.rodata.str1.4
 509 004d 000000   		.align	2
 510              	.LC3:
 511 0050 6E625F63 		.ascii	"nb_cmd(0) and rxnb.msg != NULL\000"
 511      6D642830 
 511      2920616E 
 511      64207278 
 511      6E622E6D 
 512 006f 00       		.align	2
 513              	.LC4:
 514 0070 6E625F63 		.ascii	"nb_cmd(0): unable to allocate msgb\000"
 514      6D642830 
 514      293A2075 
 514      6E61626C 
 514      6520746F 
 515 0093 00       		.section	.text.l1s_nb_cmd,"ax",%progbits
 516              		.align	2
 518              	l1s_nb_cmd:
 519              	.LFB68:
 170:layer1/prim_rx_nb.c **** 
 171:layer1/prim_rx_nb.c **** static int l1s_nb_cmd(__unused uint8_t p1, uint8_t burst_id,
 172:layer1/prim_rx_nb.c **** 		      __unused uint16_t p3)
 173:layer1/prim_rx_nb.c **** {
 520              		.loc 2 173 0
 521              		@ args = 0, pretend = 0, frame = 4
 522              		@ frame_needed = 0, uses_anonymous_args = 0
 523              	.LVL32:
 524 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 525              	.LCFI3:
 526 0004 FF6001E2 		and	r6, r1, #255
 174:layer1/prim_rx_nb.c **** 	uint16_t arfcn;
 175:layer1/prim_rx_nb.c **** 	uint8_t tsc, tn;
 176:layer1/prim_rx_nb.c **** 
 177:layer1/prim_rx_nb.c **** 	putchart('N');
 178:layer1/prim_rx_nb.c **** 
 179:layer1/prim_rx_nb.c **** 	if (burst_id == 1) {
 527              		.loc 2 179 0
 528 0008 010056E3 		cmp	r6, #1
 529              		.loc 2 173 0
 530 000c 10D04DE2 		sub	sp, sp, #16
 531              	.LCFI4:
 532              	.LVL33:
 180:layer1/prim_rx_nb.c **** 		/* allocate message only at 2nd burst in case of
 181:layer1/prim_rx_nb.c **** 		 * consecutive/overlapping normal burst RX tasks */
 182:layer1/prim_rx_nb.c **** 		/* FIXME: we actually want all allocation out of L1S! */
 183:layer1/prim_rx_nb.c **** 		if (rxnb.msg) {
 184:layer1/prim_rx_nb.c **** 			/* Can happen when resetting ... */
 185:layer1/prim_rx_nb.c **** 			printf("nb_cmd(0) and rxnb.msg != NULL\n");
 186:layer1/prim_rx_nb.c **** 			msgb_free(rxnb.msg);
 187:layer1/prim_rx_nb.c **** 		}
 188:layer1/prim_rx_nb.c **** 		/* allocate msgb as needed. FIXME: from L1A ?? */
 189:layer1/prim_rx_nb.c **** 		rxnb.msg = l1ctl_msgb_alloc(L1CTL_DATA_IND);
 190:layer1/prim_rx_nb.c **** 		if (!rxnb.msg)
 191:layer1/prim_rx_nb.c **** 			printf("nb_cmd(0): unable to allocate msgb\n");
 192:layer1/prim_rx_nb.c **** 		rxnb.dl = (struct l1ctl_info_dl *) msgb_put(rxnb.msg, sizeof(*rxnb.dl));
 193:layer1/prim_rx_nb.c **** 		rxnb.di = (struct l1ctl_data_ind *) msgb_put(rxnb.msg, sizeof(*rxnb.di));
 194:layer1/prim_rx_nb.c **** 	}
 195:layer1/prim_rx_nb.c **** 
 196:layer1/prim_rx_nb.c **** 	rfch_get_params(&l1s.next_time, &arfcn, &tsc, &tn);
 197:layer1/prim_rx_nb.c **** 
 198:layer1/prim_rx_nb.c **** 	/* DDL_DSP_TASK, four normal bursts */
 199:layer1/prim_rx_nb.c **** 	dsp_load_tch_param(&l1s.next_time,
 533              		.loc 2 199 0
 534 0010 0050A0E3 		mov	r5, #0
 535              		.loc 2 183 0
 536 0014 D4409FE5 		ldr	r4, .L45
 537              		.loc 2 179 0
 538 0018 1B00001A 		bne	.L35
 539              	.LVL34:
 540              		.loc 2 183 0
 541 001c 203094E5 		ldr	r3, [r4, #32]
 542 0020 050053E1 		cmp	r3, r5
 543              		.loc 2 185 0
 544 0024 C8009FE5 		ldr	r0, .L45+4
 545              	.LVL35:
 546              		.loc 2 183 0
 547 0028 0C00000A 		beq	.L37
 548              		.loc 2 185 0
 549 002c FEFFFFEB 		bl	puts
 550              	.LVL36:
 551              		.loc 2 186 0
 552 0030 200094E5 		ldr	r0, [r4, #32]
 553 0034 FEFFFFEB 		bl	msgb_free
 554              	.LVL37:
 555              	.L37:
 556              		.loc 2 189 0
 557 0038 0300A0E3 		mov	r0, #3
 558 003c FEFFFFEB 		bl	l1ctl_msgb_alloc
 559              	.LVL38:
 560 0040 0030A0E1 		mov	r3, r0
 561              		.loc 2 190 0
 562 0044 000050E3 		cmp	r0, #0
 563              		.loc 2 189 0
 564 0048 203084E5 		str	r3, [r4, #32]
 565              		.loc 2 191 0
 566 004c A4009FE5 		ldr	r0, .L45+8
 567              		.loc 2 190 0
 568              		.loc 2 191 0
 569 0050 FEFFFF0B 		bleq	puts
 570              	.L39:
 571              		.loc 2 192 0
 572 0054 0C10A0E3 		mov	r1, #12
 573 0058 200094E5 		ldr	r0, [r4, #32]
 574 005c FEFFFFEB 		bl	msgb_put
 575              		.loc 2 193 0
 576 0060 1710A0E3 		mov	r1, #23
 577              		.loc 2 192 0
 578 0064 240084E5 		str	r0, [r4, #36]
 579              		.loc 2 193 0
 580 0068 200094E5 		ldr	r0, [r4, #32]
 581 006c FEFFFFEB 		bl	msgb_put
 582 0070 280084E5 		str	r0, [r4, #40]
 583              	.LVL39:
 584              	.L35:
 585              		.loc 2 196 0
 586 0074 0C108DE2 		add	r1, sp, #12
 587 0078 0F208DE2 		add	r2, sp, #15
 588              	.LVL40:
 589 007c 0E308DE2 		add	r3, sp, #14
 590 0080 74009FE5 		ldr	r0, .L45+12
 591              	.LVL41:
 592 0084 FEFFFFEB 		bl	rfch_get_params
 593              	.LVL42:
 594              		.loc 2 199 0
 595 0088 0EC0DDE5 		ldrb	ip, [sp, #14]	@ zero_extendqisi2
 596 008c 0530A0E1 		mov	r3, r5
 597 0090 0320A0E3 		mov	r2, #3
 598 0094 0510A0E1 		mov	r1, r5
 599 0098 5C009FE5 		ldr	r0, .L45+12
 600 009c 08C08DE5 		str	ip, [sp, #8]
 601 00a0 00508DE5 		str	r5, [sp, #0]
 602 00a4 04508DE5 		str	r5, [sp, #4]
 603 00a8 FEFFFFEB 		bl	dsp_load_tch_param
 604              	.LBB9:
 605              	.LBB10:
 606              		.file 5 "include/calypso/dsp.h"
   1:include/calypso/dsp.h **** #ifndef _CALYPSO_DSP_H
   2:include/calypso/dsp.h **** #define _CALYPSO_DSP_H
   3:include/calypso/dsp.h **** 
   4:include/calypso/dsp.h **** #include <calypso/dsp_api.h>
   5:include/calypso/dsp.h **** #include <rffe.h>
   6:include/calypso/dsp.h **** 
   7:include/calypso/dsp.h **** #define CAL_DSP_TGT_BB_LVL	80
   8:include/calypso/dsp.h **** 
   9:include/calypso/dsp.h **** struct gsm_time;
  10:include/calypso/dsp.h **** 
  11:include/calypso/dsp.h **** struct dsp_api {
  12:include/calypso/dsp.h **** 	T_NDB_MCU_DSP *ndb;
  13:include/calypso/dsp.h **** 	T_DB_DSP_TO_MCU *db_r;
  14:include/calypso/dsp.h **** 	T_DB_MCU_TO_DSP *db_w;
  15:include/calypso/dsp.h **** 	T_PARAM_MCU_DSP *param;
  16:include/calypso/dsp.h **** 	int r_page;
  17:include/calypso/dsp.h **** 	int w_page;
  18:include/calypso/dsp.h **** 	int r_page_used;
  19:include/calypso/dsp.h **** 	int frame_ctr;
  20:include/calypso/dsp.h **** };
  21:include/calypso/dsp.h **** 
  22:include/calypso/dsp.h **** extern struct dsp_api dsp_api;
  23:include/calypso/dsp.h **** 
  24:include/calypso/dsp.h **** void dsp_power_on(void);
  25:include/calypso/dsp.h **** void dsp_dump_version(void);
  26:include/calypso/dsp.h **** void dsp_dump(void);
  27:include/calypso/dsp.h **** void dsp_checksum_task(void);
  28:include/calypso/dsp.h **** void dsp_api_memset(uint16_t *ptr, int octets);
  29:include/calypso/dsp.h **** void dsp_memcpy_to_api(volatile uint16_t *dsp_buf, const uint8_t *mcu_buf, int n, int be);
  30:include/calypso/dsp.h **** void dsp_memcpy_from_api(uint8_t *mcu_buf, const volatile uint16_t *dsp_buf, int n, int be);
  31:include/calypso/dsp.h **** void dsp_load_afc_dac(uint16_t afc);
  32:include/calypso/dsp.h **** void dsp_load_apc_dac(uint16_t apc);
  33:include/calypso/dsp.h **** void dsp_load_tch_param(struct gsm_time *next_time,
  34:include/calypso/dsp.h ****                         uint8_t chan_mode, uint8_t chan_type, uint8_t chan_sub,
  35:include/calypso/dsp.h ****                         uint8_t tch_loop, uint8_t sync_tch, uint8_t tn);
  36:include/calypso/dsp.h **** void dsp_load_ciph_param(int mode, uint8_t *key);
  37:include/calypso/dsp.h **** void dsp_end_scenario(void);
  38:include/calypso/dsp.h **** 
  39:include/calypso/dsp.h **** void dsp_load_rx_task(uint16_t task, uint8_t burst_id, uint8_t tsc);
  40:include/calypso/dsp.h **** void dsp_load_tx_task(uint16_t task, uint8_t burst_id, uint8_t tsc);
  41:include/calypso/dsp.h **** 
  42:include/calypso/dsp.h **** static inline uint16_t
  43:include/calypso/dsp.h **** dsp_task_iq_swap(uint16_t dsp_task, uint16_t band_arfcn, int tx)
  44:include/calypso/dsp.h **** {
  45:include/calypso/dsp.h **** 	if (rffe_iq_swapped(band_arfcn, tx))
 607              		.loc 5 45 0
 608 00ac 0510A0E1 		mov	r1, r5
 609              	.LVL43:
 610 00b0 BC00DDE1 		ldrh	r0, [sp, #12]
 611 00b4 FEFFFFEB 		bl	rffe_iq_swapped
 612              	.LBE10:
 613              	.LBE9:
 200:layer1/prim_rx_nb.c **** 	                   SIG_ONLY_MODE, SDCCH_4, 0, 0, 0, tn);
 201:layer1/prim_rx_nb.c **** 
 202:layer1/prim_rx_nb.c **** 	dsp_load_rx_task(
 614              		.loc 2 202 0
 615 00b8 40309FE5 		ldr	r3, .L45+16
 616 00bc 000050E3 		cmp	r0, #0
 617 00c0 0300A011 		movne	r0, r3
 618 00c4 1800A003 		moveq	r0, #24
 619 00c8 0610A0E1 		mov	r1, r6
 620              	.LVL44:
 621 00cc 0F20DDE5 		ldrb	r2, [sp, #15]	@ zero_extendqisi2
 622 00d0 FEFFFFEB 		bl	dsp_load_rx_task
 203:layer1/prim_rx_nb.c **** 		dsp_task_iq_swap(ALLC_DSP_TASK, arfcn, 0),
 204:layer1/prim_rx_nb.c **** 		burst_id, tsc
 205:layer1/prim_rx_nb.c **** 	);
 206:layer1/prim_rx_nb.c **** 
 207:layer1/prim_rx_nb.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_NB, 0);
 623              		.loc 2 207 0
 624 00d4 BC00DDE1 		ldrh	r0, [sp, #12]
 625 00d8 0310A0E3 		mov	r1, #3
 626 00dc 0520A0E1 		mov	r2, r5
 627 00e0 FEFFFFEB 		bl	l1s_rx_win_ctrl
 208:layer1/prim_rx_nb.c **** 
 209:layer1/prim_rx_nb.c **** 	return 0;
 210:layer1/prim_rx_nb.c **** }
 628              		.loc 2 210 0
 629 00e4 0500A0E1 		mov	r0, r5
 630 00e8 10D08DE2 		add	sp, sp, #16
 631 00ec 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 632              	.L46:
 633              		.align	2
 634              	.L45:
 635 00f0 00000000 		.word	rxnb
 636 00f4 50000000 		.word	.LC3
 637 00f8 70000000 		.word	.LC4
 638 00fc 0C000000 		.word	l1s+12
 639 0100 18800000 		.word	32792
 640              	.LFE68:
 642              		.bss
 643              		.align	2
 644              	rxnb:
 645 0000 00000000 		.space	44
 645      00000000 
 645      00000000 
 645      00000000 
 645      00000000 
 755              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 prim_rx_nb.c
     /tmp/ccg8XzgF.s:15     .rodata:0000000000000000 nb_sched_set
     /tmp/ccg8XzgF.s:16     .rodata:0000000000000000 $d
     /tmp/ccg8XzgF.s:518    .text.l1s_nb_cmd:0000000000000000 l1s_nb_cmd
     /tmp/ccg8XzgF.s:185    .text.l1s_nb_resp:0000000000000000 l1s_nb_resp
     /tmp/ccg8XzgF.s:95     .text.msgb_tailroom:0000000000000000 msgb_tailroom
     /tmp/ccg8XzgF.s:103    .text.msgb_tailroom:0000000000000000 $a
     /tmp/ccg8XzgF.s:124    .text.msgb_put:0000000000000000 msgb_put
     /tmp/ccg8XzgF.s:130    .text.msgb_put:0000000000000000 $a
     /tmp/ccg8XzgF.s:172    .text.msgb_put:000000000000004c $d
     /tmp/ccg8XzgF.s:192    .text.l1s_nb_resp:0000000000000000 $a
     /tmp/ccg8XzgF.s:499    .text.l1s_nb_resp:00000000000002ec $d
     /tmp/ccg8XzgF.s:644    .bss:0000000000000000 rxnb
     /tmp/ccg8XzgF.s:524    .text.l1s_nb_cmd:0000000000000000 $a
     /tmp/ccg8XzgF.s:635    .text.l1s_nb_cmd:00000000000000f0 $d

UNDEFINED SYMBOLS
tdma_end_set
osmo_panic
puts
printf
gsm_fn2gsmtime
rfch_get_params
agc_inp_dbm8_by_pm
afc_input
toa_input
rffe_compute_gain
mframe_task2chan_nr
dbm2rxlev
pu_update_rx_level
dsp_memcpy_from_api
l1_queue_for_l2
dsp_api
l1s
msgb_free
l1ctl_msgb_alloc
dsp_load_tch_param
rffe_iq_swapped
dsp_load_rx_task
l1s_rx_win_ctrl
