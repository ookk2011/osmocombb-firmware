   1              		.file	"prim_tch.c"
   9              	.Ltext0:
  10              		.global	tch_a_sched_set
  11              		.section	.rodata
  12              		.align	2
  15              	tch_a_sched_set:
  16 0000 00000000 		.word	l1s_tch_a_cmd
  17 0004 00       		.byte	0
  18 0005 00       		.byte	0
  19 0006 0000     		.space	2
  20 0008 0000     		.short	0
  21 000a 0300     		.short	3
  22 000c 00000000 		.word	0
  23 0010 00       		.byte	0
  24 0011 00       		.byte	0
  25 0012 00000000 		.space	6
  25      0000
  26 0018 00000000 		.word	0
  27 001c 00       		.byte	0
  28 001d 00       		.byte	0
  29 001e 00000000 		.space	6
  29      0000
  30 0024 00000000 		.word	l1s_tch_a_resp
  31 0028 00       		.byte	0
  32 0029 FC       		.byte	-4
  33 002a 0000     		.space	2
  34 002c 0000     		.short	0
  35 002e 0000     		.short	0
  36 0030 00000000 		.word	0
  37 0034 00       		.byte	0
  38 0035 00       		.byte	0
  39 0036 00000000 		.space	6
  39      0000
  40 003c 00000000 		.word	tdma_end_set
  41 0040 00       		.byte	0
  42 0041 00       		.byte	0
  43 0042 00000000 		.space	6
  43      0000
  44              		.global	tch_d_sched_set
  45              		.align	2
  48              	tch_d_sched_set:
  49 0048 00000000 		.word	l1s_tch_d_cmd
  50 004c 00       		.byte	0
  51 004d 00       		.byte	0
  52 004e 0000     		.space	2
  53 0050 0000     		.short	0
  54 0052 0300     		.short	3
  55 0054 00000000 		.word	0
  56 0058 00       		.byte	0
  57 0059 00       		.byte	0
  58 005a 00000000 		.space	6
  58      0000
  59 0060 00000000 		.word	0
  60 0064 00       		.byte	0
  61 0065 00       		.byte	0
  62 0066 00000000 		.space	6
  62      0000
  63 006c 00000000 		.word	l1s_tch_d_resp
  64 0070 00       		.byte	0
  65 0071 FC       		.byte	-4
  66 0072 0000     		.space	2
  67 0074 0000     		.short	0
  68 0076 0000     		.short	0
  69 0078 00000000 		.word	0
  70 007c 00       		.byte	0
  71 007d 00       		.byte	0
  72 007e 00000000 		.space	6
  72      0000
  73 0084 00000000 		.word	tdma_end_set
  74 0088 00       		.byte	0
  75 0089 00       		.byte	0
  76 008a 00000000 		.space	6
  76      0000
  77              		.global	tch_sched_set
  78              		.align	2
  81              	tch_sched_set:
  82 0090 00000000 		.word	l1s_tch_cmd
  83 0094 00       		.byte	0
  84 0095 00       		.byte	0
  85 0096 0000     		.space	2
  86 0098 0000     		.short	0
  87 009a 0300     		.short	3
  88 009c 00000000 		.word	0
  89 00a0 00       		.byte	0
  90 00a1 00       		.byte	0
  91 00a2 00000000 		.space	6
  91      0000
  92 00a8 00000000 		.word	0
  93 00ac 00       		.byte	0
  94 00ad 00       		.byte	0
  95 00ae 00000000 		.space	6
  95      0000
  96 00b4 00000000 		.word	l1s_tch_resp
  97 00b8 00       		.byte	0
  98 00b9 FC       		.byte	-4
  99 00ba 0000     		.space	2
 100 00bc 0000     		.short	0
 101 00be 0000     		.short	0
 102 00c0 00000000 		.word	0
 103 00c4 00       		.byte	0
 104 00c5 00       		.byte	0
 105 00c6 00000000 		.space	6
 105      0000
 106 00cc 00000000 		.word	tdma_end_set
 107 00d0 00       		.byte	0
 108 00d1 00       		.byte	0
 109 00d2 00000000 		.space	6
 109      0000
 110              		.section	.text.__fswab16,"ax",%progbits
 111              		.align	2
 113              	__fswab16:
 114              	.LFB3:
 115              		.file 1 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
 116              		.loc 1 47 0
 117              		@ args = 0, pretend = 0, frame = 0
 118              		@ frame_needed = 0, uses_anonymous_args = 0
 119              		@ link register save eliminated.
 120              	.LVL0:
 121 0000 0008A0E1 		mov	r0, r0, asl #16
 122              	.LVL1:
 123 0004 2008A0E1 		mov	r0, r0, lsr #16
 124              	.LVL2:
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
 125              		.loc 1 51 0
 126 0008 2034A0E1 		mov	r3, r0, lsr #8
 127 000c FF0000E2 		and	r0, r0, #255
 128              	.LVL3:
  52:include/swab.h **** #endif
  53:include/swab.h **** }
 129              		.loc 1 53 0
 130 0010 000483E1 		orr	r0, r3, r0, asl #8
 131              		.loc 1 47 0
 132              		@ lr needed for prologue
 133              		.loc 1 53 0
 134 0014 1EFF2FE1 		bx	lr
 135              	.LFE3:
 137              		.section	.text.__fswab32,"ax",%progbits
 138              		.align	2
 140              	__fswab32:
 141              	.LFB4:
  54:include/swab.h **** 
  55:include/swab.h **** static inline __attribute_const__ uint32_t __fswab32(uint32_t val)
  56:include/swab.h **** {
 142              		.loc 1 56 0
 143              		@ args = 0, pretend = 0, frame = 0
 144              		@ frame_needed = 0, uses_anonymous_args = 0
 145              		@ link register save eliminated.
 146              	.LVL4:
 147 0000 0030A0E1 		mov	r3, r0
 148              	.LBB2:
 149              	.LBB3:
 150              		.file 2 "include/asm/swab.h"
   1:include/asm/swab.h **** /*
   2:include/asm/swab.h ****  *  arch/arm/include/asm/byteorder.h
   3:include/asm/swab.h ****  *
   4:include/asm/swab.h ****  * ARM Endian-ness.  In little endian mode, the data bus is connected such
   5:include/asm/swab.h ****  * that byte accesses appear as:
   6:include/asm/swab.h ****  *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
   7:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
   8:include/asm/swab.h ****  *  d0...d31
   9:include/asm/swab.h ****  *
  10:include/asm/swab.h ****  * When in big endian mode, byte accesses appear as:
  11:include/asm/swab.h ****  *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
  12:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
  13:include/asm/swab.h ****  *  d0...d31
  14:include/asm/swab.h ****  */
  15:include/asm/swab.h **** #ifndef __ASM_ARM_SWAB_H
  16:include/asm/swab.h **** #define __ASM_ARM_SWAB_H
  17:include/asm/swab.h **** 
  18:include/asm/swab.h **** #include <stdint.h>
  19:include/asm/swab.h **** #include <defines.h>
  20:include/asm/swab.h **** 
  21:include/asm/swab.h **** static inline uint32_t __arch_swab32(uint32_t x)
  22:include/asm/swab.h **** {
  23:include/asm/swab.h **** 	uint32_t t;
  24:include/asm/swab.h **** 
  25:include/asm/swab.h **** #ifndef __thumb__
  26:include/asm/swab.h **** 	if (!__builtin_constant_p(x)) {
  27:include/asm/swab.h **** 		/*
  28:include/asm/swab.h **** 		 * The compiler needs a bit of a hint here to always do the
  29:include/asm/swab.h **** 		 * right thing and not screw it up to different degrees
  30:include/asm/swab.h **** 		 * depending on the gcc version.
  31:include/asm/swab.h **** 		 */
  32:include/asm/swab.h **** 		asm ("eor\t%0, %1, %1, ror #16" : "=r" (t) : "r" (x));
 151              		.loc 2 32 0
 152 0004 600820E0 		eor	r0, r0, r0, ror #16
 153              	.LVL5:
  33:include/asm/swab.h **** 	} else
  34:include/asm/swab.h **** #endif
  35:include/asm/swab.h **** 		t = x ^ ((x << 16) | (x >> 16)); /* eor r1,r0,r0,ror #16 */
  36:include/asm/swab.h **** 
  37:include/asm/swab.h **** 	x = (x << 24) | (x >> 8);		/* mov r0,r0,ror #8      */
 154              		.loc 2 37 0
 155 0008 FF08C0E3 		bic	r0, r0, #16711680
 156              	.LVL6:
 157 000c 2004A0E1 		mov	r0, r0, lsr #8
 158              	.LBE3:
 159              	.LBE2:
  57:include/swab.h **** #ifdef __arch_swab32
  58:include/swab.h **** 	return __arch_swab32(val);
  59:include/swab.h **** #else
  60:include/swab.h **** 	return ___constant_swab32(val);
  61:include/swab.h **** #endif
  62:include/swab.h **** }
 160              		.loc 1 62 0
 161 0010 630420E0 		eor	r0, r0, r3, ror #8
 162              		.loc 1 56 0
 163              		@ lr needed for prologue
 164              		.loc 1 62 0
 165 0014 1EFF2FE1 		bx	lr
 166              	.LFE4:
 168              		.section	.text.msgb_tailroom,"ax",%progbits
 169              		.align	2
 171              	msgb_tailroom:
 172              	.LFB38:
 173              		.file 3 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 174              		.loc 3 151 0
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              		@ link register save eliminated.
 178              	.LVL7:
 179 0000 B423D0E1 		ldrh	r2, [r0, #52]
 180 0004 383090E5 		ldr	r3, [r0, #56]
 181 0008 3C0090E5 		ldr	r0, [r0, #60]
 182              	.LVL8:
 183 000c 023083E0 		add	r3, r3, r2
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 184              		.loc 3 153 0
 185 0010 030060E0 		rsb	r0, r0, r3
 186              		.loc 3 151 0
 187              		@ lr needed for prologue
 188              		.loc 3 153 0
 189 0014 1EFF2FE1 		bx	lr
 190              	.LFE38:
 192              		.section	.rodata.str1.4,"aMS",%progbits,1
 193              		.align	2
 194              	.LC0:
 195 0000 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 195      28257029 
 195      3A204E6F 
 195      7420656E 
 195      6F756768 
 196 0032 00       		.ascii	"\000"
 197              		.section	.text.msgb_put,"ax",%progbits
 198              		.align	2
 200              	msgb_put:
 201              	.LFB40:
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 202              		.loc 3 180 0
 203              		@ args = 0, pretend = 0, frame = 0
 204              		@ frame_needed = 0, uses_anonymous_args = 0
 205              	.LVL9:
 206 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 207              	.LCFI0:
 208              		.loc 3 180 0
 209 0004 0150A0E1 		mov	r5, r1
 210 0008 0040A0E1 		mov	r4, r0
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 211              		.loc 3 182 0
 212 000c FEFFFFEB 		bl	msgb_tailroom
 213              	.LVL10:
 214 0010 050050E1 		cmp	r0, r5
 215 0014 0020A0E1 		mov	r2, r0
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 216              		.loc 3 183 0
 217 0018 0410A0E1 		mov	r1, r4
 218 001c 28009FE5 		ldr	r0, .L11
 219 0020 0530A0E1 		mov	r3, r5
 220              		.loc 3 181 0
 221 0024 3C6094E5 		ldr	r6, [r4, #60]
 222              	.LVL11:
 223              		.loc 3 182 0
 224              	.LVL12:
 225              		.loc 3 183 0
 226 0028 FEFFFFBB 		bllt	osmo_panic
 227              	.LVL13:
 228              	.L8:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 229              		.loc 3 185 0
 230 002c 3C2094E5 		ldr	r2, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 231              		.loc 3 186 0
 232 0030 B633D4E1 		ldrh	r3, [r4, #54]
 233              		.loc 3 185 0
 234 0034 052082E0 		add	r2, r2, r5
 235              		.loc 3 186 0
 236 0038 053083E0 		add	r3, r3, r5
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 237              		.loc 3 188 0
 238 003c 0600A0E1 		mov	r0, r6
 239              		.loc 3 186 0
 240 0040 B633C4E1 		strh	r3, [r4, #54]	@ movhi
 241              		.loc 3 185 0
 242 0044 3C2084E5 		str	r2, [r4, #60]
 243              		.loc 3 188 0
 244 0048 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 245              	.L12:
 246              		.align	2
 247              	.L11:
 248 004c 00000000 		.word	.LC0
 249              	.LFE40:
 251              		.section	.text.dsp_task_iq_swap,"ax",%progbits
 252              		.align	2
 254              	dsp_task_iq_swap:
 255              	.LFB65:
 256              		.file 4 "include/calypso/dsp.h"
   1:include/calypso/dsp.h **** #ifndef _CALYPSO_DSP_H
   2:include/calypso/dsp.h **** #define _CALYPSO_DSP_H
   3:include/calypso/dsp.h **** 
   4:include/calypso/dsp.h **** #include <calypso/dsp_api.h>
   5:include/calypso/dsp.h **** #include <rffe.h>
   6:include/calypso/dsp.h **** 
   7:include/calypso/dsp.h **** #define CAL_DSP_TGT_BB_LVL	80
   8:include/calypso/dsp.h **** 
   9:include/calypso/dsp.h **** struct gsm_time;
  10:include/calypso/dsp.h **** 
  11:include/calypso/dsp.h **** struct dsp_api {
  12:include/calypso/dsp.h **** 	T_NDB_MCU_DSP *ndb;
  13:include/calypso/dsp.h **** 	T_DB_DSP_TO_MCU *db_r;
  14:include/calypso/dsp.h **** 	T_DB_MCU_TO_DSP *db_w;
  15:include/calypso/dsp.h **** 	T_PARAM_MCU_DSP *param;
  16:include/calypso/dsp.h **** 	int r_page;
  17:include/calypso/dsp.h **** 	int w_page;
  18:include/calypso/dsp.h **** 	int r_page_used;
  19:include/calypso/dsp.h **** 	int frame_ctr;
  20:include/calypso/dsp.h **** };
  21:include/calypso/dsp.h **** 
  22:include/calypso/dsp.h **** extern struct dsp_api dsp_api;
  23:include/calypso/dsp.h **** 
  24:include/calypso/dsp.h **** void dsp_power_on(void);
  25:include/calypso/dsp.h **** void dsp_dump_version(void);
  26:include/calypso/dsp.h **** void dsp_dump(void);
  27:include/calypso/dsp.h **** void dsp_checksum_task(void);
  28:include/calypso/dsp.h **** void dsp_api_memset(uint16_t *ptr, int octets);
  29:include/calypso/dsp.h **** void dsp_memcpy_to_api(volatile uint16_t *dsp_buf, const uint8_t *mcu_buf, int n, int be);
  30:include/calypso/dsp.h **** void dsp_memcpy_from_api(uint8_t *mcu_buf, const volatile uint16_t *dsp_buf, int n, int be);
  31:include/calypso/dsp.h **** void dsp_load_afc_dac(uint16_t afc);
  32:include/calypso/dsp.h **** void dsp_load_apc_dac(uint16_t apc);
  33:include/calypso/dsp.h **** void dsp_load_tch_param(struct gsm_time *next_time,
  34:include/calypso/dsp.h ****                         uint8_t chan_mode, uint8_t chan_type, uint8_t chan_sub,
  35:include/calypso/dsp.h ****                         uint8_t tch_loop, uint8_t sync_tch, uint8_t tn);
  36:include/calypso/dsp.h **** void dsp_load_ciph_param(int mode, uint8_t *key);
  37:include/calypso/dsp.h **** void dsp_end_scenario(void);
  38:include/calypso/dsp.h **** 
  39:include/calypso/dsp.h **** void dsp_load_rx_task(uint16_t task, uint8_t burst_id, uint8_t tsc);
  40:include/calypso/dsp.h **** void dsp_load_tx_task(uint16_t task, uint8_t burst_id, uint8_t tsc);
  41:include/calypso/dsp.h **** 
  42:include/calypso/dsp.h **** static inline uint16_t
  43:include/calypso/dsp.h **** dsp_task_iq_swap(uint16_t dsp_task, uint16_t band_arfcn, int tx)
  44:include/calypso/dsp.h **** {
 257              		.loc 4 44 0
 258              		@ args = 0, pretend = 0, frame = 0
 259              		@ frame_needed = 0, uses_anonymous_args = 0
 260              	.LVL14:
 261 0000 0138A0E1 		mov	r3, r1, asl #16
 262 0004 00C8A0E1 		mov	ip, r0, asl #16
 263 0008 10402DE9 		stmfd	sp!, {r4, lr}
 264              	.LCFI1:
  45:include/calypso/dsp.h **** 	if (rffe_iq_swapped(band_arfcn, tx))
 265              		.loc 4 45 0
 266 000c 0210A0E1 		mov	r1, r2
 267              	.LVL15:
 268 0010 2308A0E1 		mov	r0, r3, lsr #16
 269              	.LVL16:
 270              		.loc 4 44 0
 271 0014 2C48A0E1 		mov	r4, ip, lsr #16
 272              	.LVL17:
 273              		.loc 4 45 0
 274 0018 FEFFFFEB 		bl	rffe_iq_swapped
 275              	.LVL18:
 276 001c 000050E3 		cmp	r0, #0
  46:include/calypso/dsp.h **** 		dsp_task |= 0x8000;
 277              		.loc 4 46 0
 278 0020 02498413 		orrne	r4, r4, #32768
  47:include/calypso/dsp.h **** 	return dsp_task;
  48:include/calypso/dsp.h **** }
 279              		.loc 4 48 0
 280 0024 0400A0E1 		mov	r0, r4
 281 0028 1080BDE8 		ldmfd	sp!, {r4, pc}
 282              	.LFE65:
 284              		.global	__umodsi3
 285              		.section	.text.tch_get_params,"ax",%progbits
 286              		.align	2
 288              	tch_get_params:
 289              	.LFB67:
 290              		.file 5 "layer1/prim_tch.c"
   1:layer1/prim_tch.c **** /* Layer 1 - TCH */
   2:layer1/prim_tch.c **** 
   3:layer1/prim_tch.c **** /* (C) 2010 by Dieter Spaar <spaar@mirider.augusta.de>
   4:layer1/prim_tch.c ****  * (C) 2010 by Sylvain Munaut <tnt@246tnt.com>
   5:layer1/prim_tch.c ****  *
   6:layer1/prim_tch.c ****  * All Rights Reserved
   7:layer1/prim_tch.c ****  *
   8:layer1/prim_tch.c ****  * This program is free software; you can redistribute it and/or modify
   9:layer1/prim_tch.c ****  * it under the terms of the GNU General Public License as published by
  10:layer1/prim_tch.c ****  * the Free Software Foundation; either version 2 of the License, or
  11:layer1/prim_tch.c ****  * (at your option) any later version.
  12:layer1/prim_tch.c ****  *
  13:layer1/prim_tch.c ****  * This program is distributed in the hope that it will be useful,
  14:layer1/prim_tch.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15:layer1/prim_tch.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16:layer1/prim_tch.c ****  * GNU General Public License for more details.
  17:layer1/prim_tch.c ****  *
  18:layer1/prim_tch.c ****  * You should have received a copy of the GNU General Public License along
  19:layer1/prim_tch.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  20:layer1/prim_tch.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  21:layer1/prim_tch.c ****  *
  22:layer1/prim_tch.c ****  */
  23:layer1/prim_tch.c **** 
  24:layer1/prim_tch.c **** #include <stdint.h>
  25:layer1/prim_tch.c **** #include <stdio.h>
  26:layer1/prim_tch.c **** #include <string.h>
  27:layer1/prim_tch.c **** #include <stdlib.h>
  28:layer1/prim_tch.c **** 
  29:layer1/prim_tch.c **** #include <defines.h>
  30:layer1/prim_tch.c **** #include <debug.h>
  31:layer1/prim_tch.c **** #include <memory.h>
  32:layer1/prim_tch.c **** #include <byteorder.h>
  33:layer1/prim_tch.c **** #include <osmocom/gsm/gsm_utils.h>
  34:layer1/prim_tch.c **** #include <osmocom/gsm/protocol/gsm_04_08.h>
  35:layer1/prim_tch.c **** #include <osmocom/core/msgb.h>
  36:layer1/prim_tch.c **** #include <calypso/dsp_api.h>
  37:layer1/prim_tch.c **** #include <calypso/irq.h>
  38:layer1/prim_tch.c **** #include <calypso/tpu.h>
  39:layer1/prim_tch.c **** #include <calypso/tsp.h>
  40:layer1/prim_tch.c **** #include <calypso/dsp.h>
  41:layer1/prim_tch.c **** #include <calypso/timer.h>
  42:layer1/prim_tch.c **** #include <comm/sercomm.h>
  43:layer1/prim_tch.c **** 
  44:layer1/prim_tch.c **** #include <rffe.h>
  45:layer1/prim_tch.c **** #include <layer1/sync.h>
  46:layer1/prim_tch.c **** #include <layer1/afc.h>
  47:layer1/prim_tch.c **** #include <layer1/agc.h>
  48:layer1/prim_tch.c **** #include <layer1/toa.h>
  49:layer1/prim_tch.c **** #include <layer1/tdma_sched.h>
  50:layer1/prim_tch.c **** #include <layer1/mframe_sched.h>
  51:layer1/prim_tch.c **** #include <layer1/tpu_window.h>
  52:layer1/prim_tch.c **** #include <layer1/l23_api.h>
  53:layer1/prim_tch.c **** #include <layer1/rfch.h>
  54:layer1/prim_tch.c **** #include <layer1/prim.h>
  55:layer1/prim_tch.c **** 
  56:layer1/prim_tch.c **** #include <l1ctl_proto.h>
  57:layer1/prim_tch.c **** 
  58:layer1/prim_tch.c **** 
  59:layer1/prim_tch.c **** /* This computes various parameters both for the DSP and for
  60:layer1/prim_tch.c ****  * our logic. Not all are used all the time, but it's easier
  61:layer1/prim_tch.c ****  * to build all in one place */
  62:layer1/prim_tch.c **** static void tch_get_params(struct gsm_time *time, uint8_t chan_nr,
  63:layer1/prim_tch.c ****                            uint32_t *fn_report, uint8_t *tch_f_hn,
  64:layer1/prim_tch.c ****                            uint8_t *tch_sub, uint8_t *tch_mode)
  65:layer1/prim_tch.c **** {
 291              		.loc 5 65 0
 292              		@ args = 8, pretend = 0, frame = 0
 293              		@ frame_needed = 0, uses_anonymous_args = 0
 294              	.LVL19:
 295 0000 01C0A0E1 		mov	ip, r1
 296 0004 FF1001E2 		and	r1, r1, #255
 297 0008 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 298              	.LCFI2:
  66:layer1/prim_tch.c **** 	uint8_t tn = chan_nr & 0x07;
  67:layer1/prim_tch.c **** 	uint8_t cbits = chan_nr >> 3;
 299              		.loc 5 67 0
 300 000c A1E1A0E1 		mov	lr, r1, lsr #3
 301 0010 AE10A0E1 		mov	r1, lr, lsr #1
 302              	.LVL20:
 303 0014 014001E2 		and	r4, r1, #1
 304              		.loc 5 65 0
 305 0018 0350A0E1 		mov	r5, r3
  68:layer1/prim_tch.c **** 
  69:layer1/prim_tch.c **** 	*tch_f_hn = (cbits & 2) ? 0 : 1;
 306              		.loc 5 69 0
 307 001c 013024E2 		eor	r3, r4, #1
 308              	.LVL21:
  70:layer1/prim_tch.c **** 
  71:layer1/prim_tch.c **** 	if (*tch_f_hn) {
 309              		.loc 5 71 0
 310 0020 000054E3 		cmp	r4, #0
 311              		.loc 5 69 0
 312 0024 0030C5E5 		strb	r3, [r5, #0]
 313              	.LBB4:
  72:layer1/prim_tch.c **** 		*fn_report = (time->fn - (tn * 13) + 104) % 104;
  73:layer1/prim_tch.c **** 		*tch_sub = 0;
  74:layer1/prim_tch.c **** 	} else {
  75:layer1/prim_tch.c **** 		uint8_t chan_sub = cbits & 1;
 314              		.loc 5 75 0
 315 0028 01400E12 		andne	r4, lr, #1
 316              	.LVL22:
  76:layer1/prim_tch.c **** 		uint8_t tn_report = (tn & ~1) | chan_sub;
  77:layer1/prim_tch.c **** 		*fn_report = (time->fn - (tn_report * 13) + 104) % 104;
 317              		.loc 5 77 0
 318 002c 06300C12 		andne	r3, ip, #6
 319 0030 001090E5 		ldr	r1, [r0, #0]
 320              	.LBE4:
 321              		.loc 5 65 0
 322 0034 0260A0E1 		mov	r6, r2
 323              		.loc 5 66 0
 324 0038 07000CE2 		and	r0, ip, #7
 325              	.LVL23:
 326              		.loc 5 72 0
 327 003c 0D30A003 		moveq	r3, #13
 328              	.LBB5:
 329              		.loc 5 77 0
 330 0040 04308311 		orrne	r3, r3, r4
 331 0044 0D20A013 		movne	r2, #13
 332              	.LVL24:
 333              	.LBE5:
 334              		.loc 5 72 0
 335 0048 93000000 		muleq	r0, r3, r0
 336              	.LVL25:
 337              	.LBB6:
 338              		.loc 5 77 0
 339 004c 93020010 		mulne	r0, r3, r2
 340 0050 010060E0 		rsb	r0, r0, r1
 341 0054 680080E2 		add	r0, r0, #104
 342 0058 6810A0E3 		mov	r1, #104
 343 005c FEFFFFEB 		bl	__umodsi3
 344              	.LVL26:
 345              	.LBE6:
 346              		.loc 5 65 0
 347 0060 1C709DE5 		ldr	r7, [sp, #28]
 348 0064 18809DE5 		ldr	r8, [sp, #24]
  78:layer1/prim_tch.c **** 		*tch_sub = chan_sub;
  79:layer1/prim_tch.c **** 	}
  80:layer1/prim_tch.c **** 
  81:layer1/prim_tch.c **** 	if (tch_mode) {
 349              		.loc 5 81 0
 350 0068 000057E3 		cmp	r7, #0
 351              	.LBB7:
 352              		.loc 5 77 0
 353 006c 000086E5 		str	r0, [r6, #0]
 354              		.loc 5 78 0
 355 0070 0040C8E5 		strb	r4, [r8, #0]
 356              	.LBE7:
 357              		.loc 5 81 0
 358 0074 F081BD08 		ldmeqfd	sp!, {r4, r5, r6, r7, r8, pc}
 359              	.LVL27:
  82:layer1/prim_tch.c **** 		switch (l1s.tch_mode) {
 360              		.loc 5 82 0
 361 0078 44309FE5 		ldr	r3, .L36
 362 007c 4A3AD3E5 		ldrb	r3, [r3, #2634]	@ zero_extendqisi2
 363 0080 010053E3 		cmp	r3, #1
 364 0084 2400000A 		beq	.L24
 365 0088 210053E3 		cmp	r3, #33
  83:layer1/prim_tch.c **** 		case GSM48_CMODE_SPEECH_V1:
  84:layer1/prim_tch.c **** 			*tch_mode = *tch_f_hn ? TCH_FS_MODE : TCH_HS_MODE;
  85:layer1/prim_tch.c **** 			break;
  86:layer1/prim_tch.c **** 		case GSM48_CMODE_SPEECH_EFR:
  87:layer1/prim_tch.c **** 			*tch_mode = *tch_f_hn ? TCH_EFR_MODE : SIG_ONLY_MODE;
  88:layer1/prim_tch.c **** 			break;
  89:layer1/prim_tch.c **** 		default:
  90:layer1/prim_tch.c **** 			*tch_mode = SIG_ONLY_MODE;
 366              		.loc 5 90 0
 367 008c 0030A013 		movne	r3, #0
 368              		.loc 5 82 0
 369 0090 2D00001A 		bne	.L35
 370 0094 290000EA 		b	.L25
 371              	.L24:
 372              		.loc 5 84 0
 373 0098 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 374 009c 000053E3 		cmp	r3, #0
 375 00a0 0230A003 		moveq	r3, #2
 376 00a4 0130A013 		movne	r3, #1
 377 00a8 2D0000EA 		b	.L35
 378              	.L25:
 379              		.loc 5 87 0
 380 00ac 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 381 00b0 000053E3 		cmp	r3, #0
 382 00b4 0830A013 		movne	r3, #8
 383 00b8 0030A003 		moveq	r3, #0
 384              	.L35:
 385              		.loc 5 90 0
 386 00bc 0030C7E5 		strb	r3, [r7, #0]
 387 00c0 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 388              	.L37:
 389              		.align	2
 390              	.L36:
 391 00c4 00000000 		.word	l1s
 392              	.LFE67:
 394              		.section	.text.l1a_tx_tch_compl,"ax",%progbits
 395              		.align	2
 397              	l1a_tx_tch_compl:
 398              	.LFB68:
  91:layer1/prim_tch.c **** 		}
  92:layer1/prim_tch.c **** 	}
  93:layer1/prim_tch.c **** }
  94:layer1/prim_tch.c **** 
  95:layer1/prim_tch.c **** 
  96:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
  97:layer1/prim_tch.c ****  * Shared completion handler
  98:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
  99:layer1/prim_tch.c **** 
 100:layer1/prim_tch.c **** /*
 101:layer1/prim_tch.c ****  * FIXME We really need a better way to handle completion, where we can
 102:layer1/prim_tch.c ****  *       pass arguments and such ...
 103:layer1/prim_tch.c ****  *
 104:layer1/prim_tch.c ****  *       Right now, we just 'hope' it gets processed before the next one ...
 105:layer1/prim_tch.c ****  */
 106:layer1/prim_tch.c **** 
 107:layer1/prim_tch.c **** #define TX_TYPE_SACCH	(1<<0)
 108:layer1/prim_tch.c **** #define TX_TYPE_FACCH	(1<<1)
 109:layer1/prim_tch.c **** #define TX_TYPE_TRAFFIC	(1<<2)
 110:layer1/prim_tch.c **** 
 111:layer1/prim_tch.c **** static uint16_t last_tx_tch_fn;
 112:layer1/prim_tch.c **** static uint16_t last_tx_tch_type;
 113:layer1/prim_tch.c **** 
 114:layer1/prim_tch.c **** static void l1a_tx_tch_compl(__unused enum l1_compl c)
 115:layer1/prim_tch.c **** {
 399              		.loc 5 115 0
 400              		@ args = 0, pretend = 0, frame = 0
 401              		@ frame_needed = 0, uses_anonymous_args = 0
 402              	.LVL28:
 403 0000 10402DE9 		stmfd	sp!, {r4, lr}
 404              	.LCFI3:
 116:layer1/prim_tch.c **** 	struct msgb *msg;
 117:layer1/prim_tch.c **** 
 118:layer1/prim_tch.c **** 	if (last_tx_tch_type & (TX_TYPE_SACCH | TX_TYPE_FACCH)) {
 405              		.loc 5 118 0
 406 0004 58409FE5 		ldr	r4, .L44
 407 0008 B010D4E1 		ldrh	r1, [r4, #0]
 119:layer1/prim_tch.c **** 		msg = l1_create_l2_msg(L1CTL_DATA_CONF, last_tx_tch_fn, 0, 0);
 408              		.loc 5 119 0
 409 000c 0020A0E3 		mov	r2, #0
 410              		.loc 5 118 0
 411 0010 030011E3 		tst	r1, #3
 412              		.loc 5 119 0
 413 0014 0230A0E1 		mov	r3, r2
 414 0018 0F00A0E3 		mov	r0, #15
 415              	.LVL29:
 416              		.loc 5 118 0
 417 001c 0A00000A 		beq	.L39
 418              		.loc 5 119 0
 419 0020 40109FE5 		ldr	r1, .L44+4
 420 0024 B010D1E1 		ldrh	r1, [r1, #0]
 421 0028 FEFFFFEB 		bl	l1_create_l2_msg
 120:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 422              		.loc 5 120 0
 423 002c FEFFFFEB 		bl	l1_queue_for_l2
 424              	.L39:
 121:layer1/prim_tch.c **** 	}
 122:layer1/prim_tch.c **** 
 123:layer1/prim_tch.c **** 	if (last_tx_tch_type & TX_TYPE_TRAFFIC) {
 425              		.loc 5 123 0
 426 0030 B010D4E1 		ldrh	r1, [r4, #0]
 124:layer1/prim_tch.c **** 		msg = l1_create_l2_msg(L1CTL_TRAFFIC_CONF, last_tx_tch_fn, 0, 0);
 427              		.loc 5 124 0
 428 0034 0020A0E3 		mov	r2, #0
 429              		.loc 5 123 0
 430 0038 040011E3 		tst	r1, #4
 431              		.loc 5 124 0
 432 003c 0230A0E1 		mov	r3, r2
 433 0040 1D00A0E3 		mov	r0, #29
 434              		.loc 5 123 0
 435 0044 1400000A 		beq	.L41
 436              		.loc 5 124 0
 437 0048 18109FE5 		ldr	r1, .L44+4
 438 004c B010D1E1 		ldrh	r1, [r1, #0]
 439 0050 FEFFFFEB 		bl	l1_create_l2_msg
 125:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 440              		.loc 5 125 0
 441 0054 FEFFFFEB 		bl	l1_queue_for_l2
 442              	.L41:
 126:layer1/prim_tch.c **** 	}
 127:layer1/prim_tch.c **** 
 128:layer1/prim_tch.c **** 	last_tx_tch_type = 0;
 443              		.loc 5 128 0
 444 0058 0030A0E3 		mov	r3, #0	@ movhi
 445 005c B030C4E1 		strh	r3, [r4, #0]	@ movhi
 129:layer1/prim_tch.c **** }
 446              		.loc 5 129 0
 447 0060 1080BDE8 		ldmfd	sp!, {r4, pc}
 448              	.L45:
 449              		.align	2
 450              	.L44:
 451 0064 74000000 		.word	last_tx_tch_type
 452 0068 76000000 		.word	last_tx_tch_fn
 453              	.LFE68:
 455              		.section	.text.prim_tch_init,"ax",%progbits
 456              		.align	2
 458              	prim_tch_init:
 459              	.LFB69:
 130:layer1/prim_tch.c **** 
 131:layer1/prim_tch.c **** static __attribute__ ((constructor)) void prim_tch_init(void)
 132:layer1/prim_tch.c **** {
 460              		.loc 5 132 0
 461              		@ args = 0, pretend = 0, frame = 0
 462              		@ frame_needed = 0, uses_anonymous_args = 0
 463              		@ link register save eliminated.
 464              	.LVL30:
 133:layer1/prim_tch.c **** 	l1s.completion[L1_COMPL_TX_TCH]  = &l1a_tx_tch_compl;
 465              		.loc 5 133 0
 466 0000 08209FE5 		ldr	r2, .L48
 467 0004 08309FE5 		ldr	r3, .L48+4
 468              		.loc 5 132 0
 469              		@ lr needed for prologue
 470              		.loc 5 133 0
 471 0008 7C2A83E5 		str	r2, [r3, #2684]
 134:layer1/prim_tch.c **** }
 472              		.loc 5 134 0
 473 000c 1EFF2FE1 		bx	lr
 474              	.L49:
 475              		.align	2
 476              	.L48:
 477 0010 00000000 		.word	l1a_tx_tch_compl
 478 0014 00000000 		.word	l1s
 479              	.LFE69:
 481              		.section	.ctors,"aw",%progbits
 482              		.align	2
 483 0000 00000000 		.word	prim_tch_init
 484              		.bss
 485              	meas_id.4330:
 486 0000 00       		.space	1
 487              		.section	.rodata.str1.4
 488 0033 00       		.align	2
 489              	.LC1:
 490 0034 54434820 		.ascii	"TCH FACCH: unable to allocate msgb\000"
 490      46414343 
 490      483A2075 
 490      6E61626C 
 490      6520746F 
 491              		.global	__udivsi3
 492              		.global	__divsi3
 493 0057 00       		.align	2
 494              	.LC2:
 495 0058 54434820 		.ascii	"TCH traffic: unable to allocate msgb\000"
 495      74726166 
 495      6669633A 
 495      20756E61 
 495      626C6520 
 496              		.section	.text.l1s_tch_resp,"ax",%progbits
 497              		.align	2
 499              	l1s_tch_resp:
 500              	.LFB70:
 135:layer1/prim_tch.c **** 
 136:layer1/prim_tch.c **** 
 137:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
 138:layer1/prim_tch.c ****  * TCH: Voice & FACCH
 139:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
 140:layer1/prim_tch.c **** 
 141:layer1/prim_tch.c **** /*
 142:layer1/prim_tch.c ****  * Voice and FACCH data are spread in various ways depending on a lot of
 143:layer1/prim_tch.c ****  * factors. Trying to handle that with the mframe scheduler is just a mess,
 144:layer1/prim_tch.c ****  * so we schedule it burst by burst and handle the complex logic inside the
 145:layer1/prim_tch.c ****  * primitive task code itself.
 146:layer1/prim_tch.c ****  */
 147:layer1/prim_tch.c **** 
 148:layer1/prim_tch.c **** 
 149:layer1/prim_tch.c **** #define FACCH_MEAS_HIST	8	/* Up to 8 bursts history */
 150:layer1/prim_tch.c **** struct l1s_rx_tch_state {
 151:layer1/prim_tch.c **** 	struct l1s_meas_hdr meas[FACCH_MEAS_HIST];
 152:layer1/prim_tch.c **** };
 153:layer1/prim_tch.c **** 
 154:layer1/prim_tch.c **** static struct l1s_rx_tch_state rx_tch;
 155:layer1/prim_tch.c **** 
 156:layer1/prim_tch.c **** 
 157:layer1/prim_tch.c **** static int l1s_tch_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 158:layer1/prim_tch.c **** {
 501              		.loc 5 158 0
 502              		@ args = 0, pretend = 0, frame = 24
 503              		@ frame_needed = 0, uses_anonymous_args = 0
 504              	.LVL31:
 505 0000 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 506              	.LCFI4:
 159:layer1/prim_tch.c **** 	static uint8_t meas_id = 0;
 160:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 161:layer1/prim_tch.c **** 	struct gsm_time rx_time;
 162:layer1/prim_tch.c **** 	uint8_t chan_nr;
 163:layer1/prim_tch.c **** 	uint16_t arfcn;
 164:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 165:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub;
 166:layer1/prim_tch.c **** 	uint32_t fn_report;
 167:layer1/prim_tch.c **** 	int facch_rx_now, traffic_rx_now;
 168:layer1/prim_tch.c **** 
 169:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 170:layer1/prim_tch.c **** 	gsm_fn2gsmtime(&rx_time, (l1s.current_time.fn - 1 + GSM_MAX_FN) % GSM_MAX_FN);
 507              		.loc 5 170 0
 508 0004 9C349FE5 		ldr	r3, .L90
 509 0008 9C049FE5 		ldr	r0, .L90+4
 510              	.LVL32:
 511 000c 003093E5 		ldr	r3, [r3, #0]
 512              		.loc 5 158 0
 513 0010 20D04DE2 		sub	sp, sp, #32
 514              	.LCFI5:
 515              	.LVL33:
 516              		.loc 5 170 0
 517 0014 000083E0 		add	r0, r3, r0
 518 0018 90149FE5 		ldr	r1, .L90+8
 519              	.LVL34:
 520              		.loc 5 158 0
 521 001c 0248A0E1 		mov	r4, r2, asl #16
 522              		.loc 5 170 0
 523 0020 FEFFFFEB 		bl	__umodsi3
 524              	.LVL35:
 525 0024 08508DE2 		add	r5, sp, #8
 526 0028 0010A0E1 		mov	r1, r0
 527              		.loc 5 158 0
 528 002c 2448A0E1 		mov	r4, r4, lsr #16
 529              	.LVL36:
 530              		.loc 5 170 0
 531 0030 0500A0E1 		mov	r0, r5
 532 0034 FEFFFFEB 		bl	gsm_fn2gsmtime
 171:layer1/prim_tch.c **** 	rfch_get_params(&rx_time, &arfcn, &tsc, &tn);
 172:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 533              		.loc 5 172 0
 534 0038 FF4004E2 		and	r4, r4, #255
 535              	.LVL37:
 536              		.loc 5 171 0
 537 003c 0500A0E1 		mov	r0, r5
 538 0040 1F208DE2 		add	r2, sp, #31
 539 0044 1E308DE2 		add	r3, sp, #30
 540 0048 1A108DE2 		add	r1, sp, #26
 541 004c FEFFFFEB 		bl	rfch_get_params
 542              		.loc 5 172 0
 543 0050 0400A0E1 		mov	r0, r4
 544              	.LVL38:
 545 0054 1E10DDE5 		ldrb	r1, [sp, #30]	@ zero_extendqisi2
 546 0058 FEFFFFEB 		bl	mframe_task2chan_nr
 173:layer1/prim_tch.c **** 	tch_get_params(&rx_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, NULL);
 174:layer1/prim_tch.c **** 
 175:layer1/prim_tch.c **** 	meas_id = (meas_id + 1) % FACCH_MEAS_HIST; /* absolute value doesn't matter */
 547              		.loc 5 175 0
 548 005c 50649FE5 		ldr	r6, .L90+12
 549              		.loc 5 172 0
 550 0060 00A0A0E1 		mov	sl, r0
 551              	.LVL39:
 552              		.loc 5 173 0
 553 0064 1CC08DE2 		add	ip, sp, #28
 554 0068 0500A0E1 		mov	r0, r5
 555 006c 14208DE2 		add	r2, sp, #20
 556 0070 0080A0E3 		mov	r8, #0
 557 0074 0A10A0E1 		mov	r1, sl
 558 0078 1D308DE2 		add	r3, sp, #29
 559 007c 00C08DE5 		str	ip, [sp, #0]
 560 0080 04808DE5 		str	r8, [sp, #4]
 561 0084 FEFFFFEB 		bl	tch_get_params
 562              		.loc 5 175 0
 563 0088 0040D6E5 		ldrb	r4, [r6, #0]	@ zero_extendqisi2
 564 008c 014084E2 		add	r4, r4, #1
 176:layer1/prim_tch.c **** 
 177:layer1/prim_tch.c **** 	/* Collect measurements */
 178:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 565              		.loc 5 178 0
 566 0090 20749FE5 		ldr	r7, .L90+16
 567              		.loc 5 175 0
 568 0094 1E4104E2 		and	r4, r4, #-2147483641
 569 0098 FF4004E2 		and	r4, r4, #255
 570 009c 0040C6E5 		strb	r4, [r6, #0]
 571              		.loc 5 178 0
 572 00a0 043097E5 		ldr	r3, [r7, #4]
 573 00a4 10549FE5 		ldr	r5, .L90+20
 574 00a8 B011D3E1 		ldrh	r1, [r3, #16]
 575 00ac 844185E0 		add	r4, r5, r4, asl #3
 576 00b0 B210C4E1 		strh	r1, [r4, #2]	@ movhi
 179:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].pm_dbm8 =
 577              		.loc 5 179 0
 578 00b4 B201D3E1 		ldrh	r0, [r3, #18]
 579 00b8 A001A0E1 		mov	r0, r0, lsr #3
 580 00bc FEFFFFEB 		bl	agc_inp_dbm8_by_pm
 581 00c0 B400C4E1 		strh	r0, [r4, #4]	@ movhi
 180:layer1/prim_tch.c **** 		agc_inp_dbm8_by_pm(dsp_api.db_r->a_serv_demod[D_PM] >> 3);
 181:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].freq_err =
 582              		.loc 5 181 0
 583 00c4 040097E5 		ldr	r0, [r7, #4]
 584 00c8 F0339FE5 		ldr	r3, .L90+24
 585 00cc F421D0E1 		ldrsh	r2, [r0, #20]
 586 00d0 920303E0 		mul	r3, r2, r3
 587 00d4 0010D6E5 		ldrb	r1, [r6, #0]	@ zero_extendqisi2
 588 00d8 FF2C83E2 		add	r2, r3, #65280
 589 00dc 8111A0E1 		mov	r1, r1, asl #3
 590 00e0 080053E1 		cmp	r3, r8
 591 00e4 FF2082E2 		add	r2, r2, #255
 592 00e8 0230A0B1 		movlt	r3, r2
 593 00ec 052081E0 		add	r2, r1, r5
 594 00f0 042082E2 		add	r2, r2, #4
 595 00f4 4338A0E1 		mov	r3, r3, asr #16
 596 00f8 B230C2E1 		strh	r3, [r2, #2]	@ movhi
 182:layer1/prim_tch.c **** 		ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
 183:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 597              		.loc 5 183 0
 598 00fc B631D0E1 		ldrh	r3, [r0, #22]
 599 0100 B200D2E1 		ldrh	r0, [r2, #2]
 184:layer1/prim_tch.c **** 
 185:layer1/prim_tch.c **** 	/* feed computed frequency error into AFC loop */
 186:layer1/prim_tch.c **** 	if (rx_tch.meas[meas_id].snr > AFC_SNR_THRESHOLD)
 600              		.loc 5 186 0
 601 0104 0A0C53E3 		cmp	r3, #2560
 602              		.loc 5 183 0
 603 0108 B53081E1 		strh	r3, [r1, r5]	@ movhi
 187:layer1/prim_tch.c **** 		afc_input(rx_tch.meas[meas_id].freq_err, arfcn, 1);
 604              		.loc 5 187 0
 605 010c 0008A081 		movhi	r0, r0, asl #16
 188:layer1/prim_tch.c **** 	else
 189:layer1/prim_tch.c **** 		afc_input(rx_tch.meas[meas_id].freq_err, arfcn, 0);
 606              		.loc 5 189 0
 607 0110 0008A091 		movls	r0, r0, asl #16
 190:layer1/prim_tch.c **** 
 191:layer1/prim_tch.c **** 	/* feed computed TOA into TA loop */
 192:layer1/prim_tch.c **** 	toa_input(rx_tch.meas[meas_id].toa_qbit << 2, rx_tch.meas[meas_id].snr);
 608              		.loc 5 192 0
 609 0114 98539FE5 		ldr	r5, .L90+12
 610              		.loc 5 187 0
 611 0118 4008A081 		movhi	r0, r0, asr #16
 612 011c 0120A083 		movhi	r2, #1
 613              		.loc 5 189 0
 614 0120 4008A091 		movls	r0, r0, asr #16
 615 0124 0820A091 		movls	r2, r8
 616              	.LVL40:
 617 0128 BA11DDE1 		ldrh	r1, [sp, #26]
 618 012c FEFFFFEB 		bl	afc_input
 619              		.loc 5 192 0
 620 0130 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 621 0134 80439FE5 		ldr	r4, .L90+20
 622 0138 8331A0E1 		mov	r3, r3, asl #3
 623 013c 042083E0 		add	r2, r3, r4
 624 0140 F200D2E1 		ldrsh	r0, [r2, #2]
 625 0144 B41093E1 		ldrh	r1, [r3, r4]
 626 0148 0001A0E1 		mov	r0, r0, asl #2
 627 014c FEFFFFEB 		bl	toa_input
 193:layer1/prim_tch.c **** 
 194:layer1/prim_tch.c **** 	/* Tell the RF frontend to set the gain appropriately */
 195:layer1/prim_tch.c **** 	rffe_compute_gain(rx_tch.meas[meas_id].pm_dbm8 / 8,
 628              		.loc 5 195 0
 629 0150 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 630 0154 834184E0 		add	r4, r4, r3, asl #3
 631 0158 F400D4E1 		ldrsh	r0, [r4, #4]
 632 015c 073080E2 		add	r3, r0, #7
 633 0160 000050E3 		cmp	r0, #0
 634 0164 0300A0B1 		movlt	r0, r3
 635 0168 C001A0E1 		mov	r0, r0, asr #3
 636 016c 5010A0E3 		mov	r1, #80
 637 0170 FEFFFFEB 		bl	rffe_compute_gain
 638              	.LVL41:
 196:layer1/prim_tch.c **** 		CAL_DSP_TGT_BB_LVL);
 197:layer1/prim_tch.c **** 
 198:layer1/prim_tch.c **** 	/* FACCH Block end ? */
 199:layer1/prim_tch.c **** 	if (tch_f_hn) {
 639              		.loc 5 199 0
 640 0174 1D30DDE5 		ldrb	r3, [sp, #29]	@ zero_extendqisi2
 641 0178 000053E3 		cmp	r3, #0
 642 017c 6500000A 		beq	.L55
 200:layer1/prim_tch.c **** 		/* FACCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) (mod 13) */
 201:layer1/prim_tch.c **** 		facch_rx_now = ((rx_time.fn % 13) % 4) == 3;
 202:layer1/prim_tch.c **** 	} else {
 203:layer1/prim_tch.c **** 		/* FAACH/H: See GSM 05.02 Clause 7 Table 1of9 */
 204:layer1/prim_tch.c **** 		uint8_t t2_norm = rx_time.t2 - tch_sub;
 205:layer1/prim_tch.c **** 		facch_rx_now = (t2_norm == 15) ||
 206:layer1/prim_tch.c **** 		               (t2_norm == 23) ||
 207:layer1/prim_tch.c **** 		               (t2_norm ==  6);
 208:layer1/prim_tch.c **** 	}
 209:layer1/prim_tch.c **** 
 210:layer1/prim_tch.c **** 	if (facch_rx_now && (dsp_api.ndb->a_fd[0] & (1<<B_BLUD))) {
 643              		.loc 5 210 0
 644 0180 08009DE5 		ldr	r0, [sp, #8]
 645 0184 0D10A0E3 		mov	r1, #13
 646 0188 FEFFFFEB 		bl	__umodsi3
 647 018c 030000E2 		and	r0, r0, #3
 648 0190 030050E3 		cmp	r0, #3
 649 0194 E400001A 		bne	.L58
 650 0198 6E0000EA 		b	.L57
 651              	.L55:
 652              	.LBB8:
 653              		.loc 5 204 0
 654 019c 0E30DDE5 		ldrb	r3, [sp, #14]	@ zero_extendqisi2
 655              	.LVL42:
 656 01a0 1C20DDE5 		ldrb	r2, [sp, #28]	@ zero_extendqisi2
 657 01a4 033062E0 		rsb	r3, r2, r3
 658 01a8 FF3003E2 		and	r3, r3, #255
 659              	.LVL43:
 660              		.loc 5 205 0
 661 01ac 170053E3 		cmp	r3, #23
 662 01b0 0F005313 		cmpne	r3, #15
 663 01b4 6E00000A 		beq	.L57
 664              	.LVL44:
 665 01b8 060053E3 		cmp	r3, #6
 666 01bc E100001A 		bne	.L60
 667              	.L57:
 668              	.LBE8:
 669              		.loc 5 210 0
 670 01c0 F0329FE5 		ldr	r3, .L90+16
 671              	.LVL45:
 672 01c4 002093E5 		ldr	r2, [r3, #0]
 673              	.LVL46:
 674 01c8 F4329FE5 		ldr	r3, .L90+28
 675 01cc F33092E1 		ldrsh	r3, [r2, r3]
 676 01d0 000053E3 		cmp	r3, #0
 677 01d4 E10000AA 		bge	.L60
 678              	.LBB9:
 211:layer1/prim_tch.c **** 		struct msgb *msg;
 212:layer1/prim_tch.c **** 		struct l1ctl_info_dl *dl;
 213:layer1/prim_tch.c **** 		struct l1ctl_data_ind *di;
 214:layer1/prim_tch.c **** 		uint16_t num_biterr;
 215:layer1/prim_tch.c **** 		uint32_t avg_snr = 0;
 216:layer1/prim_tch.c **** 		int32_t avg_dbm8 = 0;
 217:layer1/prim_tch.c **** 		int i, n;
 218:layer1/prim_tch.c **** 
 219:layer1/prim_tch.c **** 		/* Allocate msgb */
 220:layer1/prim_tch.c **** 			/* FIXME: we actually want all allocation out of L1S! */
 221:layer1/prim_tch.c **** 		msg = l1ctl_msgb_alloc(L1CTL_DATA_IND);
 679              		.loc 5 221 0
 680 01d8 0300A0E3 		mov	r0, #3
 681 01dc FEFFFFEB 		bl	l1ctl_msgb_alloc
 222:layer1/prim_tch.c **** 		if(!msg) {
 682              		.loc 5 222 0
 683 01e0 007050E2 		subs	r7, r0, #0
 684              	.LVL47:
 685 01e4 7B00001A 		bne	.L62
 223:layer1/prim_tch.c **** 			printf("TCH FACCH: unable to allocate msgb\n");
 686              		.loc 5 223 0
 687 01e8 D8029FE5 		ldr	r0, .L90+32
 688 01ec FEFFFFEB 		bl	puts
 689 01f0 CD0000EA 		b	.L64
 690              	.L62:
 224:layer1/prim_tch.c **** 			goto skip_rx_facch;
 225:layer1/prim_tch.c **** 		}
 226:layer1/prim_tch.c **** 
 227:layer1/prim_tch.c **** 		dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 691              		.loc 5 227 0
 692 01f4 0C10A0E3 		mov	r1, #12
 693 01f8 FEFFFFEB 		bl	msgb_put
 228:layer1/prim_tch.c **** 		di = (struct l1ctl_data_ind *) msgb_put(msg, sizeof(*di));
 694              		.loc 5 228 0
 695 01fc 1710A0E3 		mov	r1, #23
 696              		.loc 5 227 0
 697 0200 0050A0E1 		mov	r5, r0
 698              	.LVL48:
 699              		.loc 5 228 0
 700 0204 0700A0E1 		mov	r0, r7
 701 0208 FEFFFFEB 		bl	msgb_put
 229:layer1/prim_tch.c **** 
 230:layer1/prim_tch.c **** 		/* Fill DL header (should be about the first burst ... here is the last) */
 231:layer1/prim_tch.c **** 		dl->chan_nr = chan_nr;
 232:layer1/prim_tch.c **** 		dl->link_id = 0x00;	/* FACCH */
 702              		.loc 5 232 0
 703 020c 0040A0E3 		mov	r4, #0
 704              		.loc 5 231 0
 705 0210 00A0C5E5 		strb	sl, [r5, #0]
 706              		.loc 5 232 0
 707 0214 0140C5E5 		strb	r4, [r5, #1]
 708              		.loc 5 228 0
 709 0218 0080A0E1 		mov	r8, r0
 710              	.LVL49:
 233:layer1/prim_tch.c **** 		dl->band_arfcn = htons(arfcn);
 711              		.loc 5 233 0
 712 021c BA01DDE1 		ldrh	r0, [sp, #26]
 713 0220 FEFFFFEB 		bl	__fswab16
 714 0224 2034A0E1 		mov	r3, r0, lsr #8
 715 0228 0330C5E5 		strb	r3, [r5, #3]
 716 022c 0200C5E5 		strb	r0, [r5, #2]
 234:layer1/prim_tch.c **** 		dl->frame_nr = htonl(rx_time.fn);
 717              		.loc 5 234 0
 718 0230 08009DE5 		ldr	r0, [sp, #8]
 719 0234 FEFFFFEB 		bl	__fswab32
 720 0238 201CA0E1 		mov	r1, r0, lsr #24
 721 023c 2034A0E1 		mov	r3, r0, lsr #8
 722 0240 2028A0E1 		mov	r2, r0, lsr #16
 723 0244 0530C5E5 		strb	r3, [r5, #5]
 724 0248 0710C5E5 		strb	r1, [r5, #7]
 725 024c 0400C5E5 		strb	r0, [r5, #4]
 726 0250 0620C5E5 		strb	r2, [r5, #6]
 235:layer1/prim_tch.c **** 
 236:layer1/prim_tch.c **** 		/* Average SNR & RX level */
 237:layer1/prim_tch.c **** 		n = tch_f_hn ? 8 : 6;
 727              		.loc 5 237 0
 728 0254 58329FE5 		ldr	r3, .L90+12
 729 0258 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 730 025c 1D30DDE5 		ldrb	r3, [sp, #29]	@ zero_extendqisi2
 731 0260 040053E1 		cmp	r3, r4
 732 0264 0660A003 		moveq	r6, #6
 733              	.LVL50:
 734 0268 0860A013 		movne	r6, #8
 735 026c 081082E2 		add	r1, r2, #8
 736              	.LVL51:
 737 0270 0400A0E1 		mov	r0, r4
 738              	.LVL52:
 739 0274 04C0A0E1 		mov	ip, r4
 740              	.LVL53:
 741 0278 A90000EA 		b	.L68
 742              	.L69:
 743              	.LBB10:
 238:layer1/prim_tch.c **** 		for (i=0; i<n; i++) {
 239:layer1/prim_tch.c **** 			int j = (meas_id + FACCH_MEAS_HIST - i) % FACCH_MEAS_HIST;
 744              		.loc 5 239 0
 745 027c 1E3111E2 		ands	r3, r1, #-2147483641
 746 0280 01304342 		submi	r3, r3, #1
 747 0284 833EE041 		mvnmi	r3, r3, asl #29
 748 0288 A33EE041 		mvnmi	r3, r3, lsr #29
 749 028c 01308342 		addmi	r3, r3, #1
 240:layer1/prim_tch.c **** 			avg_snr += rx_tch.meas[j].snr;
 750              		.loc 5 240 0
 751 0290 8331A0E1 		mov	r3, r3, asl #3
 752 0294 0E2083E0 		add	r2, r3, lr
 241:layer1/prim_tch.c **** 			avg_dbm8 += rx_tch.meas[j].pm_dbm8;
 753              		.loc 5 241 0
 754 0298 F420D2E1 		ldrsh	r2, [r2, #4]
 755              		.loc 5 240 0
 756 029c BE3093E1 		ldrh	r3, [r3, lr]
 757              	.LBE10:
 758              		.loc 5 238 0
 759 02a0 011041E2 		sub	r1, r1, #1
 760              	.LBB11:
 761              		.loc 5 240 0
 762 02a4 030080E0 		add	r0, r0, r3
 763              		.loc 5 241 0
 764 02a8 024084E0 		add	r4, r4, r2
 765              	.L68:
 766              	.LBE11:
 767              		.loc 5 238 0
 768 02ac 06005CE1 		cmp	ip, r6
 769              	.LBB12:
 770              		.loc 5 240 0
 771 02b0 04E29FE5 		ldr	lr, .L90+20
 772              	.LBE12:
 773              		.loc 5 238 0
 774 02b4 01C08CE2 		add	ip, ip, #1
 775 02b8 9D0000BA 		blt	.L69
 242:layer1/prim_tch.c **** 		}
 243:layer1/prim_tch.c **** 
 244:layer1/prim_tch.c **** 		dl->snr = avg_snr / n;
 776              		.loc 5 244 0
 777 02bc 0610A0E1 		mov	r1, r6
 778 02c0 FEFFFFEB 		bl	__udivsi3
 779              	.LVL54:
 245:layer1/prim_tch.c **** 		dl->rx_level = dbm2rxlev(avg_dbm8 / (8*n));
 780              		.loc 5 245 0
 781 02c4 8611A0E1 		mov	r1, r6, asl #3
 782              		.loc 5 244 0
 783 02c8 0900C5E5 		strb	r0, [r5, #9]
 784              		.loc 5 245 0
 785 02cc 0400A0E1 		mov	r0, r4
 786 02d0 FEFFFFEB 		bl	__divsi3
 787 02d4 FEFFFFEB 		bl	dbm2rxlev
 246:layer1/prim_tch.c **** 
 247:layer1/prim_tch.c **** 		/* Errors & CRC status */
 248:layer1/prim_tch.c **** 		num_biterr = dsp_api.ndb->a_fd[2] & 0xffff;
 788              		.loc 5 248 0
 789 02d8 D8319FE5 		ldr	r3, .L90+16
 790              		.loc 5 245 0
 791 02dc 0800C5E5 		strb	r0, [r5, #8]
 792              		.loc 5 248 0
 793 02e0 002093E5 		ldr	r2, [r3, #0]
 794 02e4 E0319FE5 		ldr	r3, .L90+36
 795 02e8 B33092E1 		ldrh	r3, [r2, r3]
 796              	.LVL55:
 249:layer1/prim_tch.c **** 		if (num_biterr > 0xff)
 797              		.loc 5 249 0
 798 02ec FF0053E3 		cmp	r3, #255
 250:layer1/prim_tch.c **** 			dl->num_biterr = 0xff;
 799              		.loc 5 250 0
 800 02f0 0030E083 		mvnhi	r3, #0
 801              	.LVL56:
 802              	.LVL57:
 251:layer1/prim_tch.c **** 		else
 252:layer1/prim_tch.c **** 			dl->num_biterr = num_biterr;
 803              		.loc 5 252 0
 804 02f4 0A30C5E5 		strb	r3, [r5, #10]
 253:layer1/prim_tch.c **** 
 254:layer1/prim_tch.c **** 		dl->fire_crc = ((dsp_api.ndb->a_fd[0] & 0xffff) & ((1 << B_FIRE1) | (1 << B_FIRE0))) >> B_FIRE0;
 805              		.loc 5 254 0
 806 02f8 B8419FE5 		ldr	r4, .L90+16
 807              	.LVL58:
 808 02fc C0319FE5 		ldr	r3, .L90+28
 809              	.LVL59:
 810 0300 002094E5 		ldr	r2, [r4, #0]
 811 0304 B33092E1 		ldrh	r3, [r2, r3]
 812 0308 603003E2 		and	r3, r3, #96
 813 030c C332A0E1 		mov	r3, r3, asr #5
 814 0310 0B30C5E5 		strb	r3, [r5, #11]
 255:layer1/prim_tch.c **** 
 256:layer1/prim_tch.c **** 		/* Update rx level for pm report */
 257:layer1/prim_tch.c **** 		pu_update_rx_level(dl->rx_level);
 815              		.loc 5 257 0
 816 0314 0800D5E5 		ldrb	r0, [r5, #8]	@ zero_extendqisi2
 817 0318 FEFFFFEB 		bl	pu_update_rx_level
 258:layer1/prim_tch.c **** 
 259:layer1/prim_tch.c **** 		/* Copy actual data, skipping the information block [0,1,2] */
 260:layer1/prim_tch.c **** 		dsp_memcpy_from_api(di->data, &dsp_api.ndb->a_fd[3], 23, 0);
 818              		.loc 5 260 0
 819 031c 001094E5 		ldr	r1, [r4, #0]
 820 0320 0800A0E1 		mov	r0, r8
 821 0324 221E81E2 		add	r1, r1, #544
 822 0328 1720A0E3 		mov	r2, #23
 823 032c 0030A0E3 		mov	r3, #0
 824 0330 FEFFFFEB 		bl	dsp_memcpy_from_api
 261:layer1/prim_tch.c **** 
 262:layer1/prim_tch.c **** 		/* Give message to up layer */
 263:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 825              		.loc 5 263 0
 826 0334 0700A0E1 		mov	r0, r7
 827 0338 FEFFFFEB 		bl	l1_queue_for_l2
 828              	.L64:
 264:layer1/prim_tch.c **** 
 265:layer1/prim_tch.c **** 	skip_rx_facch:
 266:layer1/prim_tch.c **** 		/* Reset A_FD header (needed by DSP) */
 267:layer1/prim_tch.c **** 		/* B_FIRE1 =1, B_FIRE0 =0 , BLUD =0 */
 268:layer1/prim_tch.c **** 		dsp_api.ndb->a_fd[0] = (1<<B_FIRE1);
 829              		.loc 5 268 0
 830 033c 74319FE5 		ldr	r3, .L90+16
 831 0340 002093E5 		ldr	r2, [r3, #0]
 269:layer1/prim_tch.c **** 		dsp_api.ndb->a_fd[2] = 0xffff;
 270:layer1/prim_tch.c **** 
 271:layer1/prim_tch.c **** 		/* Reset A_DD_0 header in NDB (needed by DSP) */
 272:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_0[0] = 0;
 273:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_0[2] = 0xffff;
 274:layer1/prim_tch.c **** 
 275:layer1/prim_tch.c **** 		/* Reset A_DD_1 header in NDB (needed by DSP) */
 276:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_1[0] = 0;
 277:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_1[2] = 0xffff;
 832              		.loc 5 277 0
 833 0344 0010E0E3 		mvn	r1, #0	@ movhi
 834 0348 433FA0E3 		mov	r3, #268
 835 034c B31082E1 		strh	r1, [r2, r3]	@ movhi
 836              		.loc 5 268 0
 837 0350 6C319FE5 		ldr	r3, .L90+28
 838 0354 4010A0E3 		mov	r1, #64	@ movhi
 839 0358 B31082E1 		strh	r1, [r2, r3]	@ movhi
 840              		.loc 5 269 0
 841 035c 043083E2 		add	r3, r3, #4
 842 0360 0010E0E3 		mvn	r1, #0	@ movhi
 843 0364 B31082E1 		strh	r1, [r2, r3]	@ movhi
 844              		.loc 5 272 0
 845 0368 1A3083E2 		add	r3, r3, #26
 846 036c 0010A0E3 		mov	r1, #0	@ movhi
 847 0370 B31082E1 		strh	r1, [r2, r3]	@ movhi
 848              		.loc 5 273 0
 849 0374 043083E2 		add	r3, r3, #4
 850 0378 0010E0E3 		mvn	r1, #0	@ movhi
 851 037c B31082E1 		strh	r1, [r2, r3]	@ movhi
 852              		.loc 5 276 0
 853 0380 4D3F43E2 		sub	r3, r3, #308
 854 0384 0010A0E3 		mov	r1, #0	@ movhi
 855 0388 B31082E1 		strh	r1, [r2, r3]	@ movhi
 856              	.LVL60:
 857              	.L60:
 858              	.LBE9:
 278:layer1/prim_tch.c **** 	}
 279:layer1/prim_tch.c **** 
 280:layer1/prim_tch.c **** 	/* Traffic now ? */
 281:layer1/prim_tch.c **** 	if (tch_f_hn) {
 859              		.loc 5 281 0
 860 038c 1D30DDE5 		ldrb	r3, [sp, #29]	@ zero_extendqisi2
 861              	.LVL61:
 862 0390 000053E3 		cmp	r3, #0
 863 0394 EC00000A 		beq	.L75
 864              	.L58:
 282:layer1/prim_tch.c **** 		/* TCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) (mod 13)*/
 283:layer1/prim_tch.c **** 		traffic_rx_now = ((rx_time.fn % 13) % 4) == 3;
 865              		.loc 5 283 0
 866 0398 08009DE5 		ldr	r0, [sp, #8]
 867 039c 0D10A0E3 		mov	r1, #13
 868 03a0 FEFFFFEB 		bl	__umodsi3
 869 03a4 030000E2 		and	r0, r0, #3
 870 03a8 030050E3 		cmp	r0, #3
 871 03ac 0000A013 		movne	r0, #0
 872 03b0 0100A003 		moveq	r0, #1
 873              	.LVL62:
 874 03b4 F60000EA 		b	.L76
 875              	.LVL63:
 876              	.L75:
 284:layer1/prim_tch.c **** 	} else {
 285:layer1/prim_tch.c **** 		/* TCH/H0: B0(0,2,4,6),B1(4,6,8,10),B2(8,10,0,2) (mod 13) */
 286:layer1/prim_tch.c **** 		/*     H1: B0(1,3,5,7),B1(5,7,9,11),B2(9,11,1,3) (mod 13) */
 287:layer1/prim_tch.c **** 		traffic_rx_now = (((rx_time.fn - tch_sub + 13) % 13) % 4) == 2;
 877              		.loc 5 287 0
 878 03b8 1C30DDE5 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 879 03bc 08009DE5 		ldr	r0, [sp, #8]
 880 03c0 000063E0 		rsb	r0, r3, r0
 881 03c4 0D0080E2 		add	r0, r0, #13
 882 03c8 0D10A0E3 		mov	r1, #13
 883 03cc FEFFFFEB 		bl	__umodsi3
 884 03d0 030000E2 		and	r0, r0, #3
 885 03d4 020050E3 		cmp	r0, #2
 886 03d8 0000A013 		movne	r0, #0
 887 03dc 0100A003 		moveq	r0, #1
 888              	.LVL64:
 889              	.L76:
 288:layer1/prim_tch.c **** 	}
 289:layer1/prim_tch.c **** 
 290:layer1/prim_tch.c **** 	if (traffic_rx_now) {
 890              		.loc 5 290 0
 891 03e0 000050E3 		cmp	r0, #0
 892 03e4 2201000A 		beq	.L77
 893              	.LBB13:
 291:layer1/prim_tch.c **** 		volatile uint16_t *traffic_buf;
 292:layer1/prim_tch.c **** 
 293:layer1/prim_tch.c **** 		traffic_buf = tch_sub ? dsp_api.ndb->a_dd_1 : dsp_api.ndb->a_dd_0;
 894              		.loc 5 293 0
 895 03e8 1C30DDE5 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 896 03ec 000053E3 		cmp	r3, #0
 897 03f0 C0309FE5 		ldr	r3, .L90+16
 898 03f4 00309315 		ldrne	r3, [r3, #0]
 899 03f8 00309305 		ldreq	r3, [r3, #0]
 900 03fc 424F8312 		addne	r4, r3, #264
 901 0400 8E4F8302 		addeq	r4, r3, #568
 294:layer1/prim_tch.c **** 
 295:layer1/prim_tch.c **** 		if (traffic_buf[0] & (1<<B_BLUD)) {
 902              		.loc 5 295 0
 903 0404 B030D4E1 		ldrh	r3, [r4, #0]
 904 0408 020913E3 		tst	r3, #32768
 905 040c 2201000A 		beq	.L77
 296:layer1/prim_tch.c **** 			/* Send the data to upper layers (if interested and good frame) */
 297:layer1/prim_tch.c **** 			if ((l1s.audio_mode & AUDIO_RX_TRAFFIC_IND) &&
 906              		.loc 5 297 0
 907 0410 90309FE5 		ldr	r3, .L90
 908 0414 4C3AD3E5 		ldrb	r3, [r3, #2636]	@ zero_extendqisi2
 909 0418 080013E3 		tst	r3, #8
 910 041c 1E01000A 		beq	.L83
 911 0420 90309FE5 		ldr	r3, .L90+16
 912 0424 002093E5 		ldr	r2, [r3, #0]
 913 0428 8E3FA0E3 		mov	r3, #568
 914 042c B33092E1 		ldrh	r3, [r2, r3]
 915 0430 040013E3 		tst	r3, #4
 916 0434 1E01001A 		bne	.L83
 917              	.LBB14:
 298:layer1/prim_tch.c **** 			    !(dsp_api.ndb->a_dd_0[0] & (1<<B_BFI))) {
 299:layer1/prim_tch.c **** 				struct msgb *msg;
 300:layer1/prim_tch.c **** 				struct l1ctl_info_dl *dl;
 301:layer1/prim_tch.c **** 				struct l1ctl_traffic_ind *ti;
 302:layer1/prim_tch.c **** 
 303:layer1/prim_tch.c **** 				/* Allocate msgb */
 304:layer1/prim_tch.c **** 				/* FIXME: we actually want all allocation out of L1S! */
 305:layer1/prim_tch.c **** 				msg = l1ctl_msgb_alloc(L1CTL_TRAFFIC_IND);
 918              		.loc 5 305 0
 919 0438 1E00A0E3 		mov	r0, #30
 920              	.LVL65:
 921 043c FEFFFFEB 		bl	l1ctl_msgb_alloc
 306:layer1/prim_tch.c **** 				if(!msg) {
 922              		.loc 5 306 0
 923 0440 005050E2 		subs	r5, r0, #0
 924              	.LVL66:
 925 0444 1301001A 		bne	.L86
 307:layer1/prim_tch.c **** 					printf("TCH traffic: unable to allocate msgb\n");
 926              		.loc 5 307 0
 927 0448 80009FE5 		ldr	r0, .L90+40
 928 044c FEFFFFEB 		bl	puts
 929 0450 1E0100EA 		b	.L83
 930              	.L86:
 308:layer1/prim_tch.c **** 					goto skip_rx_traffic;
 309:layer1/prim_tch.c **** 				}
 310:layer1/prim_tch.c **** 
 311:layer1/prim_tch.c **** 				dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 931              		.loc 5 311 0
 932 0454 0C10A0E3 		mov	r1, #12
 933 0458 FEFFFFEB 		bl	msgb_put
 312:layer1/prim_tch.c **** 				ti = (struct l1ctl_traffic_ind *) msgb_put(msg, sizeof(*ti));
 934              		.loc 5 312 0
 935 045c 2810A0E3 		mov	r1, #40
 936 0460 0500A0E1 		mov	r0, r5
 937 0464 FEFFFFEB 		bl	msgb_put
 313:layer1/prim_tch.c **** 
 314:layer1/prim_tch.c **** 				/* Copy actual data, skipping the information block [0,1,2] */
 315:layer1/prim_tch.c **** 				dsp_memcpy_from_api(ti->data, &traffic_buf[3], 33, 1);
 938              		.loc 5 315 0
 939 0468 061084E2 		add	r1, r4, #6
 940 046c 2120A0E3 		mov	r2, #33
 941 0470 0130A0E3 		mov	r3, #1
 942 0474 FEFFFFEB 		bl	dsp_memcpy_from_api
 316:layer1/prim_tch.c **** 
 317:layer1/prim_tch.c **** 				/* Give message to up layer */
 318:layer1/prim_tch.c **** 				l1_queue_for_l2(msg);
 943              		.loc 5 318 0
 944 0478 0500A0E1 		mov	r0, r5
 945 047c FEFFFFEB 		bl	l1_queue_for_l2
 946              	.LVL67:
 947              	.L83:
 948              	.LBE14:
 319:layer1/prim_tch.c **** 			}
 320:layer1/prim_tch.c **** 
 321:layer1/prim_tch.c **** 	skip_rx_traffic:
 322:layer1/prim_tch.c **** 			/* Reset traffic buffer header in NDB (needed by DSP) */
 323:layer1/prim_tch.c **** 			traffic_buf[0] = 0;
 949              		.loc 5 323 0
 950 0480 0020A0E3 		mov	r2, #0	@ movhi
 324:layer1/prim_tch.c **** 			traffic_buf[2] = 0xffff;
 951              		.loc 5 324 0
 952 0484 0030E0E3 		mvn	r3, #0	@ movhi
 953              		.loc 5 323 0
 954 0488 B020C4E1 		strh	r2, [r4, #0]	@ movhi
 955              		.loc 5 324 0
 956 048c B430C4E1 		strh	r3, [r4, #4]	@ movhi
 957              	.L77:
 958              	.LBE13:
 325:layer1/prim_tch.c **** 		}
 326:layer1/prim_tch.c **** 	}
 327:layer1/prim_tch.c **** 
 328:layer1/prim_tch.c **** 	/* mark READ page as being used */
 329:layer1/prim_tch.c **** 	dsp_api.r_page_used = 1;
 959              		.loc 5 329 0
 960 0490 20309FE5 		ldr	r3, .L90+16
 961 0494 0120A0E3 		mov	r2, #1
 330:layer1/prim_tch.c **** 
 331:layer1/prim_tch.c **** 	return 0;
 332:layer1/prim_tch.c **** }
 962              		.loc 5 332 0
 963 0498 0000A0E3 		mov	r0, #0
 964              	.LVL68:
 965              		.loc 5 329 0
 966 049c 182083E5 		str	r2, [r3, #24]
 967              		.loc 5 332 0
 968 04a0 20D08DE2 		add	sp, sp, #32
 969 04a4 F085BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, pc}
 970              	.L91:
 971              		.align	2
 972              	.L90:
 973 04a8 00000000 		.word	l1s
 974 04ac FF6F2900 		.word	2715647
 975 04b0 00702900 		.word	2715648
 976 04b4 00000000 		.word	meas_id.4330
 977 04b8 00000000 		.word	dsp_api
 978 04bc 34000000 		.word	rx_tch
 979 04c0 C0500100 		.word	86208
 980 04c4 1A020000 		.word	538
 981 04c8 34000000 		.word	.LC1
 982 04cc 1E020000 		.word	542
 983 04d0 58000000 		.word	.LC2
 984              	.LFE70:
 986              		.bss
 987 0001 000000   		.align	2
 988              	icnt.4508:
 989 0004 00000000 		.space	4
 990              		.section	.text.l1s_tch_cmd,"ax",%progbits
 991              		.align	2
 993              	l1s_tch_cmd:
 994              	.LFB71:
 333:layer1/prim_tch.c **** 
 334:layer1/prim_tch.c **** static int l1s_tch_cmd(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 335:layer1/prim_tch.c **** {
 995              		.loc 5 335 0
 996              		@ args = 0, pretend = 0, frame = 12
 997              		@ frame_needed = 0, uses_anonymous_args = 0
 998              	.LVL69:
 999 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 1000              	.LCFI6:
 1001 0004 0248A0E1 		mov	r4, r2, asl #16
 1002 0008 18D04DE2 		sub	sp, sp, #24
 1003              	.LCFI7:
 1004              	.LVL70:
 1005              		.loc 5 335 0
 1006 000c 2448A0E1 		mov	r4, r4, lsr #16
 336:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 337:layer1/prim_tch.c **** 	uint8_t chan_nr;
 338:layer1/prim_tch.c **** 	uint16_t arfcn;
 339:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 340:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub, tch_mode;
 341:layer1/prim_tch.c **** 	uint32_t fn_report;
 342:layer1/prim_tch.c **** 	uint8_t sync = 0;
 343:layer1/prim_tch.c **** 	static int icnt;
 344:layer1/prim_tch.c **** 	int facch_tx_now, traffic_tx_now;
 345:layer1/prim_tch.c **** 
 346:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 347:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, &arfcn, &tsc, &tn);
 1007              		.loc 5 347 0
 1008 0010 17208DE2 		add	r2, sp, #23
 1009              	.LVL71:
 1010 0014 16308DE2 		add	r3, sp, #22
 1011 0018 24039FE5 		ldr	r0, .L127
 1012              	.LVL72:
 1013 001c 10108DE2 		add	r1, sp, #16
 1014              	.LVL73:
 348:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1015              		.loc 5 348 0
 1016 0020 FF4004E2 		and	r4, r4, #255
 1017              	.LVL74:
 1018              		.loc 5 347 0
 1019 0024 FEFFFFEB 		bl	rfch_get_params
 1020              	.LVL75:
 1021              		.loc 5 348 0
 1022 0028 1610DDE5 		ldrb	r1, [sp, #22]	@ zero_extendqisi2
 1023 002c 0400A0E1 		mov	r0, r4
 1024 0030 FEFFFFEB 		bl	mframe_task2chan_nr
 349:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 1025              		.loc 5 349 0
 1026 0034 14C08DE2 		add	ip, sp, #20
 1027              		.loc 5 348 0
 1028 0038 0010A0E1 		mov	r1, r0
 1029              		.loc 5 349 0
 1030 003c 0C208DE2 		add	r2, sp, #12
 1031 0040 FC029FE5 		ldr	r0, .L127
 1032 0044 00C08DE5 		str	ip, [sp, #0]
 1033 0048 15308DE2 		add	r3, sp, #21
 1034 004c 13C08DE2 		add	ip, sp, #19
 1035 0050 04C08DE5 		str	ip, [sp, #4]
 1036 0054 FEFFFFEB 		bl	tch_get_params
 350:layer1/prim_tch.c **** 
 351:layer1/prim_tch.c **** 	/* Sync & FACCH delay */
 352:layer1/prim_tch.c **** 	if (l1s.tch_sync) {
 1037              		.loc 5 352 0
 1038 0058 E8029FE5 		ldr	r0, .L127+4
 1039 005c 4B2AD0E5 		ldrb	r2, [r0, #2635]	@ zero_extendqisi2
 1040 0060 000052E3 		cmp	r2, #0
 1041 0064 E0129FE5 		ldr	r1, .L127+8
 353:layer1/prim_tch.c **** 		l1s.tch_sync = 0;
 1042              		.loc 5 353 0
 1043 0068 0030A013 		movne	r3, #0
 354:layer1/prim_tch.c **** 		sync = 1;
 355:layer1/prim_tch.c **** 		icnt = 0;
 1044              		.loc 5 355 0
 1045 006c 0170A013 		movne	r7, #1
 1046              	.LVL76:
 1047 0070 00308115 		strne	r3, [r1, #0]
 1048              		.loc 5 353 0
 1049 0074 4B3AC015 		strneb	r3, [r0, #2635]
 1050 0078 2200001A 		bne	.L95
 1051              	.LVL77:
 1052              	.L93:
 356:layer1/prim_tch.c **** 	} else if (icnt <= 26)
 1053              		.loc 5 356 0
 1054 007c 003091E5 		ldr	r3, [r1, #0]
 1055 0080 1A0053E3 		cmp	r3, #26
 357:layer1/prim_tch.c **** 		icnt++;
 1056              		.loc 5 357 0
 1057 0084 013083D2 		addle	r3, r3, #1
 1058 0088 003081D5 		strle	r3, [r1, #0]
 1059 008c 0270A0E1 		mov	r7, r2
 1060              	.LVL78:
 1061              	.L95:
 1062              	.LVL79:
 358:layer1/prim_tch.c **** 
 359:layer1/prim_tch.c **** 	/* Load FACCH data if we start a new burst */
 360:layer1/prim_tch.c **** 	/* (the DSP wants the data on the CMD of the burst _preceding_ the
 361:layer1/prim_tch.c **** 	 * first burst) */
 362:layer1/prim_tch.c **** 	if (tch_f_hn) {
 1063              		.loc 5 362 0
 1064 0090 1530DDE5 		ldrb	r3, [sp, #21]	@ zero_extendqisi2
 1065 0094 000053E3 		cmp	r3, #0
 1066 0098 A8329FE5 		ldr	r3, .L127+4
 1067 009c 2D00000A 		beq	.L98
 363:layer1/prim_tch.c **** 		/* FACCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) */
 364:layer1/prim_tch.c **** 		facch_tx_now = ((l1s.next_time.fn % 13) % 4) == 3;
 365:layer1/prim_tch.c **** 	} else {
 366:layer1/prim_tch.c **** 		/* FAACH/H: See GSM 05.02 Clause 7 Table 1of9 */
 367:layer1/prim_tch.c **** 		uint8_t t2_norm = l1s.next_time.t2 - tch_sub;
 368:layer1/prim_tch.c **** 		facch_tx_now = (t2_norm == 23) ||
 369:layer1/prim_tch.c **** 		               (t2_norm ==  6) ||
 370:layer1/prim_tch.c **** 		               (t2_norm == 15);
 371:layer1/prim_tch.c **** 	}
 372:layer1/prim_tch.c **** 
 373:layer1/prim_tch.c **** 	if (facch_tx_now) {
 1068              		.loc 5 373 0
 1069 00a0 0C0093E5 		ldr	r0, [r3, #12]
 1070 00a4 0D10A0E3 		mov	r1, #13
 1071 00a8 FEFFFFEB 		bl	__umodsi3
 1072 00ac 030000E2 		and	r0, r0, #3
 1073 00b0 030050E3 		cmp	r0, #3
 1074 00b4 6500001A 		bne	.L101
 1075 00b8 360000EA 		b	.L100
 1076              	.L98:
 1077              	.LBB15:
 1078              		.loc 5 367 0
 1079 00bc 1230D3E5 		ldrb	r3, [r3, #18]	@ zero_extendqisi2
 1080              	.LVL80:
 1081 00c0 1420DDE5 		ldrb	r2, [sp, #20]	@ zero_extendqisi2
 1082 00c4 033062E0 		rsb	r3, r2, r3
 1083 00c8 FF3003E2 		and	r3, r3, #255
 1084              	.LVL81:
 1085              		.loc 5 368 0
 1086 00cc 060053E3 		cmp	r3, #6
 1087 00d0 17005313 		cmpne	r3, #23
 1088 00d4 3600000A 		beq	.L100
 1089              	.LVL82:
 1090 00d8 0F0053E3 		cmp	r3, #15
 1091 00dc 6200001A 		bne	.L103
 1092              	.L100:
 1093              	.LBE15:
 1094              	.LBB16:
 374:layer1/prim_tch.c **** 		uint16_t *info_ptr = dsp_api.ndb->a_fu;
 1095              		.loc 5 374 0
 1096 00e0 68329FE5 		ldr	r3, .L127+12
 1097              	.LVL83:
 1098 00e4 002093E5 		ldr	r2, [r3, #0]
 1099              	.LVL84:
 375:layer1/prim_tch.c **** 		struct msgb *msg;
 376:layer1/prim_tch.c **** 		const uint8_t *data;
 377:layer1/prim_tch.c **** 
 378:layer1/prim_tch.c **** 		/* Pull FACCH data (if ready) */
 379:layer1/prim_tch.c **** 		if (icnt > 26)
 1100              		.loc 5 379 0
 1101 00e8 5C329FE5 		ldr	r3, .L127+8
 1102 00ec 003093E5 		ldr	r3, [r3, #0]
 1103              		.loc 5 374 0
 1104 00f0 0A4D82E2 		add	r4, r2, #640
 1105              	.LVL85:
 1106              		.loc 5 379 0
 1107 00f4 1A0053E3 		cmp	r3, #26
 1108              		.loc 5 374 0
 1109 00f8 024084E2 		add	r4, r4, #2
 380:layer1/prim_tch.c **** 			msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_MAIN]);
 381:layer1/prim_tch.c **** 		else
 382:layer1/prim_tch.c **** 			msg = NULL;
 383:layer1/prim_tch.c **** 
 384:layer1/prim_tch.c **** 		/* If TX is empty and we're signalling only, use dummy frame */
 385:layer1/prim_tch.c **** 		if (msg)
 386:layer1/prim_tch.c **** 			data = msg->l3h;
 1110              		.loc 5 386 0
 1111 00fc 0050A0D3 		movle	r5, #0
 1112              	.LVL86:
 1113              		.loc 5 379 0
 1114 0100 440000DA 		ble	.L106
 1115              		.loc 5 380 0
 1116 0104 48029FE5 		ldr	r0, .L127+16
 1117 0108 FEFFFFEB 		bl	msgb_dequeue
 1118              		.loc 5 385 0
 1119 010c 005050E2 		subs	r5, r0, #0
 1120              		.loc 5 386 0
 1121 0110 18109515 		ldrne	r1, [r5, #24]
 1122              	.LVL87:
 1123              		.loc 5 385 0
 1124 0114 4900001A 		bne	.L108
 1125              	.L106:
 1126              	.LVL88:
 387:layer1/prim_tch.c **** 		else if (tch_mode == SIG_ONLY_MODE)
 1127              		.loc 5 387 0
 1128 0118 1330DDE5 		ldrb	r3, [sp, #19]	@ zero_extendqisi2
 1129 011c 000053E3 		cmp	r3, #0
 1130 0120 5400001A 		bne	.L109
 388:layer1/prim_tch.c **** 			data = pu_get_idle_frame();
 1131              		.loc 5 388 0
 1132 0124 FEFFFFEB 		bl	pu_get_idle_frame
 1133              	.LVL89:
 1134 0128 0010A0E1 		mov	r1, r0
 1135              	.LVL90:
 1136              	.L108:
 389:layer1/prim_tch.c **** 		else
 390:layer1/prim_tch.c **** 			data = NULL;
 391:layer1/prim_tch.c **** 
 392:layer1/prim_tch.c **** 		/* Do we really send something ? */
 393:layer1/prim_tch.c **** 		if (data) {
 1137              		.loc 5 393 0
 1138 012c 000051E3 		cmp	r1, #0
 1139 0130 5400000A 		beq	.L109
 394:layer1/prim_tch.c **** 			/* Fill data block header */
 395:layer1/prim_tch.c **** 			info_ptr[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 1140              		.loc 5 395 0
 1141 0134 0239A0E3 		mov	r3, #32768
 1142 0138 B030C4E1 		strh	r3, [r4, #0]	@ movhi
 396:layer1/prim_tch.c **** 			info_ptr[1] = 0;		/* 2nd word: cleared. */
 1143              		.loc 5 396 0
 1144 013c 0030A0E3 		mov	r3, #0	@ movhi
 1145 0140 B230C4E1 		strh	r3, [r4, #2]	@ movhi
 397:layer1/prim_tch.c **** 			info_ptr[2] = 0;		/* 3nd word: cleared. */
 1146              		.loc 5 397 0
 1147 0144 B430C4E1 		strh	r3, [r4, #4]	@ movhi
 398:layer1/prim_tch.c **** 
 399:layer1/prim_tch.c **** 			/* Copy the actual data after the header */
 400:layer1/prim_tch.c **** 			dsp_memcpy_to_api(&info_ptr[3], data, 23, 0);
 1148              		.loc 5 400 0
 1149 0148 060084E2 		add	r0, r4, #6
 1150 014c 1720A0E3 		mov	r2, #23
 1151 0150 0030A0E3 		mov	r3, #0
 1152 0154 FEFFFFEB 		bl	dsp_memcpy_to_api
 1153              	.LVL91:
 1154              	.L109:
 401:layer1/prim_tch.c **** 		}
 402:layer1/prim_tch.c **** 
 403:layer1/prim_tch.c **** 		/* Indicate completion (FIXME: early but easier this way for now) */
 404:layer1/prim_tch.c **** 		if (msg) {
 1155              		.loc 5 404 0
 1156 0158 000055E3 		cmp	r5, #0
 1157 015c 6200000A 		beq	.L103
 405:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 406:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_FACCH;
 1158              		.loc 5 406 0
 1159 0160 F0C19FE5 		ldr	ip, .L127+20
 1160              		.loc 5 405 0
 1161 0164 DC119FE5 		ldr	r1, .L127+4
 1162              	.LVL92:
 1163              		.loc 5 406 0
 1164 0168 B020DCE1 		ldrh	r2, [ip, #0]
 1165              		.loc 5 405 0
 1166 016c E8319FE5 		ldr	r3, .L127+24
 1167 0170 BC10D1E1 		ldrh	r1, [r1, #12]
 1168              		.loc 5 406 0
 1169 0174 022082E3 		orr	r2, r2, #2
 407:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 1170              		.loc 5 407 0
 1171 0178 0300A0E3 		mov	r0, #3
 1172              		.loc 5 405 0
 1173 017c B010C3E1 		strh	r1, [r3, #0]	@ movhi
 1174              		.loc 5 406 0
 1175 0180 B020CCE1 		strh	r2, [ip, #0]	@ movhi
 1176              		.loc 5 407 0
 1177 0184 FEFFFFEB 		bl	l1s_compl_sched
 408:layer1/prim_tch.c **** 		}
 409:layer1/prim_tch.c **** 
 410:layer1/prim_tch.c **** 		/* Free msg now that we're done with it */
 411:layer1/prim_tch.c **** 		if (msg)
 412:layer1/prim_tch.c **** 			msgb_free(msg);
 1178              		.loc 5 412 0
 1179 0188 0500A0E1 		mov	r0, r5
 1180 018c FEFFFFEB 		bl	msgb_free
 1181              	.LVL93:
 1182              	.L103:
 1183              	.LBE16:
 413:layer1/prim_tch.c **** 	}
 414:layer1/prim_tch.c **** 
 415:layer1/prim_tch.c **** 	/* Traffic now ? */
 416:layer1/prim_tch.c **** 	if (tch_f_hn) {
 1184              		.loc 5 416 0
 1185 0190 1530DDE5 		ldrb	r3, [sp, #21]	@ zero_extendqisi2
 1186              	.LVL94:
 1187 0194 000053E3 		cmp	r3, #0
 1188 0198 6E00000A 		beq	.L113
 1189              	.L101:
 417:layer1/prim_tch.c **** 		/* TCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) (mod 13)*/
 418:layer1/prim_tch.c **** 		traffic_tx_now = ((l1s.next_time.fn % 13) % 4) == 3;
 1190              		.loc 5 418 0
 1191 019c A4319FE5 		ldr	r3, .L127+4
 1192 01a0 0D10A0E3 		mov	r1, #13
 1193              	.LVL95:
 1194 01a4 0C0093E5 		ldr	r0, [r3, #12]
 1195 01a8 FEFFFFEB 		bl	__umodsi3
 1196 01ac 030000E2 		and	r0, r0, #3
 1197 01b0 030050E3 		cmp	r0, #3
 1198 01b4 0000A013 		movne	r0, #0
 1199 01b8 0100A003 		moveq	r0, #1
 1200              	.LVL96:
 1201 01bc 790000EA 		b	.L114
 1202              	.LVL97:
 1203              	.L113:
 419:layer1/prim_tch.c **** 	} else {
 420:layer1/prim_tch.c **** 		/* TCH/H0: B0(0,2,4,6),B1(4,6,8,10),B2(8,10,0,2) (mod 13) */
 421:layer1/prim_tch.c **** 		/*     H1: B0(1,3,5,7),B1(5,7,9,11),B2(9,11,1,3) (mod 13) */
 422:layer1/prim_tch.c **** 		traffic_tx_now = (((l1s.next_time.fn - tch_sub + 13) % 13) % 4) == 2;
 1204              		.loc 5 422 0
 1205 01c0 80319FE5 		ldr	r3, .L127+4
 1206 01c4 0C0093E5 		ldr	r0, [r3, #12]
 1207 01c8 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1208 01cc 000063E0 		rsb	r0, r3, r0
 1209 01d0 0D0080E2 		add	r0, r0, #13
 1210 01d4 0D10A0E3 		mov	r1, #13
 1211              	.LVL98:
 1212 01d8 FEFFFFEB 		bl	__umodsi3
 1213 01dc 030000E2 		and	r0, r0, #3
 1214 01e0 020050E3 		cmp	r0, #2
 1215 01e4 0000A013 		movne	r0, #0
 1216 01e8 0100A003 		moveq	r0, #1
 1217              	.LVL99:
 1218              	.L114:
 423:layer1/prim_tch.c **** 	}
 424:layer1/prim_tch.c **** 
 425:layer1/prim_tch.c **** 	if (traffic_tx_now) {
 1219              		.loc 5 425 0
 1220 01ec 000050E3 		cmp	r0, #0
 1221 01f0 A700000A 		beq	.L115
 1222              	.LBB17:
 426:layer1/prim_tch.c **** 		volatile uint16_t *traffic_buf;
 427:layer1/prim_tch.c **** 		struct msgb *msg;
 428:layer1/prim_tch.c **** 		const uint8_t *data;
 429:layer1/prim_tch.c **** 
 430:layer1/prim_tch.c **** 		/* Reset play mode */
 431:layer1/prim_tch.c **** 		dsp_api.ndb->d_tch_mode &= ~B_PLAY_UL;
 1223              		.loc 5 431 0
 1224 01f4 54319FE5 		ldr	r3, .L127+12
 1225 01f8 000093E5 		ldr	r0, [r3, #0]
 1226              	.LVL100:
 1227 01fc B630D0E1 		ldrh	r3, [r0, #6]
 1228 0200 0830C3E3 		bic	r3, r3, #8
 1229 0204 B630C0E1 		strh	r3, [r0, #6]	@ movhi
 432:layer1/prim_tch.c **** 
 433:layer1/prim_tch.c **** 		/* Check l1s audio mode */
 434:layer1/prim_tch.c **** 		if (!(l1s.audio_mode & AUDIO_TX_TRAFFIC_REQ))
 1230              		.loc 5 434 0
 1231 0208 38319FE5 		ldr	r3, .L127+4
 1232 020c 4C3AD3E5 		ldrb	r3, [r3, #2636]	@ zero_extendqisi2
 1233 0210 020013E3 		tst	r3, #2
 1234 0214 A700000A 		beq	.L115
 435:layer1/prim_tch.c **** 			goto skip_tx_traffic;
 436:layer1/prim_tch.c **** 
 437:layer1/prim_tch.c **** 		/* Traffic buffer = !tch_sub */
 438:layer1/prim_tch.c **** 		traffic_buf = tch_sub ? dsp_api.ndb->a_du_0 : dsp_api.ndb->a_du_1;
 1235              		.loc 5 438 0
 1236 0218 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 439:layer1/prim_tch.c **** 
 440:layer1/prim_tch.c **** 		/* Pull Traffic data (if any) */
 441:layer1/prim_tch.c **** 		msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 1237              		.loc 5 441 0
 1238 021c 3C619FE5 		ldr	r6, .L127+28
 1239              		.loc 5 438 0
 1240 0220 000053E3 		cmp	r3, #0
 1241 0224 2A4E8012 		addne	r4, r0, #672
 1242              	.LVL101:
 1243 0228 4D4F8002 		addeq	r4, r0, #308
 1244              		.loc 5 441 0
 1245 022c 0600A0E1 		mov	r0, r6
 1246 0230 FEFFFFEB 		bl	msgb_dequeue
 442:layer1/prim_tch.c **** 
 443:layer1/prim_tch.c **** 		/* Copy actual data, skipping the information block [0,1,2] */
 444:layer1/prim_tch.c **** 		if (msg) {
 1247              		.loc 5 444 0
 1248 0234 005050E2 		subs	r5, r0, #0
 1249              	.LVL102:
 1250 0238 A700000A 		beq	.L115
 445:layer1/prim_tch.c **** 			data = msg->l2h;
 446:layer1/prim_tch.c **** 			dsp_memcpy_to_api(&traffic_buf[3], data, 33, 1);
 1251              		.loc 5 446 0
 1252 023c 060084E2 		add	r0, r4, #6
 1253 0240 141095E5 		ldr	r1, [r5, #20]
 1254 0244 2120A0E3 		mov	r2, #33
 1255 0248 0130A0E3 		mov	r3, #1
 1256 024c FEFFFFEB 		bl	dsp_memcpy_to_api
 447:layer1/prim_tch.c **** 
 448:layer1/prim_tch.c **** 			traffic_buf[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 1257              		.loc 5 448 0
 1258 0250 0239A0E3 		mov	r3, #32768
 1259 0254 B030C4E1 		strh	r3, [r4, #0]	@ movhi
 449:layer1/prim_tch.c **** 			traffic_buf[1] = 0;		/* 2nd word: cleared. */
 450:layer1/prim_tch.c **** 			traffic_buf[2] = 0;		/* 3nd word: cleared. */
 451:layer1/prim_tch.c **** 		}
 452:layer1/prim_tch.c **** 
 453:layer1/prim_tch.c **** 		if (msg)
 454:layer1/prim_tch.c **** 			dsp_api.ndb->d_tch_mode |= B_PLAY_UL;
 1260              		.loc 5 454 0
 1261 0258 F0309FE5 		ldr	r3, .L127+12
 1262 025c 000093E5 		ldr	r0, [r3, #0]
 1263              		.loc 5 449 0
 1264 0260 0030A0E3 		mov	r3, #0	@ movhi
 1265 0264 B230C4E1 		strh	r3, [r4, #2]	@ movhi
 1266              		.loc 5 450 0
 1267 0268 B430C4E1 		strh	r3, [r4, #4]	@ movhi
 455:layer1/prim_tch.c **** 
 456:layer1/prim_tch.c **** 		/* Indicate completion (FIXME: early but easier this way for now) */
 457:layer1/prim_tch.c **** 		if (msg) {
 458:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 459:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_TRAFFIC;
 1268              		.loc 5 459 0
 1269 026c E4C09FE5 		ldr	ip, .L127+20
 1270              		.loc 5 454 0
 1271 0270 B630D0E1 		ldrh	r3, [r0, #6]
 1272              		.loc 5 459 0
 1273 0274 B020DCE1 		ldrh	r2, [ip, #0]
 1274              		.loc 5 454 0
 1275 0278 083083E3 		orr	r3, r3, #8
 1276 027c B630C0E1 		strh	r3, [r0, #6]	@ movhi
 1277              		.loc 5 458 0
 1278 0280 541A16E5 		ldr	r1, [r6, #-2644]
 1279 0284 D0309FE5 		ldr	r3, .L127+24
 1280              		.loc 5 459 0
 1281 0288 042082E3 		orr	r2, r2, #4
 460:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 1282              		.loc 5 460 0
 1283 028c 0300A0E3 		mov	r0, #3
 1284              		.loc 5 458 0
 1285 0290 B010C3E1 		strh	r1, [r3, #0]	@ movhi
 1286              		.loc 5 459 0
 1287 0294 B020CCE1 		strh	r2, [ip, #0]	@ movhi
 1288              		.loc 5 460 0
 1289 0298 FEFFFFEB 		bl	l1s_compl_sched
 461:layer1/prim_tch.c **** 		}
 462:layer1/prim_tch.c **** 
 463:layer1/prim_tch.c **** 		/* Free msg now that we're done with it */
 464:layer1/prim_tch.c **** 		if (msg)
 465:layer1/prim_tch.c **** 			msgb_free(msg);
 1290              		.loc 5 465 0
 1291 029c 0500A0E1 		mov	r0, r5
 1292 02a0 FEFFFFEB 		bl	msgb_free
 1293              	.LVL103:
 1294              	.L115:
 1295              	.LVL104:
 1296              	.LBE17:
 466:layer1/prim_tch.c **** 	}
 467:layer1/prim_tch.c **** skip_tx_traffic:
 468:layer1/prim_tch.c **** 
 469:layer1/prim_tch.c **** 	/* Configure DSP for TX/RX */
 470:layer1/prim_tch.c **** 	l1s_tx_apc_helper(arfcn);
 1297              		.loc 5 470 0
 1298 02a4 B001DDE1 		ldrh	r0, [sp, #16]
 1299              	.LVL105:
 1300 02a8 FEFFFFEB 		bl	l1s_tx_apc_helper
 471:layer1/prim_tch.c **** 
 472:layer1/prim_tch.c **** 	dsp_load_tch_param(
 1301              		.loc 5 472 0
 1302 02ac 1520DDE5 		ldrb	r2, [sp, #21]	@ zero_extendqisi2
 1303 02b0 16C0DDE5 		ldrb	ip, [sp, #22]	@ zero_extendqisi2
 1304 02b4 000052E3 		cmp	r2, #0
 1305 02b8 0220A003 		moveq	r2, #2
 1306 02bc 0120A013 		movne	r2, #1
 1307 02c0 0040A0E3 		mov	r4, #0
 1308              	.LVL106:
 1309 02c4 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1310 02c8 1310DDE5 		ldrb	r1, [sp, #19]	@ zero_extendqisi2
 1311 02cc 70009FE5 		ldr	r0, .L127
 1312 02d0 90108DE8 		stmia	sp, {r4, r7, ip}	@ phole stm
 1313 02d4 FEFFFFEB 		bl	dsp_load_tch_param
 473:layer1/prim_tch.c **** 		&l1s.next_time,
 474:layer1/prim_tch.c **** 		tch_mode, tch_f_hn ? TCH_F : TCH_H, tch_sub,
 475:layer1/prim_tch.c **** 		0, sync, tn
 476:layer1/prim_tch.c **** 	);
 477:layer1/prim_tch.c **** 
 478:layer1/prim_tch.c **** 	dsp_load_rx_task(
 1314              		.loc 5 478 0
 1315 02d8 0420A0E1 		mov	r2, r4
 1316 02dc B011DDE1 		ldrh	r1, [sp, #16]
 1317 02e0 0D00A0E3 		mov	r0, #13
 1318 02e4 FEFFFFEB 		bl	dsp_task_iq_swap
 1319 02e8 0410A0E1 		mov	r1, r4
 1320              	.LVL107:
 1321 02ec 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1322 02f0 FEFFFFEB 		bl	dsp_load_rx_task
 479:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHT_DSP_TASK, arfcn, 0),
 480:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCH */
 481:layer1/prim_tch.c **** 	);
 482:layer1/prim_tch.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_NB, 0);
 1323              		.loc 5 482 0
 1324 02f4 B001DDE1 		ldrh	r0, [sp, #16]
 1325 02f8 0420A0E1 		mov	r2, r4
 1326 02fc 0310A0E3 		mov	r1, #3
 1327 0300 FEFFFFEB 		bl	l1s_rx_win_ctrl
 483:layer1/prim_tch.c **** 
 484:layer1/prim_tch.c **** 	dsp_load_tx_task(
 1328              		.loc 5 484 0
 1329 0304 B011DDE1 		ldrh	r1, [sp, #16]
 1330 0308 0120A0E3 		mov	r2, #1
 1331 030c 0D00A0E3 		mov	r0, #13
 1332 0310 FEFFFFEB 		bl	dsp_task_iq_swap
 1333 0314 0410A0E1 		mov	r1, r4
 1334 0318 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1335 031c FEFFFFEB 		bl	dsp_load_tx_task
 485:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHT_DSP_TASK, arfcn, 1),
 486:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCH */
 487:layer1/prim_tch.c **** 	);
 488:layer1/prim_tch.c **** 	l1s_tx_win_ctrl(arfcn | ARFCN_UPLINK, L1_TXWIN_NB, 0, 3);
 1336              		.loc 5 488 0
 1337 0320 B001DDE1 		ldrh	r0, [sp, #16]
 1338 0324 0410A0E1 		mov	r1, r4
 1339 0328 010980E3 		orr	r0, r0, #16384
 1340 032c 0420A0E1 		mov	r2, r4
 1341 0330 0330A0E3 		mov	r3, #3
 1342 0334 FEFFFFEB 		bl	l1s_tx_win_ctrl
 489:layer1/prim_tch.c **** 
 490:layer1/prim_tch.c **** 	return 0;
 491:layer1/prim_tch.c **** }
 1343              		.loc 5 491 0
 1344 0338 0400A0E1 		mov	r0, r4
 1345 033c 18D08DE2 		add	sp, sp, #24
 1346 0340 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 1347              	.L128:
 1348              		.align	2
 1349              	.L127:
 1350 0344 0C000000 		.word	l1s+12
 1351 0348 00000000 		.word	l1s
 1352 034c 04000000 		.word	icnt.4508
 1353 0350 00000000 		.word	dsp_api
 1354 0354 500A0000 		.word	l1s+2640
 1355 0358 74000000 		.word	last_tx_tch_type
 1356 035c 76000000 		.word	last_tx_tch_fn
 1357 0360 600A0000 		.word	l1s+2656
 1358              	.LFE71:
 1360              		.section	.text.l1s_tch_d_resp,"ax",%progbits
 1361              		.align	2
 1363              	l1s_tch_d_resp:
 1364              	.LFB72:
 492:layer1/prim_tch.c **** 
 493:layer1/prim_tch.c **** 
 494:layer1/prim_tch.c **** const struct tdma_sched_item tch_sched_set[] = {
 495:layer1/prim_tch.c **** 	SCHED_ITEM_DT(l1s_tch_cmd, 0, 0, 0),	SCHED_END_FRAME(),
 496:layer1/prim_tch.c **** 						SCHED_END_FRAME(),
 497:layer1/prim_tch.c **** 	SCHED_ITEM(l1s_tch_resp, 0, 0, -4),	SCHED_END_FRAME(),
 498:layer1/prim_tch.c **** 	SCHED_END_SET()
 499:layer1/prim_tch.c **** };
 500:layer1/prim_tch.c **** 
 501:layer1/prim_tch.c **** 
 502:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
 503:layer1/prim_tch.c ****  * TCH/H: Dummy
 504:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
 505:layer1/prim_tch.c **** 
 506:layer1/prim_tch.c **** /* This task is needed to perform some operation in the DSP when there is
 507:layer1/prim_tch.c ****  * no data to be exchanged */
 508:layer1/prim_tch.c **** 
 509:layer1/prim_tch.c **** static int l1s_tch_d_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 510:layer1/prim_tch.c **** {
 1365              		.loc 5 510 0
 1366              		@ args = 0, pretend = 0, frame = 0
 1367              		@ frame_needed = 0, uses_anonymous_args = 0
 1368              		@ link register save eliminated.
 1369              	.LVL108:
 511:layer1/prim_tch.c **** 	/* mark READ page as being used */
 512:layer1/prim_tch.c **** 	dsp_api.r_page_used = 1;
 1370              		.loc 5 512 0
 1371 0000 0C309FE5 		ldr	r3, .L131
 1372 0004 0120A0E3 		mov	r2, #1
 1373              	.LVL109:
 513:layer1/prim_tch.c **** 
 514:layer1/prim_tch.c **** 	return 0;
 515:layer1/prim_tch.c **** }
 1374              		.loc 5 515 0
 1375 0008 0000A0E3 		mov	r0, #0
 1376              	.LVL110:
 1377              		.loc 5 510 0
 1378              		@ lr needed for prologue
 1379              		.loc 5 512 0
 1380 000c 182083E5 		str	r2, [r3, #24]
 1381              		.loc 5 515 0
 1382 0010 1EFF2FE1 		bx	lr
 1383              	.L132:
 1384              		.align	2
 1385              	.L131:
 1386 0014 00000000 		.word	dsp_api
 1387              	.LFE72:
 1389              		.section	.text.l1s_tch_d_cmd,"ax",%progbits
 1390              		.align	2
 1392              	l1s_tch_d_cmd:
 1393              	.LFB73:
 516:layer1/prim_tch.c **** 
 517:layer1/prim_tch.c **** static int l1s_tch_d_cmd(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 518:layer1/prim_tch.c **** {
 1394              		.loc 5 518 0
 1395              		@ args = 0, pretend = 0, frame = 12
 1396              		@ frame_needed = 0, uses_anonymous_args = 0
 1397              	.LVL111:
 1398 0000 10402DE9 		stmfd	sp!, {r4, lr}
 1399              	.LCFI8:
 1400 0004 0248A0E1 		mov	r4, r2, asl #16
 1401 0008 18D04DE2 		sub	sp, sp, #24
 1402              	.LCFI9:
 1403              	.LVL112:
 1404              		.loc 5 518 0
 1405 000c 2448A0E1 		mov	r4, r4, lsr #16
 519:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 520:layer1/prim_tch.c **** 	uint8_t chan_nr;
 521:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 522:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub, tch_mode;
 523:layer1/prim_tch.c **** 	uint32_t fn_report;
 524:layer1/prim_tch.c **** 
 525:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 526:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, NULL, &tsc, &tn);
 1406              		.loc 5 526 0
 1407 0010 17208DE2 		add	r2, sp, #23
 1408              	.LVL113:
 1409 0014 16308DE2 		add	r3, sp, #22
 1410 0018 98009FE5 		ldr	r0, .L138
 1411              	.LVL114:
 1412 001c 0010A0E3 		mov	r1, #0
 1413              	.LVL115:
 527:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1414              		.loc 5 527 0
 1415 0020 FF4004E2 		and	r4, r4, #255
 1416              	.LVL116:
 1417              		.loc 5 526 0
 1418 0024 FEFFFFEB 		bl	rfch_get_params
 1419              	.LVL117:
 1420              		.loc 5 527 0
 1421 0028 1610DDE5 		ldrb	r1, [sp, #22]	@ zero_extendqisi2
 1422 002c 0400A0E1 		mov	r0, r4
 1423 0030 FEFFFFEB 		bl	mframe_task2chan_nr
 528:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 1424              		.loc 5 528 0
 1425 0034 14C08DE2 		add	ip, sp, #20
 1426              		.loc 5 527 0
 1427 0038 0010A0E1 		mov	r1, r0
 1428              		.loc 5 528 0
 1429 003c 0C208DE2 		add	r2, sp, #12
 1430 0040 15308DE2 		add	r3, sp, #21
 1431 0044 00C08DE5 		str	ip, [sp, #0]
 1432 0048 68009FE5 		ldr	r0, .L138
 1433 004c 13C08DE2 		add	ip, sp, #19
 1434 0050 04C08DE5 		str	ip, [sp, #4]
 1435 0054 FEFFFFEB 		bl	tch_get_params
 1436              	.LVL118:
 529:layer1/prim_tch.c **** 
 530:layer1/prim_tch.c **** 	/* Configure DSP */
 531:layer1/prim_tch.c **** 	dsp_load_tch_param(
 1437              		.loc 5 531 0
 1438 0058 1520DDE5 		ldrb	r2, [sp, #21]	@ zero_extendqisi2
 1439 005c 16C0DDE5 		ldrb	ip, [sp, #22]	@ zero_extendqisi2
 1440 0060 000052E3 		cmp	r2, #0
 1441 0064 0040A0E3 		mov	r4, #0
 1442 0068 0220A003 		moveq	r2, #2
 1443 006c 0120A013 		movne	r2, #1
 1444              	.LVL119:
 1445 0070 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1446              	.LVL120:
 1447 0074 1310DDE5 		ldrb	r1, [sp, #19]	@ zero_extendqisi2
 1448 0078 38009FE5 		ldr	r0, .L138
 1449 007c 08C08DE5 		str	ip, [sp, #8]
 1450 0080 00408DE5 		str	r4, [sp, #0]
 1451 0084 04408DE5 		str	r4, [sp, #4]
 1452 0088 FEFFFFEB 		bl	dsp_load_tch_param
 532:layer1/prim_tch.c **** 		&l1s.next_time,
 533:layer1/prim_tch.c **** 		tch_mode, tch_f_hn ? TCH_F : TCH_H, tch_sub,
 534:layer1/prim_tch.c **** 		0, 0, tn
 535:layer1/prim_tch.c **** 	);
 536:layer1/prim_tch.c **** 
 537:layer1/prim_tch.c **** 	dsp_load_rx_task(TCHD_DSP_TASK, 0, tsc); /* burst_id unused for TCH */
 1453              		.loc 5 537 0
 1454 008c 0410A0E1 		mov	r1, r4
 1455              	.LVL121:
 1456 0090 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1457 0094 1C00A0E3 		mov	r0, #28
 1458 0098 FEFFFFEB 		bl	dsp_load_rx_task
 538:layer1/prim_tch.c **** 	dsp_load_tx_task(TCHD_DSP_TASK, 0, tsc); /* burst_id unused for TCH */
 1459              		.loc 5 538 0
 1460 009c 1C00A0E3 		mov	r0, #28
 1461 00a0 0410A0E1 		mov	r1, r4
 1462 00a4 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1463 00a8 FEFFFFEB 		bl	dsp_load_tx_task
 539:layer1/prim_tch.c **** 
 540:layer1/prim_tch.c **** 	return 0;
 541:layer1/prim_tch.c **** }
 1464              		.loc 5 541 0
 1465 00ac 0400A0E1 		mov	r0, r4
 1466 00b0 18D08DE2 		add	sp, sp, #24
 1467 00b4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1468              	.L139:
 1469              		.align	2
 1470              	.L138:
 1471 00b8 0C000000 		.word	l1s+12
 1472              	.LFE73:
 1474              		.section	.text.l1s_tch_a_resp,"ax",%progbits
 1475              		.align	2
 1477              	l1s_tch_a_resp:
 1478              	.LFB74:
 542:layer1/prim_tch.c **** 
 543:layer1/prim_tch.c **** const struct tdma_sched_item tch_d_sched_set[] = {
 544:layer1/prim_tch.c **** 	SCHED_ITEM_DT(l1s_tch_d_cmd, 0, 0, 0),	SCHED_END_FRAME(),
 545:layer1/prim_tch.c **** 						SCHED_END_FRAME(),
 546:layer1/prim_tch.c **** 	SCHED_ITEM(l1s_tch_d_resp, 0, 0, -4),	SCHED_END_FRAME(),
 547:layer1/prim_tch.c **** 	SCHED_END_SET()
 548:layer1/prim_tch.c **** };
 549:layer1/prim_tch.c **** 
 550:layer1/prim_tch.c **** 
 551:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
 552:layer1/prim_tch.c ****  * TCH: SACCH
 553:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
 554:layer1/prim_tch.c **** 
 555:layer1/prim_tch.c **** /*
 556:layer1/prim_tch.c ****  * SACCH data are spread over 4 bursts, however they are so far appart that
 557:layer1/prim_tch.c ****  * we can't use the normal scheduler to schedule all them at once in a single
 558:layer1/prim_tch.c ****  * set.
 559:layer1/prim_tch.c ****  * Therefore, the task code itself decides in which burst it is, if it's the
 560:layer1/prim_tch.c ****  * start/end, and act appropriately.
 561:layer1/prim_tch.c ****  */
 562:layer1/prim_tch.c **** 
 563:layer1/prim_tch.c **** 
 564:layer1/prim_tch.c **** struct l1s_rx_tch_a_state {
 565:layer1/prim_tch.c **** 	struct l1s_meas_hdr meas[4];
 566:layer1/prim_tch.c **** 
 567:layer1/prim_tch.c **** 	struct msgb *msg;
 568:layer1/prim_tch.c **** 	struct l1ctl_info_dl *dl;
 569:layer1/prim_tch.c **** 	struct l1ctl_data_ind *di;
 570:layer1/prim_tch.c **** };
 571:layer1/prim_tch.c **** 
 572:layer1/prim_tch.c **** static struct l1s_rx_tch_a_state rx_tch_a;
 573:layer1/prim_tch.c **** 
 574:layer1/prim_tch.c **** 
 575:layer1/prim_tch.c **** static int l1s_tch_a_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 576:layer1/prim_tch.c **** {
 1479              		.loc 5 576 0
 1480              		@ args = 0, pretend = 0, frame = 24
 1481              		@ frame_needed = 0, uses_anonymous_args = 0
 1482              	.LVL122:
 1483 0000 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 1484              	.LCFI10:
 577:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 578:layer1/prim_tch.c **** 	struct gsm_time rx_time;
 579:layer1/prim_tch.c **** 	uint8_t chan_nr;
 580:layer1/prim_tch.c **** 	uint16_t arfcn;
 581:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 582:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub;
 583:layer1/prim_tch.c **** 	uint32_t fn_report;
 584:layer1/prim_tch.c **** 	uint8_t burst_id;
 585:layer1/prim_tch.c **** 
 586:layer1/prim_tch.c **** 	/* It may happen we've never gone through cmd(0) yet, skip until then */
 587:layer1/prim_tch.c **** 	if (!rx_tch_a.msg)
 1485              		.loc 5 587 0
 1486 0004 80829FE5 		ldr	r8, .L157
 1487 0008 203098E5 		ldr	r3, [r8, #32]
 1488              		.loc 5 576 0
 1489 000c 0228A0E1 		mov	r2, r2, asl #16
 1490              	.LVL123:
 1491 0010 2228A0E1 		mov	r2, r2, lsr #16
 1492              	.LVL124:
 1493              		.loc 5 587 0
 1494 0014 000053E3 		cmp	r3, #0
 1495              		.loc 5 576 0
 1496 0018 20D04DE2 		sub	sp, sp, #32
 1497              	.LCFI11:
 1498              	.LVL125:
 1499              		.loc 5 577 0
 1500 001c FF5002E2 		and	r5, r2, #255
 1501              	.LVL126:
 1502              		.loc 5 587 0
 1503 0020 9B00000A 		beq	.L141
 588:layer1/prim_tch.c **** 		goto skip;
 589:layer1/prim_tch.c **** 
 590:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 591:layer1/prim_tch.c **** 	gsm_fn2gsmtime(&rx_time, (l1s.current_time.fn - 1 + GSM_MAX_FN) % GSM_MAX_FN);
 1504              		.loc 5 591 0
 1505 0024 64329FE5 		ldr	r3, .L157+4
 1506 0028 64029FE5 		ldr	r0, .L157+8
 1507              	.LVL127:
 1508 002c 003093E5 		ldr	r3, [r3, #0]
 1509 0030 60129FE5 		ldr	r1, .L157+12
 1510              	.LVL128:
 1511 0034 000083E0 		add	r0, r3, r0
 1512 0038 FEFFFFEB 		bl	__umodsi3
 1513              	.LVL129:
 1514 003c 08408DE2 		add	r4, sp, #8
 1515 0040 0010A0E1 		mov	r1, r0
 1516 0044 0400A0E1 		mov	r0, r4
 1517 0048 FEFFFFEB 		bl	gsm_fn2gsmtime
 592:layer1/prim_tch.c **** 	rfch_get_params(&rx_time, &arfcn, &tsc, &tn);
 1518              		.loc 5 592 0
 1519 004c 0400A0E1 		mov	r0, r4
 1520 0050 1F208DE2 		add	r2, sp, #31
 1521 0054 1E308DE2 		add	r3, sp, #30
 1522 0058 1A108DE2 		add	r1, sp, #26
 1523 005c FEFFFFEB 		bl	rfch_get_params
 593:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1524              		.loc 5 593 0
 1525 0060 0500A0E1 		mov	r0, r5
 1526              	.LVL130:
 1527 0064 1E10DDE5 		ldrb	r1, [sp, #30]	@ zero_extendqisi2
 1528 0068 FEFFFFEB 		bl	mframe_task2chan_nr
 594:layer1/prim_tch.c **** 	tch_get_params(&rx_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, NULL);
 1529              		.loc 5 594 0
 1530 006c 00A0A0E3 		mov	sl, #0
 1531 0070 1CC08DE2 		add	ip, sp, #28
 1532 0074 14208DE2 		add	r2, sp, #20
 1533              		.loc 5 593 0
 1534 0078 0010A0E1 		mov	r1, r0
 1535              		.loc 5 594 0
 1536 007c 1D308DE2 		add	r3, sp, #29
 1537 0080 0400A0E1 		mov	r0, r4
 1538 0084 00C08DE5 		str	ip, [sp, #0]
 1539 0088 04A08DE5 		str	sl, [sp, #4]
 1540 008c FEFFFFEB 		bl	tch_get_params
 1541              	.LVL131:
 595:layer1/prim_tch.c **** 	burst_id = (fn_report - 12) / 26;
 1542              		.loc 5 595 0
 1543 0090 14009DE5 		ldr	r0, [sp, #20]
 1544 0094 1A10A0E3 		mov	r1, #26
 1545 0098 0C0040E2 		sub	r0, r0, #12
 1546 009c FEFFFFEB 		bl	__udivsi3
 596:layer1/prim_tch.c **** 
 597:layer1/prim_tch.c **** 	/* Collect measurements */
 598:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 1547              		.loc 5 598 0
 1548 00a0 F4519FE5 		ldr	r5, .L157+16
 1549              	.LVL132:
 1550 00a4 043095E5 		ldr	r3, [r5, #4]
 1551              		.loc 5 595 0
 1552 00a8 FF7000E2 		and	r7, r0, #255
 1553              	.LVL133:
 1554              		.loc 5 598 0
 1555 00ac B011D3E1 		ldrh	r1, [r3, #16]
 1556 00b0 8761A0E1 		mov	r6, r7, asl #3
 1557 00b4 084086E0 		add	r4, r6, r8
 1558 00b8 B210C4E1 		strh	r1, [r4, #2]	@ movhi
 599:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].pm_dbm8 =
 1559              		.loc 5 599 0
 1560 00bc B201D3E1 		ldrh	r0, [r3, #18]
 1561 00c0 A001A0E1 		mov	r0, r0, lsr #3
 1562 00c4 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
 600:layer1/prim_tch.c **** 		agc_inp_dbm8_by_pm(dsp_api.db_r->a_serv_demod[D_PM] >> 3);
 601:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].freq_err =
 1563              		.loc 5 601 0
 1564 00c8 041095E5 		ldr	r1, [r5, #4]
 1565              		.loc 5 599 0
 1566 00cc B400C4E1 		strh	r0, [r4, #4]	@ movhi
 1567              		.loc 5 601 0
 1568 00d0 C8319FE5 		ldr	r3, .L157+20
 1569 00d4 F421D1E1 		ldrsh	r2, [r1, #20]
 1570 00d8 920303E0 		mul	r3, r2, r3
 1571 00dc FF2C83E2 		add	r2, r3, #65280
 1572 00e0 FF2082E2 		add	r2, r2, #255
 1573 00e4 0A0053E1 		cmp	r3, sl
 1574 00e8 0230A0B1 		movlt	r3, r2
 1575              		.loc 5 599 0
 1576 00ec 044084E2 		add	r4, r4, #4
 1577              		.loc 5 601 0
 1578 00f0 4338A0E1 		mov	r3, r3, asr #16
 1579 00f4 B230C4E1 		strh	r3, [r4, #2]	@ movhi
 602:layer1/prim_tch.c **** 		ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
 603:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 1580              		.loc 5 603 0
 1581 00f8 B631D1E1 		ldrh	r3, [r1, #22]
 1582 00fc B200D4E1 		ldrh	r0, [r4, #2]
 604:layer1/prim_tch.c **** 
 605:layer1/prim_tch.c **** 	/* feed computed frequency error into AFC loop */
 606:layer1/prim_tch.c **** 	if (rx_tch_a.meas[burst_id].snr > AFC_SNR_THRESHOLD)
 1583              		.loc 5 606 0
 1584 0100 0A0C53E3 		cmp	r3, #2560
 607:layer1/prim_tch.c **** 		afc_input(rx_tch_a.meas[burst_id].freq_err, arfcn, 1);
 1585              		.loc 5 607 0
 1586 0104 0008A081 		movhi	r0, r0, asl #16
 608:layer1/prim_tch.c **** 	else
 609:layer1/prim_tch.c **** 		afc_input(rx_tch_a.meas[burst_id].freq_err, arfcn, 0);
 1587              		.loc 5 609 0
 1588 0108 0008A091 		movls	r0, r0, asl #16
 1589              		.loc 5 607 0
 1590 010c 4008A081 		movhi	r0, r0, asr #16
 1591 0110 0120A083 		movhi	r2, #1
 1592              		.loc 5 609 0
 1593 0114 4008A091 		movls	r0, r0, asr #16
 1594 0118 0A20A091 		movls	r2, sl
 1595              	.LVL134:
 1596 011c BA11DDE1 		ldrh	r1, [sp, #26]
 610:layer1/prim_tch.c **** 
 611:layer1/prim_tch.c **** 	/* feed computed TOA into TA loop */
 612:layer1/prim_tch.c **** 	toa_input(rx_tch_a.meas[burst_id].toa_qbit << 2, rx_tch_a.meas[burst_id].snr);
 1597              		.loc 5 612 0
 1598 0120 64519FE5 		ldr	r5, .L157
 1599              		.loc 5 603 0
 1600 0124 B83086E1 		strh	r3, [r6, r8]	@ movhi
 1601              		.loc 5 609 0
 1602 0128 FEFFFFEB 		bl	afc_input
 1603              		.loc 5 612 0
 1604 012c 8731A0E1 		mov	r3, r7, asl #3
 1605 0130 054083E0 		add	r4, r3, r5
 1606 0134 F200D4E1 		ldrsh	r0, [r4, #2]
 1607 0138 B51093E1 		ldrh	r1, [r3, r5]
 1608 013c 0001A0E1 		mov	r0, r0, asl #2
 1609 0140 FEFFFFEB 		bl	toa_input
 613:layer1/prim_tch.c **** 
 614:layer1/prim_tch.c **** 	/* Tell the RF frontend to set the gain appropriately */
 615:layer1/prim_tch.c **** 	rffe_compute_gain(rx_tch_a.meas[burst_id].pm_dbm8 / 8,
 1610              		.loc 5 615 0
 1611 0144 F400D4E1 		ldrsh	r0, [r4, #4]
 1612 0148 000050E3 		cmp	r0, #0
 1613 014c 073080E2 		add	r3, r0, #7
 1614 0150 0300A0B1 		movlt	r0, r3
 1615 0154 C001A0E1 		mov	r0, r0, asr #3
 1616 0158 5010A0E3 		mov	r1, #80
 1617 015c FEFFFFEB 		bl	rffe_compute_gain
 616:layer1/prim_tch.c **** 		CAL_DSP_TGT_BB_LVL);
 617:layer1/prim_tch.c **** 
 618:layer1/prim_tch.c **** 	/* Last burst, read data & send to the up layer */
 619:layer1/prim_tch.c **** 	if ((burst_id == 3) && (dsp_api.ndb->a_cd[0] & (1<<B_BLUD))) {
 1618              		.loc 5 619 0
 1619 0160 030057E3 		cmp	r7, #3
 1620 0164 9B00001A 		bne	.L141
 1621 0168 2C319FE5 		ldr	r3, .L157+16
 1622 016c 002093E5 		ldr	r2, [r3, #0]
 1623 0170 7F3FA0E3 		mov	r3, #508
 1624 0174 F33092E1 		ldrsh	r3, [r2, r3]
 1625 0178 000053E3 		cmp	r3, #0
 1626 017c 9B0000AA 		bge	.L141
 1627 0180 00C0A0E3 		mov	ip, #0
 1628              	.LVL135:
 1629 0184 0500A0E1 		mov	r0, r5
 1630 0188 0CE0A0E1 		mov	lr, ip
 1631              	.LVL136:
 1632              	.L148:
 1633              	.LBB18:
 620:layer1/prim_tch.c **** 		unsigned int i;
 621:layer1/prim_tch.c **** 		uint16_t num_biterr;
 622:layer1/prim_tch.c **** 		uint32_t avg_snr = 0;
 623:layer1/prim_tch.c **** 		int32_t avg_dbm8 = 0;
 624:layer1/prim_tch.c **** 
 625:layer1/prim_tch.c **** 		/* Average SNR & RX level + error & crc status */
 626:layer1/prim_tch.c **** 		for (i=0; i<4; i++) {
 1634              		.loc 5 626 0
 1635 018c 10219FE5 		ldr	r2, .L157+24
 627:layer1/prim_tch.c **** 			avg_snr += rx_tch_a.meas[i].snr;
 1636              		.loc 5 627 0
 1637 0190 B030D0E1 		ldrh	r3, [r0, #0]
 628:layer1/prim_tch.c **** 			avg_dbm8 += rx_tch_a.meas[i].pm_dbm8;
 1638              		.loc 5 628 0
 1639 0194 F410D0E1 		ldrsh	r1, [r0, #4]
 1640 0198 080080E2 		add	r0, r0, #8
 1641              		.loc 5 626 0
 1642 019c 020050E1 		cmp	r0, r2
 1643              		.loc 5 627 0
 1644 01a0 03E08EE0 		add	lr, lr, r3
 1645              		.loc 5 628 0
 1646 01a4 01C08CE0 		add	ip, ip, r1
 1647              		.loc 5 626 0
 1648 01a8 6100001A 		bne	.L148
 629:layer1/prim_tch.c **** 		}
 630:layer1/prim_tch.c **** 		rx_tch_a.dl->snr = avg_snr / 4;
 1649              		.loc 5 630 0
 1650 01ac D8509FE5 		ldr	r5, .L157
 1651 01b0 242095E5 		ldr	r2, [r5, #36]
 1652 01b4 2E31A0E1 		mov	r3, lr, lsr #2
 631:layer1/prim_tch.c **** 		rx_tch_a.dl->rx_level = dbm2rxlev(avg_dbm8 / (8*4));
 1653              		.loc 5 631 0
 1654 01b8 00005CE3 		cmp	ip, #0
 1655 01bc 1F008CE2 		add	r0, ip, #31
 1656              		.loc 5 630 0
 1657 01c0 0930C2E5 		strb	r3, [r2, #9]
 1658              		.loc 5 631 0
 1659 01c4 0C00A0A1 		movge	r0, ip
 1660 01c8 C002A0E1 		mov	r0, r0, asr #5
 1661 01cc 244095E5 		ldr	r4, [r5, #36]
 1662 01d0 FEFFFFEB 		bl	dbm2rxlev
 1663              	.LVL137:
 632:layer1/prim_tch.c **** 
 633:layer1/prim_tch.c **** 		num_biterr = dsp_api.ndb->a_cd[2];
 1664              		.loc 5 633 0
 1665 01d4 C0309FE5 		ldr	r3, .L157+16
 1666              		.loc 5 631 0
 1667 01d8 0800C4E5 		strb	r0, [r4, #8]
 1668              		.loc 5 633 0
 1669 01dc 002093E5 		ldr	r2, [r3, #0]
 1670 01e0 023CA0E3 		mov	r3, #512
 1671 01e4 B33092E1 		ldrh	r3, [r2, r3]
 1672              	.LVL138:
 1673 01e8 242095E5 		ldr	r2, [r5, #36]
 634:layer1/prim_tch.c **** 		if (num_biterr > 0xff)
 1674              		.loc 5 634 0
 1675 01ec FF0053E3 		cmp	r3, #255
 635:layer1/prim_tch.c **** 			rx_tch_a.dl->num_biterr = 0xff;
 1676              		.loc 5 635 0
 1677 01f0 0030E083 		mvnhi	r3, #0
 1678              	.LVL139:
 1679              	.LVL140:
 636:layer1/prim_tch.c **** 		else
 637:layer1/prim_tch.c **** 			rx_tch_a.dl->num_biterr = num_biterr;
 1680              		.loc 5 637 0
 1681 01f4 0A30C2E5 		strb	r3, [r2, #10]
 638:layer1/prim_tch.c **** 
 639:layer1/prim_tch.c **** 		rx_tch_a.dl->fire_crc = ((dsp_api.ndb->a_cd[0] & 0xffff) & ((1 << B_FIRE1) | (1 << B_FIRE0))) >> 
 1682              		.loc 5 639 0
 1683 01f8 9C509FE5 		ldr	r5, .L157+16
 1684 01fc 003095E5 		ldr	r3, [r5, #0]
 1685              	.LVL141:
 1686 0200 7F6FA0E3 		mov	r6, #508
 1687 0204 80409FE5 		ldr	r4, .L157
 1688 0208 B63093E1 		ldrh	r3, [r3, r6]
 1689 020c 242094E5 		ldr	r2, [r4, #36]
 1690 0210 603003E2 		and	r3, r3, #96
 1691 0214 C332A0E1 		mov	r3, r3, asr #5
 1692 0218 0B30C2E5 		strb	r3, [r2, #11]
 640:layer1/prim_tch.c **** 
 641:layer1/prim_tch.c **** 		/* Update rx level for pm report */
 642:layer1/prim_tch.c **** 		pu_update_rx_level(rx_tch_a.dl->rx_level);
 1693              		.loc 5 642 0
 1694 021c 243094E5 		ldr	r3, [r4, #36]
 1695 0220 0800D3E5 		ldrb	r0, [r3, #8]	@ zero_extendqisi2
 1696 0224 FEFFFFEB 		bl	pu_update_rx_level
 643:layer1/prim_tch.c **** 
 644:layer1/prim_tch.c **** 		/* Copy actual data, skipping the information block [0,1,2] */
 645:layer1/prim_tch.c **** 		dsp_memcpy_from_api(rx_tch_a.di->data, &dsp_api.ndb->a_cd[3], 23, 0);
 1697              		.loc 5 645 0
 1698 0228 001095E5 		ldr	r1, [r5, #0]
 1699 022c 061081E0 		add	r1, r1, r6
 1700 0230 061081E2 		add	r1, r1, #6
 1701 0234 1720A0E3 		mov	r2, #23
 1702 0238 0030A0E3 		mov	r3, #0
 1703 023c 280094E5 		ldr	r0, [r4, #40]
 1704 0240 FEFFFFEB 		bl	dsp_memcpy_from_api
 646:layer1/prim_tch.c **** 
 647:layer1/prim_tch.c **** 		/* Give message to up layer */
 648:layer1/prim_tch.c **** 		l1_queue_for_l2(rx_tch_a.msg);
 1705              		.loc 5 648 0
 1706 0244 200094E5 		ldr	r0, [r4, #32]
 1707 0248 FEFFFFEB 		bl	l1_queue_for_l2
 649:layer1/prim_tch.c **** 		rx_tch_a.msg = NULL; rx_tch_a.dl = NULL; rx_tch_a.di = NULL;
 1708              		.loc 5 649 0
 1709 024c 0030A0E3 		mov	r3, #0
 650:layer1/prim_tch.c **** 
 651:layer1/prim_tch.c **** 		/* Reset header */
 652:layer1/prim_tch.c **** 		dsp_api.ndb->a_cd[0] = (1<<B_FIRE1);
 1710              		.loc 5 652 0
 1711 0250 002095E5 		ldr	r2, [r5, #0]
 1712              		.loc 5 649 0
 1713 0254 283084E5 		str	r3, [r4, #40]
 1714 0258 203084E5 		str	r3, [r4, #32]
 1715 025c 243084E5 		str	r3, [r4, #36]
 653:layer1/prim_tch.c **** 		dsp_api.ndb->a_cd[2] = 0xffff;
 1716              		.loc 5 653 0
 1717 0260 0010E0E3 		mvn	r1, #0	@ movhi
 1718 0264 023C83E2 		add	r3, r3, #512
 1719 0268 B31082E1 		strh	r1, [r2, r3]	@ movhi
 1720              		.loc 5 652 0
 1721 026c 4030A0E3 		mov	r3, #64	@ movhi
 1722 0270 B63082E1 		strh	r3, [r2, r6]	@ movhi
 1723              	.LVL142:
 1724              	.L141:
 1725              	.LBE18:
 654:layer1/prim_tch.c **** 	}
 655:layer1/prim_tch.c **** 
 656:layer1/prim_tch.c **** skip:
 657:layer1/prim_tch.c **** 	/* mark READ page as being used */
 658:layer1/prim_tch.c **** 	dsp_api.r_page_used = 1;
 1726              		.loc 5 658 0
 1727 0274 20309FE5 		ldr	r3, .L157+16
 1728 0278 0120A0E3 		mov	r2, #1
 1729              	.LVL143:
 659:layer1/prim_tch.c **** 
 660:layer1/prim_tch.c **** 	return 0;
 661:layer1/prim_tch.c **** }
 1730              		.loc 5 661 0
 1731 027c 0000A0E3 		mov	r0, #0
 1732              	.LVL144:
 1733              		.loc 5 658 0
 1734 0280 182083E5 		str	r2, [r3, #24]
 1735              		.loc 5 661 0
 1736 0284 20D08DE2 		add	sp, sp, #32
 1737 0288 F085BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, pc}
 1738              	.L158:
 1739              		.align	2
 1740              	.L157:
 1741 028c 08000000 		.word	rx_tch_a
 1742 0290 00000000 		.word	l1s
 1743 0294 FF6F2900 		.word	2715647
 1744 0298 00702900 		.word	2715648
 1745 029c 00000000 		.word	dsp_api
 1746 02a0 C0500100 		.word	86208
 1747 02a4 28000000 		.word	rx_tch_a+32
 1748              	.LFE74:
 1750              		.section	.rodata.str1.4
 1751 007d 000000   		.align	2
 1752              	.LC3:
 1753 0080 7463685F 		.ascii	"tch_a_cmd(0): unable to allocate msgb\000"
 1753      615F636D 
 1753      64283029 
 1753      3A20756E 
 1753      61626C65 
 1754 00a6 0000     		.section	.text.l1s_tch_a_cmd,"ax",%progbits
 1755              		.align	2
 1757              	l1s_tch_a_cmd:
 1758              	.LFB75:
 662:layer1/prim_tch.c **** 
 663:layer1/prim_tch.c **** static int l1s_tch_a_cmd(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 664:layer1/prim_tch.c **** {
 1759              		.loc 5 664 0
 1760              		@ args = 0, pretend = 0, frame = 12
 1761              		@ frame_needed = 0, uses_anonymous_args = 0
 1762              	.LVL145:
 1763 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1764              	.LCFI12:
 1765 0004 0248A0E1 		mov	r4, r2, asl #16
 1766 0008 18D04DE2 		sub	sp, sp, #24
 1767              	.LCFI13:
 1768              	.LVL146:
 1769              		.loc 5 664 0
 1770 000c 2448A0E1 		mov	r4, r4, lsr #16
 665:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 666:layer1/prim_tch.c **** 	uint8_t chan_nr;
 667:layer1/prim_tch.c **** 	uint16_t arfcn;
 668:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 669:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub, tch_mode;
 670:layer1/prim_tch.c **** 	uint32_t fn_report;
 671:layer1/prim_tch.c **** 	uint8_t burst_id;
 672:layer1/prim_tch.c **** 
 673:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 674:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, &arfcn, &tsc, &tn);
 1771              		.loc 5 674 0
 1772 0010 17208DE2 		add	r2, sp, #23
 1773              	.LVL147:
 1774 0014 16308DE2 		add	r3, sp, #22
 1775 0018 34029FE5 		ldr	r0, .L175
 1776              	.LVL148:
 1777 001c 10108DE2 		add	r1, sp, #16
 1778              	.LVL149:
 675:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1779              		.loc 5 675 0
 1780 0020 FF4004E2 		and	r4, r4, #255
 1781              	.LVL150:
 1782              		.loc 5 674 0
 1783 0024 FEFFFFEB 		bl	rfch_get_params
 1784              	.LVL151:
 1785              		.loc 5 675 0
 1786 0028 1610DDE5 		ldrb	r1, [sp, #22]	@ zero_extendqisi2
 1787 002c 0400A0E1 		mov	r0, r4
 1788 0030 FEFFFFEB 		bl	mframe_task2chan_nr
 676:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 1789              		.loc 5 676 0
 1790 0034 14C08DE2 		add	ip, sp, #20
 1791              	.LVL152:
 1792 0038 0010A0E1 		mov	r1, r0
 1793 003c 0C208DE2 		add	r2, sp, #12
 1794 0040 15308DE2 		add	r3, sp, #21
 1795 0044 00C08DE5 		str	ip, [sp, #0]
 1796              	.LVL153:
 1797              		.loc 5 675 0
 1798 0048 0060A0E1 		mov	r6, r0
 1799              		.loc 5 676 0
 1800 004c 13C08DE2 		add	ip, sp, #19
 1801 0050 FC019FE5 		ldr	r0, .L175
 1802 0054 04C08DE5 		str	ip, [sp, #4]
 1803 0058 FEFFFFEB 		bl	tch_get_params
 1804              	.LVL154:
 1805              	.LVL155:
 677:layer1/prim_tch.c **** 	burst_id = (fn_report - 12) / 26;
 678:layer1/prim_tch.c **** 
 679:layer1/prim_tch.c **** 	/* Load SACCH data if we start a new burst */
 680:layer1/prim_tch.c **** 	if (burst_id == 0) {
 1806              		.loc 5 680 0
 1807 005c 0C009DE5 		ldr	r0, [sp, #12]
 1808 0060 1A10A0E3 		mov	r1, #26
 1809 0064 0C0040E2 		sub	r0, r0, #12
 1810 0068 FEFFFFEB 		bl	__udivsi3
 1811 006c FF0010E3 		tst	r0, #255
 1812 0070 6900001A 		bne	.L160
 1813              	.LBB19:
 681:layer1/prim_tch.c **** 		uint16_t *info_ptr = dsp_api.ndb->a_cu;
 1814              		.loc 5 681 0
 1815 0074 DC319FE5 		ldr	r3, .L175+4
 1816 0078 003093E5 		ldr	r3, [r3, #0]
 682:layer1/prim_tch.c **** 		struct msgb *msg;
 683:layer1/prim_tch.c **** 		const uint8_t *data;
 684:layer1/prim_tch.c **** 
 685:layer1/prim_tch.c **** 		/* If the TX queue is empty, send dummy measurement */
 686:layer1/prim_tch.c **** 		msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_SACCH]);
 1817              		.loc 5 686 0
 1818 007c D8019FE5 		ldr	r0, .L175+8
 1819              		.loc 5 681 0
 1820 0080 994F83E2 		add	r4, r3, #612
 1821              	.LVL156:
 1822              		.loc 5 686 0
 1823 0084 FEFFFFEB 		bl	msgb_dequeue
 687:layer1/prim_tch.c **** 		data = msg ? msg->l3h : pu_get_meas_frame();
 1824              		.loc 5 687 0
 1825 0088 005050E2 		subs	r5, r0, #0
 1826              	.LVL157:
 1827 008c 18109515 		ldrne	r1, [r5, #24]
 1828              	.LVL158:
 1829 0090 2500001A 		bne	.L164
 1830 0094 FEFFFFEB 		bl	pu_get_meas_frame
 1831              	.LVL159:
 1832 0098 0010A0E1 		mov	r1, r0
 1833              	.LVL160:
 1834              	.L164:
 688:layer1/prim_tch.c **** 
 689:layer1/prim_tch.c **** 		/* Fill data block header */
 690:layer1/prim_tch.c **** 		info_ptr[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 1835              		.loc 5 690 0
 1836 009c 0239A0E3 		mov	r3, #32768
 1837 00a0 B030C4E1 		strh	r3, [r4, #0]	@ movhi
 691:layer1/prim_tch.c **** 		info_ptr[1] = 0;		/* 2nd word: cleared. */
 1838              		.loc 5 691 0
 1839 00a4 0030A0E3 		mov	r3, #0	@ movhi
 1840 00a8 B230C4E1 		strh	r3, [r4, #2]	@ movhi
 692:layer1/prim_tch.c **** 		info_ptr[2] = 0;		/* 3nd word: cleared. */
 1841              		.loc 5 692 0
 1842 00ac B430C4E1 		strh	r3, [r4, #4]	@ movhi
 693:layer1/prim_tch.c **** 
 694:layer1/prim_tch.c **** 		/* Copy the actual data after the header */
 695:layer1/prim_tch.c **** 		dsp_memcpy_to_api(&info_ptr[3], data, 23, 0);
 1843              		.loc 5 695 0
 1844 00b0 060084E2 		add	r0, r4, #6
 1845 00b4 1720A0E3 		mov	r2, #23
 1846 00b8 0030A0E3 		mov	r3, #0
 1847 00bc FEFFFFEB 		bl	dsp_memcpy_to_api
 1848              	.LVL161:
 696:layer1/prim_tch.c **** 
 697:layer1/prim_tch.c **** 		/* Indicate completion (FIXME: early but easier this way for now) */
 698:layer1/prim_tch.c **** 		if (msg) {
 1849              		.loc 5 698 0
 1850 00c0 000055E3 		cmp	r5, #0
 1851 00c4 6400000A 		beq	.L165
 699:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 700:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_SACCH;
 1852              		.loc 5 700 0
 1853 00c8 90C19FE5 		ldr	ip, .L175+12
 1854              		.loc 5 699 0
 1855 00cc 90119FE5 		ldr	r1, .L175+16
 1856              		.loc 5 700 0
 1857 00d0 B020DCE1 		ldrh	r2, [ip, #0]
 1858              		.loc 5 699 0
 1859 00d4 8C319FE5 		ldr	r3, .L175+20
 1860 00d8 BC10D1E1 		ldrh	r1, [r1, #12]
 1861              		.loc 5 700 0
 1862 00dc 012082E3 		orr	r2, r2, #1
 701:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 1863              		.loc 5 701 0
 1864 00e0 0300A0E3 		mov	r0, #3
 1865              		.loc 5 699 0
 1866 00e4 B010C3E1 		strh	r1, [r3, #0]	@ movhi
 1867              		.loc 5 700 0
 1868 00e8 B020CCE1 		strh	r2, [ip, #0]	@ movhi
 1869              		.loc 5 701 0
 1870 00ec FEFFFFEB 		bl	l1s_compl_sched
 702:layer1/prim_tch.c **** 		}
 703:layer1/prim_tch.c **** 
 704:layer1/prim_tch.c **** 		/* Free msg now that we're done with it */
 705:layer1/prim_tch.c **** 		if (msg)
 706:layer1/prim_tch.c **** 			msgb_free(msg);
 1871              		.loc 5 706 0
 1872 00f0 0500A0E1 		mov	r0, r5
 1873 00f4 FEFFFFEB 		bl	msgb_free
 1874 00f8 640000EA 		b	.L165
 1875              	.L167:
 1876              	.LBE19:
 707:layer1/prim_tch.c **** 	}
 708:layer1/prim_tch.c **** 
 709:layer1/prim_tch.c **** 	/* Allocate RX burst */
 710:layer1/prim_tch.c **** 	if (burst_id == 0) {
 711:layer1/prim_tch.c **** 		/* Clear 'dangling' msgb */
 712:layer1/prim_tch.c **** 		if (rx_tch_a.msg) {
 713:layer1/prim_tch.c **** 			/* Can happen if the task was shutdown in the middle of
 714:layer1/prim_tch.c **** 			 * 4 bursts ... */
 715:layer1/prim_tch.c **** 			msgb_free(rx_tch_a.msg);
 1877              		.loc 5 715 0
 1878 00fc FEFFFFEB 		bl	msgb_free
 1879              	.L168:
 716:layer1/prim_tch.c **** 		}
 717:layer1/prim_tch.c **** 
 718:layer1/prim_tch.c **** 		/* Allocate burst */
 719:layer1/prim_tch.c **** 			/* FIXME: we actually want all allocation out of L1S! */
 720:layer1/prim_tch.c **** 		rx_tch_a.msg = l1ctl_msgb_alloc(L1CTL_DATA_IND);
 1880              		.loc 5 720 0
 1881 0100 0300A0E3 		mov	r0, #3
 1882 0104 FEFFFFEB 		bl	l1ctl_msgb_alloc
 1883 0108 5C419FE5 		ldr	r4, .L175+24
 1884              	.LVL162:
 721:layer1/prim_tch.c **** 		if (!rx_tch_a.msg)
 1885              		.loc 5 721 0
 1886 010c 000050E3 		cmp	r0, #0
 1887              		.loc 5 720 0
 1888 0110 200084E5 		str	r0, [r4, #32]
 1889              		.loc 5 721 0
 722:layer1/prim_tch.c **** 			printf("tch_a_cmd(0): unable to allocate msgb\n");
 1890              		.loc 5 722 0
 1891 0114 54019F05 		ldreq	r0, .L175+28
 1892 0118 FEFFFF0B 		bleq	puts
 1893              	.L169:
 723:layer1/prim_tch.c **** 
 724:layer1/prim_tch.c **** 		rx_tch_a.dl = (struct l1ctl_info_dl *) msgb_put(rx_tch_a.msg, sizeof(*rx_tch_a.dl));
 1894              		.loc 5 724 0
 1895 011c 0C10A0E3 		mov	r1, #12
 1896 0120 200094E5 		ldr	r0, [r4, #32]
 1897 0124 FEFFFFEB 		bl	msgb_put
 725:layer1/prim_tch.c **** 		rx_tch_a.di = (struct l1ctl_data_ind *) msgb_put(rx_tch_a.msg, sizeof(*rx_tch_a.di));
 1898              		.loc 5 725 0
 1899 0128 1710A0E3 		mov	r1, #23
 1900              		.loc 5 724 0
 1901 012c 240084E5 		str	r0, [r4, #36]
 1902              		.loc 5 725 0
 1903 0130 200094E5 		ldr	r0, [r4, #32]
 1904 0134 FEFFFFEB 		bl	msgb_put
 726:layer1/prim_tch.c **** 
 727:layer1/prim_tch.c **** 		/* Pre-fill DL header with some info about burst(0) */
 728:layer1/prim_tch.c **** 		rx_tch_a.dl->chan_nr = chan_nr;
 1905              		.loc 5 728 0
 1906 0138 243094E5 		ldr	r3, [r4, #36]
 1907              		.loc 5 725 0
 1908 013c 280084E5 		str	r0, [r4, #40]
 1909              		.loc 5 728 0
 1910 0140 0060C3E5 		strb	r6, [r3, #0]
 729:layer1/prim_tch.c **** 		rx_tch_a.dl->link_id = 0x40;	/* SACCH */
 1911              		.loc 5 729 0
 1912 0144 242094E5 		ldr	r2, [r4, #36]
 1913 0148 4030A0E3 		mov	r3, #64
 1914 014c 0130C2E5 		strb	r3, [r2, #1]
 1915              	.LVL163:
 730:layer1/prim_tch.c **** 		rx_tch_a.dl->band_arfcn = htons(arfcn);
 1916              		.loc 5 730 0
 1917 0150 B001DDE1 		ldrh	r0, [sp, #16]
 1918 0154 FEFFFFEB 		bl	__fswab16
 1919 0158 242094E5 		ldr	r2, [r4, #36]
 1920 015c 2034A0E1 		mov	r3, r0, lsr #8
 1921 0160 0330C2E5 		strb	r3, [r2, #3]
 1922 0164 0200C2E5 		strb	r0, [r2, #2]
 731:layer1/prim_tch.c **** 		rx_tch_a.dl->frame_nr = htonl(l1s.next_time.fn);
 1923              		.loc 5 731 0
 1924 0168 F4309FE5 		ldr	r3, .L175+16
 1925 016c 0C0093E5 		ldr	r0, [r3, #12]
 1926 0170 FEFFFFEB 		bl	__fswab32
 1927 0174 243094E5 		ldr	r3, [r4, #36]
 1928 0178 202CA0E1 		mov	r2, r0, lsr #24
 1929 017c 2014A0E1 		mov	r1, r0, lsr #8
 1930 0180 20C8A0E1 		mov	ip, r0, lsr #16
 1931 0184 0720C3E5 		strb	r2, [r3, #7]
 1932 0188 0510C3E5 		strb	r1, [r3, #5]
 1933 018c 06C0C3E5 		strb	ip, [r3, #6]
 1934 0190 0400C3E5 		strb	r0, [r3, #4]
 1935 0194 690000EA 		b	.L160
 1936              	.LVL164:
 1937              	.L165:
 1938              		.loc 5 712 0
 1939 0198 CC309FE5 		ldr	r3, .L175+24
 1940 019c 200093E5 		ldr	r0, [r3, #32]
 1941 01a0 000050E3 		cmp	r0, #0
 1942 01a4 3D00001A 		bne	.L167
 1943 01a8 3E0000EA 		b	.L168
 1944              	.LVL165:
 1945              	.L160:
 732:layer1/prim_tch.c **** 	}
 733:layer1/prim_tch.c **** 
 734:layer1/prim_tch.c **** 	/* Configure DSP for TX/RX */
 735:layer1/prim_tch.c **** 	l1s_tx_apc_helper(arfcn);
 1946              		.loc 5 735 0
 1947 01ac B001DDE1 		ldrh	r0, [sp, #16]
 1948 01b0 FEFFFFEB 		bl	l1s_tx_apc_helper
 1949              	.LVL166:
 736:layer1/prim_tch.c **** 
 737:layer1/prim_tch.c **** 	dsp_load_tch_param(
 1950              		.loc 5 737 0
 1951 01b4 1520DDE5 		ldrb	r2, [sp, #21]	@ zero_extendqisi2
 1952 01b8 16C0DDE5 		ldrb	ip, [sp, #22]	@ zero_extendqisi2
 1953 01bc 000052E3 		cmp	r2, #0
 1954 01c0 0040A0E3 		mov	r4, #0
 1955 01c4 0220A003 		moveq	r2, #2
 1956 01c8 0120A013 		movne	r2, #1
 1957              	.LVL167:
 1958 01cc 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1959              	.LVL168:
 1960 01d0 1310DDE5 		ldrb	r1, [sp, #19]	@ zero_extendqisi2
 1961 01d4 78009FE5 		ldr	r0, .L175
 1962 01d8 08C08DE5 		str	ip, [sp, #8]
 1963 01dc 00408DE5 		str	r4, [sp, #0]
 1964 01e0 04408DE5 		str	r4, [sp, #4]
 1965 01e4 FEFFFFEB 		bl	dsp_load_tch_param
 738:layer1/prim_tch.c **** 		&l1s.next_time,
 739:layer1/prim_tch.c **** 		tch_mode, tch_f_hn ? TCH_F : TCH_H, tch_sub,
 740:layer1/prim_tch.c **** 		0, 0, tn
 741:layer1/prim_tch.c **** 	);
 742:layer1/prim_tch.c **** 
 743:layer1/prim_tch.c **** 	dsp_load_rx_task(
 1966              		.loc 5 743 0
 1967 01e8 0420A0E1 		mov	r2, r4
 1968 01ec B011DDE1 		ldrh	r1, [sp, #16]
 1969 01f0 0E00A0E3 		mov	r0, #14
 1970 01f4 FEFFFFEB 		bl	dsp_task_iq_swap
 1971 01f8 0410A0E1 		mov	r1, r4
 1972              	.LVL169:
 1973 01fc 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1974 0200 FEFFFFEB 		bl	dsp_load_rx_task
 744:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHA_DSP_TASK, arfcn, 0),
 745:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCHA */
 746:layer1/prim_tch.c **** 	);
 747:layer1/prim_tch.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_NB, 0);
 1975              		.loc 5 747 0
 1976 0204 B001DDE1 		ldrh	r0, [sp, #16]
 1977 0208 0420A0E1 		mov	r2, r4
 1978 020c 0310A0E3 		mov	r1, #3
 1979 0210 FEFFFFEB 		bl	l1s_rx_win_ctrl
 748:layer1/prim_tch.c **** 
 749:layer1/prim_tch.c **** 	dsp_load_tx_task(
 1980              		.loc 5 749 0
 1981 0214 B011DDE1 		ldrh	r1, [sp, #16]
 1982 0218 0120A0E3 		mov	r2, #1
 1983 021c 0E00A0E3 		mov	r0, #14
 1984 0220 FEFFFFEB 		bl	dsp_task_iq_swap
 1985 0224 0410A0E1 		mov	r1, r4
 1986 0228 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1987 022c FEFFFFEB 		bl	dsp_load_tx_task
 750:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHA_DSP_TASK, arfcn, 1),
 751:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCHA */
 752:layer1/prim_tch.c **** 	);
 753:layer1/prim_tch.c **** 	l1s_tx_win_ctrl(arfcn | ARFCN_UPLINK, L1_TXWIN_NB, 0, 3);
 1988              		.loc 5 753 0
 1989 0230 B001DDE1 		ldrh	r0, [sp, #16]
 1990 0234 0410A0E1 		mov	r1, r4
 1991 0238 010980E3 		orr	r0, r0, #16384
 1992 023c 0420A0E1 		mov	r2, r4
 1993 0240 0330A0E3 		mov	r3, #3
 1994 0244 FEFFFFEB 		bl	l1s_tx_win_ctrl
 754:layer1/prim_tch.c **** 
 755:layer1/prim_tch.c **** 	return 0;
 756:layer1/prim_tch.c **** }
 1995              		.loc 5 756 0
 1996 0248 0400A0E1 		mov	r0, r4
 1997 024c 18D08DE2 		add	sp, sp, #24
 1998 0250 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1999              	.L176:
 2000              		.align	2
 2001              	.L175:
 2002 0254 0C000000 		.word	l1s+12
 2003 0258 00000000 		.word	dsp_api
 2004 025c 580A0000 		.word	l1s+2648
 2005 0260 74000000 		.word	last_tx_tch_type
 2006 0264 00000000 		.word	l1s
 2007 0268 76000000 		.word	last_tx_tch_fn
 2008 026c 08000000 		.word	rx_tch_a
 2009 0270 80000000 		.word	.LC3
 2010              	.LFE75:
 2012              		.bss
 2013              		.align	2
 2014              	rx_tch_a:
 2015 0008 00000000 		.space	44
 2015      00000000 
 2015      00000000 
 2015      00000000 
 2015      00000000 
 2016              		.align	2
 2017              	rx_tch:
 2018 0034 00000000 		.space	64
 2018      00000000 
 2018      00000000 
 2018      00000000 
 2018      00000000 
 2019              		.align	1
 2020              	last_tx_tch_type:
 2021 0074 0000     		.space	2
 2022              		.align	1
 2023              	last_tx_tch_fn:
 2024 0076 0000     		.space	2
 2296              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 prim_tch.c
     /tmp/cc2A8fvT.s:15     .rodata:0000000000000000 tch_a_sched_set
     /tmp/cc2A8fvT.s:16     .rodata:0000000000000000 $d
     /tmp/cc2A8fvT.s:1757   .text.l1s_tch_a_cmd:0000000000000000 l1s_tch_a_cmd
     /tmp/cc2A8fvT.s:1477   .text.l1s_tch_a_resp:0000000000000000 l1s_tch_a_resp
     /tmp/cc2A8fvT.s:48     .rodata:0000000000000048 tch_d_sched_set
     /tmp/cc2A8fvT.s:1392   .text.l1s_tch_d_cmd:0000000000000000 l1s_tch_d_cmd
     /tmp/cc2A8fvT.s:1363   .text.l1s_tch_d_resp:0000000000000000 l1s_tch_d_resp
     /tmp/cc2A8fvT.s:81     .rodata:0000000000000090 tch_sched_set
     /tmp/cc2A8fvT.s:993    .text.l1s_tch_cmd:0000000000000000 l1s_tch_cmd
     /tmp/cc2A8fvT.s:499    .text.l1s_tch_resp:0000000000000000 l1s_tch_resp
     /tmp/cc2A8fvT.s:113    .text.__fswab16:0000000000000000 __fswab16
     /tmp/cc2A8fvT.s:121    .text.__fswab16:0000000000000000 $a
     /tmp/cc2A8fvT.s:140    .text.__fswab32:0000000000000000 __fswab32
     /tmp/cc2A8fvT.s:147    .text.__fswab32:0000000000000000 $a
     /tmp/cc2A8fvT.s:171    .text.msgb_tailroom:0000000000000000 msgb_tailroom
     /tmp/cc2A8fvT.s:179    .text.msgb_tailroom:0000000000000000 $a
     /tmp/cc2A8fvT.s:200    .text.msgb_put:0000000000000000 msgb_put
     /tmp/cc2A8fvT.s:206    .text.msgb_put:0000000000000000 $a
     /tmp/cc2A8fvT.s:248    .text.msgb_put:000000000000004c $d
     /tmp/cc2A8fvT.s:254    .text.dsp_task_iq_swap:0000000000000000 dsp_task_iq_swap
     /tmp/cc2A8fvT.s:261    .text.dsp_task_iq_swap:0000000000000000 $a
     /tmp/cc2A8fvT.s:288    .text.tch_get_params:0000000000000000 tch_get_params
     /tmp/cc2A8fvT.s:295    .text.tch_get_params:0000000000000000 $a
     /tmp/cc2A8fvT.s:391    .text.tch_get_params:00000000000000c4 $d
     /tmp/cc2A8fvT.s:397    .text.l1a_tx_tch_compl:0000000000000000 l1a_tx_tch_compl
     /tmp/cc2A8fvT.s:403    .text.l1a_tx_tch_compl:0000000000000000 $a
     /tmp/cc2A8fvT.s:451    .text.l1a_tx_tch_compl:0000000000000064 $d
     /tmp/cc2A8fvT.s:2020   .bss:0000000000000074 last_tx_tch_type
     /tmp/cc2A8fvT.s:2023   .bss:0000000000000076 last_tx_tch_fn
     /tmp/cc2A8fvT.s:458    .text.prim_tch_init:0000000000000000 prim_tch_init
     /tmp/cc2A8fvT.s:466    .text.prim_tch_init:0000000000000000 $a
     /tmp/cc2A8fvT.s:477    .text.prim_tch_init:0000000000000010 $d
     /tmp/cc2A8fvT.s:483    .ctors:0000000000000000 $d
     /tmp/cc2A8fvT.s:485    .bss:0000000000000000 meas_id.4330
     /tmp/cc2A8fvT.s:505    .text.l1s_tch_resp:0000000000000000 $a
     /tmp/cc2A8fvT.s:973    .text.l1s_tch_resp:00000000000004a8 $d
     /tmp/cc2A8fvT.s:2017   .bss:0000000000000034 rx_tch
     /tmp/cc2A8fvT.s:988    .bss:0000000000000004 icnt.4508
     /tmp/cc2A8fvT.s:999    .text.l1s_tch_cmd:0000000000000000 $a
     /tmp/cc2A8fvT.s:1350   .text.l1s_tch_cmd:0000000000000344 $d
     /tmp/cc2A8fvT.s:1371   .text.l1s_tch_d_resp:0000000000000000 $a
     /tmp/cc2A8fvT.s:1386   .text.l1s_tch_d_resp:0000000000000014 $d
     /tmp/cc2A8fvT.s:1398   .text.l1s_tch_d_cmd:0000000000000000 $a
     /tmp/cc2A8fvT.s:1471   .text.l1s_tch_d_cmd:00000000000000b8 $d
     /tmp/cc2A8fvT.s:1483   .text.l1s_tch_a_resp:0000000000000000 $a
     /tmp/cc2A8fvT.s:1741   .text.l1s_tch_a_resp:000000000000028c $d
     /tmp/cc2A8fvT.s:2014   .bss:0000000000000008 rx_tch_a
     /tmp/cc2A8fvT.s:1763   .text.l1s_tch_a_cmd:0000000000000000 $a
     /tmp/cc2A8fvT.s:2002   .text.l1s_tch_a_cmd:0000000000000254 $d

UNDEFINED SYMBOLS
tdma_end_set
osmo_panic
rffe_iq_swapped
__umodsi3
l1s
l1_create_l2_msg
l1_queue_for_l2
__udivsi3
__divsi3
gsm_fn2gsmtime
rfch_get_params
mframe_task2chan_nr
agc_inp_dbm8_by_pm
afc_input
toa_input
rffe_compute_gain
l1ctl_msgb_alloc
puts
dbm2rxlev
pu_update_rx_level
dsp_memcpy_from_api
dsp_api
msgb_dequeue
pu_get_idle_frame
dsp_memcpy_to_api
l1s_compl_sched
msgb_free
l1s_tx_apc_helper
dsp_load_tch_param
dsp_load_rx_task
l1s_rx_win_ctrl
dsp_load_tx_task
l1s_tx_win_ctrl
pu_get_meas_frame
