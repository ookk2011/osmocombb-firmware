   1              		.file	"l23_api.c"
   9              	.Ltext0:
  10              		.global	l1a_l23_tx_cb
  11              		.bss
  12              		.align	2
  15              	l1a_l23_tx_cb:
  16 0000 00000000 		.space	4
  17              		.data
  18              		.align	2
  21              	l23_rx_queue:
  22 0000 00000000 		.word	l23_rx_queue
  23 0004 00000000 		.word	l23_rx_queue
  24              		.section	.text.__fswab16,"ax",%progbits
  25              		.align	2
  27              	__fswab16:
  28              	.LFB3:
  29              		.file 1 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
  30              		.loc 1 47 0
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  34              	.LVL0:
  35 0000 0008A0E1 		mov	r0, r0, asl #16
  36              	.LVL1:
  37 0004 2008A0E1 		mov	r0, r0, lsr #16
  38              	.LVL2:
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
  39              		.loc 1 51 0
  40 0008 2034A0E1 		mov	r3, r0, lsr #8
  41 000c FF0000E2 		and	r0, r0, #255
  42              	.LVL3:
  52:include/swab.h **** #endif
  53:include/swab.h **** }
  43              		.loc 1 53 0
  44 0010 000483E1 		orr	r0, r3, r0, asl #8
  45              		.loc 1 47 0
  46              		@ lr needed for prologue
  47              		.loc 1 53 0
  48 0014 1EFF2FE1 		bx	lr
  49              	.LFE3:
  51              		.section	.text.msgb_tailroom,"ax",%progbits
  52              		.align	2
  54              	msgb_tailroom:
  55              	.LFB35:
  56              		.file 2 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
  57              		.loc 2 151 0
  58              		@ args = 0, pretend = 0, frame = 0
  59              		@ frame_needed = 0, uses_anonymous_args = 0
  60              		@ link register save eliminated.
  61              	.LVL4:
  62 0000 B423D0E1 		ldrh	r2, [r0, #52]
  63 0004 383090E5 		ldr	r3, [r0, #56]
  64 0008 3C0090E5 		ldr	r0, [r0, #60]
  65              	.LVL5:
  66 000c 023083E0 		add	r3, r3, r2
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
  67              		.loc 2 153 0
  68 0010 030060E0 		rsb	r0, r0, r3
  69              		.loc 2 151 0
  70              		@ lr needed for prologue
  71              		.loc 2 153 0
  72 0014 1EFF2FE1 		bx	lr
  73              	.LFE35:
  75              		.section	.rodata.str1.4,"aMS",%progbits,1
  76              		.align	2
  77              	.LC0:
  78 0000 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
  78      28257029 
  78      3A204E6F 
  78      7420656E 
  78      6F756768 
  79 0032 00       		.ascii	"\000"
  80              		.section	.text.msgb_put,"ax",%progbits
  81              		.align	2
  83              	msgb_put:
  84              	.LFB37:
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
  85              		.loc 2 180 0
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 0, uses_anonymous_args = 0
  88              	.LVL6:
  89 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  90              	.LCFI0:
  91              		.loc 2 180 0
  92 0004 0150A0E1 		mov	r5, r1
  93 0008 0040A0E1 		mov	r4, r0
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
  94              		.loc 2 182 0
  95 000c FEFFFFEB 		bl	msgb_tailroom
  96              	.LVL7:
  97 0010 050050E1 		cmp	r0, r5
  98 0014 0020A0E1 		mov	r2, r0
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
  99              		.loc 2 183 0
 100 0018 0410A0E1 		mov	r1, r4
 101 001c 28009FE5 		ldr	r0, .L9
 102 0020 0530A0E1 		mov	r3, r5
 103              		.loc 2 181 0
 104 0024 3C6094E5 		ldr	r6, [r4, #60]
 105              	.LVL8:
 106              		.loc 2 182 0
 107              	.LVL9:
 108              		.loc 2 183 0
 109 0028 FEFFFFBB 		bllt	osmo_panic
 110              	.LVL10:
 111              	.L6:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 112              		.loc 2 185 0
 113 002c 3C2094E5 		ldr	r2, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 114              		.loc 2 186 0
 115 0030 B633D4E1 		ldrh	r3, [r4, #54]
 116              		.loc 2 185 0
 117 0034 052082E0 		add	r2, r2, r5
 118              		.loc 2 186 0
 119 0038 053083E0 		add	r3, r3, r5
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 120              		.loc 2 188 0
 121 003c 0600A0E1 		mov	r0, r6
 122              		.loc 2 186 0
 123 0040 B633C4E1 		strh	r3, [r4, #54]	@ movhi
 124              		.loc 2 185 0
 125 0044 3C2084E5 		str	r2, [r4, #60]
 126              		.loc 2 188 0
 127 0048 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 128              	.L10:
 129              		.align	2
 130              	.L9:
 131 004c 00000000 		.word	.LC0
 132              	.LFE37:
 134              		.section	.text.l1_queue_for_l2,"ax",%progbits
 135              		.align	2
 136              		.global	l1_queue_for_l2
 138              	l1_queue_for_l2:
 139              	.LFB59:
 140              		.file 3 "layer1/l23_api.c"
   1:layer1/l23_api.c **** /* Synchronous part of GSM Layer 1: API to Layer2+ */
   2:layer1/l23_api.c **** 
   3:layer1/l23_api.c **** /* (C) 2010 by Holger Hans Peter Freyther <zecke@selfish.org>
   4:layer1/l23_api.c ****  *
   5:layer1/l23_api.c ****  * All Rights Reserved
   6:layer1/l23_api.c ****  *
   7:layer1/l23_api.c ****  * This program is free software; you can redistribute it and/or modify
   8:layer1/l23_api.c ****  * it under the terms of the GNU General Public License as published by
   9:layer1/l23_api.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:layer1/l23_api.c ****  * (at your option) any later version.
  11:layer1/l23_api.c ****  *
  12:layer1/l23_api.c ****  * This program is distributed in the hope that it will be useful,
  13:layer1/l23_api.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:layer1/l23_api.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:layer1/l23_api.c ****  * GNU General Public License for more details.
  16:layer1/l23_api.c ****  *
  17:layer1/l23_api.c ****  * You should have received a copy of the GNU General Public License along
  18:layer1/l23_api.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:layer1/l23_api.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:layer1/l23_api.c ****  *
  21:layer1/l23_api.c ****  */
  22:layer1/l23_api.c **** 
  23:layer1/l23_api.c **** #define DEBUG
  24:layer1/l23_api.c **** 
  25:layer1/l23_api.c **** #include <stdint.h>
  26:layer1/l23_api.c **** #include <stdio.h>
  27:layer1/l23_api.c **** #include <string.h>
  28:layer1/l23_api.c **** 
  29:layer1/l23_api.c **** #include <debug.h>
  30:layer1/l23_api.c **** #include <byteorder.h>
  31:layer1/l23_api.c **** 
  32:layer1/l23_api.c **** #include <asm/system.h>
  33:layer1/l23_api.c **** 
  34:layer1/l23_api.c **** #include <osmocom/core/msgb.h>
  35:layer1/l23_api.c **** #include <osmocom/gsm/protocol/gsm_04_08.h>
  36:layer1/l23_api.c **** #include <comm/sercomm.h>
  37:layer1/l23_api.c **** 
  38:layer1/l23_api.c **** #include <layer1/sync.h>
  39:layer1/l23_api.c **** #include <layer1/async.h>
  40:layer1/l23_api.c **** #include <layer1/mframe_sched.h>
  41:layer1/l23_api.c **** #include <layer1/prim.h>
  42:layer1/l23_api.c **** #include <layer1/tpu_window.h>
  43:layer1/l23_api.c **** #include <layer1/sched_gsmtime.h>
  44:layer1/l23_api.c **** 
  45:layer1/l23_api.c **** #include <abb/twl3025.h>
  46:layer1/l23_api.c **** #include <rf/trf6151.h>
  47:layer1/l23_api.c **** #include <calypso/sim.h>
  48:layer1/l23_api.c **** #include <calypso/dsp.h>
  49:layer1/l23_api.c **** 
  50:layer1/l23_api.c **** #include <l1ctl_proto.h>
  51:layer1/l23_api.c **** 
  52:layer1/l23_api.c **** /* the size we will allocate struct msgb* for HDLC */
  53:layer1/l23_api.c **** #define L3_MSG_HEAD 4
  54:layer1/l23_api.c **** #define L3_MSG_DATA 200
  55:layer1/l23_api.c **** #define L3_MSG_SIZE (L3_MSG_HEAD + sizeof(struct l1ctl_hdr) + L3_MSG_DATA)
  56:layer1/l23_api.c **** 
  57:layer1/l23_api.c **** void (*l1a_l23_tx_cb)(struct msgb *msg) = NULL;
  58:layer1/l23_api.c **** 
  59:layer1/l23_api.c **** void l1_queue_for_l2(struct msgb *msg)
  60:layer1/l23_api.c **** {
 141              		.loc 3 60 0
 142              		@ args = 0, pretend = 0, frame = 0
 143              		@ frame_needed = 0, uses_anonymous_args = 0
 144              	.LVL11:
 145 0000 04E02DE5 		str	lr, [sp, #-4]!
 146              	.LCFI1:
  61:layer1/l23_api.c **** 	if (l1a_l23_tx_cb) {
 147              		.loc 3 61 0
 148 0004 24309FE5 		ldr	r3, .L16
 149 0008 003093E5 		ldr	r3, [r3, #0]
 150 000c 000053E3 		cmp	r3, #0
 151              		.loc 3 60 0
 152 0010 0010A0E1 		mov	r1, r0
 153              		.loc 3 61 0
 154 0014 0700000A 		beq	.L12
 155              	.LVL12:
  62:layer1/l23_api.c **** 		l1a_l23_tx_cb(msg);
 156              		.loc 3 62 0
 157 0018 0FE0A0E1 		mov	lr, pc
 158 001c 13FF2FE1 		bx	r3
 159              	.LVL13:
  63:layer1/l23_api.c **** 		return;
  64:layer1/l23_api.c **** 	}
  65:layer1/l23_api.c **** 	/* forward via serial for now */
  66:layer1/l23_api.c **** 	sercomm_sendmsg(SC_DLCI_L1A_L23, msg);
  67:layer1/l23_api.c **** }
 160              		.loc 3 67 0
 161 0020 04F09DE4 		ldr	pc, [sp], #4
 162              	.LVL14:
 163              	.L12:
 164              		.loc 3 66 0
 165 0024 0500A0E3 		mov	r0, #5
 166              		.loc 3 67 0
 167 0028 04E09DE4 		ldr	lr, [sp], #4
 168              		.loc 3 66 0
 169 002c FEFFFFEA 		b	sercomm_sendmsg
 170              	.LVL15:
 171              	.L17:
 172              		.align	2
 173              	.L16:
 174 0030 00000000 		.word	l1a_l23_tx_cb
 175              	.LFE59:
 177              		.section	.text.audio_set_enabled,"ax",%progbits
 178              		.align	2
 180              	audio_set_enabled:
 181              	.LFB63:
  68:layer1/l23_api.c **** 
  69:layer1/l23_api.c **** enum mf_type {
  70:layer1/l23_api.c **** 	MFNONE,
  71:layer1/l23_api.c **** 	MF51,
  72:layer1/l23_api.c **** 	MF26ODD,
  73:layer1/l23_api.c **** 	MF26EVEN
  74:layer1/l23_api.c **** };
  75:layer1/l23_api.c **** static uint32_t chan_nr2mf_task_mask(uint8_t chan_nr, uint8_t neigh_mode)
  76:layer1/l23_api.c **** {
  77:layer1/l23_api.c **** 	uint8_t cbits = chan_nr >> 3;
  78:layer1/l23_api.c **** 	uint8_t tn = chan_nr & 0x7;
  79:layer1/l23_api.c **** 	uint8_t lch_idx;
  80:layer1/l23_api.c **** 	enum mframe_task master_task = 0;
  81:layer1/l23_api.c **** 	uint32_t neigh_task = 0;
  82:layer1/l23_api.c **** 	enum mf_type multiframe;
  83:layer1/l23_api.c **** 
  84:layer1/l23_api.c **** 	if (cbits == 0x01) {
  85:layer1/l23_api.c **** 		lch_idx = 0;
  86:layer1/l23_api.c **** 		master_task = (tn & 1) ? MF_TASK_TCH_F_ODD : MF_TASK_TCH_F_EVEN;
  87:layer1/l23_api.c **** 		multiframe = (tn & 1) ? MF26ODD : MF26EVEN;
  88:layer1/l23_api.c **** 	} else if ((cbits & 0x1e) == 0x02) {
  89:layer1/l23_api.c **** 		lch_idx = cbits & 0x1;
  90:layer1/l23_api.c **** 		master_task = MF_TASK_TCH_H_0 + lch_idx;
  91:layer1/l23_api.c **** 	} else if ((cbits & 0x1c) == 0x04) {
  92:layer1/l23_api.c **** 		lch_idx = cbits & 0x3;
  93:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH4_0 + lch_idx;
  94:layer1/l23_api.c **** 		multiframe = MF51;
  95:layer1/l23_api.c **** 	} else if ((cbits & 0x18) == 0x08) {
  96:layer1/l23_api.c **** 		lch_idx = cbits & 0x7;
  97:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH8_0 + lch_idx;
  98:layer1/l23_api.c **** 		multiframe = MF51;
  99:layer1/l23_api.c **** #if 0
 100:layer1/l23_api.c **** 	} else if (cbits == 0x10) {
 101:layer1/l23_api.c **** 		/* FIXME: when to do extended BCCH? */
 102:layer1/l23_api.c **** 		master_task = MF_TASK_BCCH_NORM;
 103:layer1/l23_api.c **** 	} else if (cbits == 0x11 || cbits == 0x12) {
 104:layer1/l23_api.c **** 		/* FIXME: how to decide CCCH norm/extd? */
 105:layer1/l23_api.c **** 		master_task = MF_TASK_BCCH_CCCH;
 106:layer1/l23_api.c **** #endif
 107:layer1/l23_api.c **** 	}
 108:layer1/l23_api.c **** 	switch (neigh_mode) {
 109:layer1/l23_api.c **** 	case NEIGH_MODE_PM:
 110:layer1/l23_api.c **** 		switch (multiframe) {
 111:layer1/l23_api.c **** 		case MF51:
 112:layer1/l23_api.c **** 			neigh_task = (1 << MF_TASK_NEIGH_PM51);
 113:layer1/l23_api.c **** 			break;
 114:layer1/l23_api.c **** 		case MF26EVEN:
 115:layer1/l23_api.c **** 			neigh_task = (1 << MF_TASK_NEIGH_PM26E);
 116:layer1/l23_api.c **** 			break;
 117:layer1/l23_api.c **** 		case MF26ODD:
 118:layer1/l23_api.c **** 			neigh_task = (1 << MF_TASK_NEIGH_PM26O);
 119:layer1/l23_api.c **** 			break;
 120:layer1/l23_api.c **** 		}
 121:layer1/l23_api.c **** 		break;
 122:layer1/l23_api.c **** 	}
 123:layer1/l23_api.c **** 	return (1 << master_task) | neigh_task;
 124:layer1/l23_api.c **** }
 125:layer1/l23_api.c **** 
 126:layer1/l23_api.c **** static int  chan_nr2dchan_type(uint8_t chan_nr)
 127:layer1/l23_api.c **** {
 128:layer1/l23_api.c **** 	uint8_t cbits = chan_nr >> 3;
 129:layer1/l23_api.c **** 
 130:layer1/l23_api.c **** 	if (cbits == 0x01) {
 131:layer1/l23_api.c **** 		return GSM_DCHAN_TCH_F;
 132:layer1/l23_api.c **** 	} else if ((cbits & 0x1e) == 0x02) {
 133:layer1/l23_api.c **** 		return GSM_DCHAN_TCH_H;
 134:layer1/l23_api.c **** 	} else if ((cbits & 0x1c) == 0x04) {
 135:layer1/l23_api.c **** 		return GSM_DCHAN_SDCCH_4;
 136:layer1/l23_api.c **** 	} else if ((cbits & 0x18) == 0x08) {
 137:layer1/l23_api.c **** 		return GSM_DCHAN_SDCCH_8;
 138:layer1/l23_api.c **** 	}
 139:layer1/l23_api.c **** 	return GSM_DCHAN_UNKNOWN;
 140:layer1/l23_api.c **** }
 141:layer1/l23_api.c **** 
 142:layer1/l23_api.c **** static int chan_nr_is_tch(uint8_t chan_nr)
 143:layer1/l23_api.c **** {
 144:layer1/l23_api.c **** 	return ((chan_nr >> 3) == 0x01 ||		/* TCH/F */
 145:layer1/l23_api.c **** 		((chan_nr >> 3) & 0x1e) == 0x02);	/* TCH/H */
 146:layer1/l23_api.c **** }
 147:layer1/l23_api.c **** 
 148:layer1/l23_api.c **** static void audio_set_enabled(uint8_t tch_mode, uint8_t audio_mode)
 149:layer1/l23_api.c **** {
 182              		.loc 3 149 0
 183              		@ args = 0, pretend = 0, frame = 0
 184              		@ frame_needed = 0, uses_anonymous_args = 0
 185              	.LVL16:
 186 0000 0030A0E1 		mov	r3, r0
 187 0004 30402DE9 		stmfd	sp!, {r4, r5, lr}
 188              	.LCFI2:
 150:layer1/l23_api.c **** 	if (tch_mode == GSM48_CMODE_SIGN) {
 189              		.loc 3 150 0
 190 0008 FF5013E2 		ands	r5, r3, #255
 191              		.loc 3 149 0
 192 000c 0130A0E1 		mov	r3, r1
 151:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VUL, 0);
 152:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VDL, 0);
 153:layer1/l23_api.c **** 	} else {
 154:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VUL,
 193              		.loc 3 154 0
 194 0010 0400A0E3 		mov	r0, #4
 195              	.LVL17:
 196 0014 011001E2 		and	r1, r1, #1
 197              	.LVL18:
 198              		.loc 3 149 0
 199 0018 FF4003E2 		and	r4, r3, #255
 200              		.loc 3 150 0
 201 001c 0A00001A 		bne	.L19
 202              	.LVL19:
 203              		.loc 3 151 0
 204 0020 0510A0E1 		mov	r1, r5
 205 0024 FEFFFFEB 		bl	twl3025_unit_enable
 206              		.loc 3 152 0
 207 0028 0510A0E1 		mov	r1, r5
 208 002c 0D0000EA 		b	.L23
 209              	.LVL20:
 210              	.L19:
 211              		.loc 3 154 0
 212 0030 FEFFFFEB 		bl	twl3025_unit_enable
 155:layer1/l23_api.c **** 		                    !!(audio_mode & AUDIO_TX_MICROPHONE));
 156:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VDL,
 213              		.loc 3 156 0
 214 0034 2411A0E1 		mov	r1, r4, lsr #2
 215 0038 011001E2 		and	r1, r1, #1
 216              	.LVL21:
 217              	.L23:
 218 003c 0300A0E3 		mov	r0, #3
 157:layer1/l23_api.c **** 		                    !!(audio_mode & AUDIO_RX_SPEAKER));
 158:layer1/l23_api.c **** 	}
 159:layer1/l23_api.c **** }
 219              		.loc 3 159 0
 220 0040 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 221              		.loc 3 156 0
 222 0044 FEFFFFEA 		b	twl3025_unit_enable
 223              	.LFE63:
 225              		.section	.rodata.str1.4
 226 0033 00       		.align	2
 227              	.LC1:
 228 0034 6C316374 		.ascii	"l1ctl\000"
 228      6C00
 229 003a 0000     		.align	2
 230              	.LC2:
 231 003c 4F4F5053 		.ascii	"OOPS. Out of buffers...\012\000"
 231      2E204F75 
 231      74206F66 
 231      20627566 
 231      66657273 
 232              		.section	.text.l1ctl_msgb_alloc,"ax",%progbits
 233              		.align	2
 234              		.global	l1ctl_msgb_alloc
 236              	l1ctl_msgb_alloc:
 237              	.LFB64:
 160:layer1/l23_api.c **** 
 161:layer1/l23_api.c **** struct msgb *l1ctl_msgb_alloc(uint8_t msg_type)
 162:layer1/l23_api.c **** {
 238              		.loc 3 162 0
 239              		@ args = 0, pretend = 0, frame = 0
 240              		@ frame_needed = 0, uses_anonymous_args = 0
 241              	.LVL22:
 242 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 243              	.LCFI3:
 244              		.loc 3 162 0
 245 0004 0030A0E1 		mov	r3, r0
 246              	.LBB2:
 247              	.LBB3:
 189:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 190:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint8 value to the end of the message
 191:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 192:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 8bit byte to be appended
 193:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 194:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u8(struct msgb *msgb, uint8_t word)
 195:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 196:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 1);
 197:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word & 0xFF;
 198:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 199:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 200:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint16 value to the end of the message
 201:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 202:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 16bit byte to be appended
 203:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 204:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u16(struct msgb *msgb, uint16_t word)
 205:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 206:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 2);
 207:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 8 & 0xFF;
 208:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word & 0xFF;
 209:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 210:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 211:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint32 value to the end of the message
 212:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 213:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 32bit byte to be appended
 214:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 215:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u32(struct msgb *msgb, uint32_t word)
 216:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 217:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 4);
 218:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 24 & 0xFF;
 219:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word >> 16 & 0xFF;
 220:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[2] = word >> 8 & 0xFF;
 221:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[3] = word & 0xFF;
 222:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 223:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 224:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove data from end of message
 225:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 226:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to remove from end
 227:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 228:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_get(struct msgb *msgb, unsigned int len)
 229:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 230:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->data - len;
 231:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_length(msgb) < len)
 232:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "msgb too small to get %u (len %u)\n",
 233:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   len, msgb_length(msgb));
 234:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail -= len;
 235:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 236:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 237:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 238:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from end of message
 239:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 240:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 241:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 242:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_get_u8(struct msgb *msgb)
 243:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 244:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 1);
 245:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 246:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 247:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from end of message
 248:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 249:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 250:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 251:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_get_u16(struct msgb *msgb)
 252:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 253:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 2);
 254:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 255:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 256:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from end of message
 257:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 258:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 259:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 260:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_get_u32(struct msgb *msgb)
 261:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 262:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 4);
 263:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 264:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 265:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 266:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief prepend (push) some data to start of message
 267:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 268:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to pre-pend
 269:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to newly added portion at start of \a msgb
 270:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 271:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further
 272:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * to the front (by \a len bytes), thereby enlarging the message by \a
 273:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes.
 274:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 275:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to the newly added section in the
 276:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * beginning of the message.  It can be used to fill/copy data into it.
 277:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 278:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_push(struct msgb *msgb, unsigned int len)
 279:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 280:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_headroom(msgb) < (int) len)
 281:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough headroom msgb_push (%u < %u)\n",
 282:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_headroom(msgb), len);
 283:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->data -= len;
 284:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 285:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data;
 286:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 287:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove (pull) a header from the front of the message buffer
 288:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 289:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of octets to be pulled
 290:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to new start of msgb
 291:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 292:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further back
 293:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * in the message, thereby shrinking the size of the message by \a len
 294:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * bytes.
 295:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 296:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_pull(struct msgb *msgb, unsigned int len)
 297:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 300:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 301:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 302:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from front of message
 303:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 304:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 305:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 306:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_pull_u8(struct msgb *msgb)
 307:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 308:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 1) - 1;
 309:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 310:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 311:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from front of message
 312:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 313:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 314:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 315:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_pull_u16(struct msgb *msgb)
 316:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 317:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 2) - 2;
 318:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 319:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 320:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from front of message
 321:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 322:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 323:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 324:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_pull_u32(struct msgb *msgb)
 325:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 326:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 4) - 4;
 327:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 328:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 329:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 330:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Increase headroom of empty msgb, reducing the tailroom
 331:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 332:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len amount of extra octets to be reserved as headroom
 333:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 334:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function reserves some memory at the beginning of the underlying
 335:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer.  The idea is to reserve space in case further headers
 336:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * have to be pushed to the \ref msgb during further processing.
 337:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 338:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * Calling this function leads to undefined reusults if it is called on
 339:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * a non-empty \ref msgb.
 340:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 341:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_reserve(struct msgb *msg, int len)
 342:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 343:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->data += len;
 344:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail += len;
 345:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 346:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 347:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Trim the msgb to a given absolute length
 348:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 349:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len new total length of buffer
 350:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 0 in case of success, negative in case of error
 351:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 352:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_trim(struct msgb *msg, int len)
 353:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 354:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (len > msg->data_len)
 355:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		return -1;
 356:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 357:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->len = len;
 358:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail = msg->data + len;
 359:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 360:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return 0;
 361:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 362:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 363:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Trim the msgb to a given layer3 length
 364:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \pram[in] msg message buffer
 365:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] l3len new layer3 length
 366:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 0 in case of success, negative in case of error
 367:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 368:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_l3trim(struct msgb *msg, int l3len)
 369:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 370:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb_trim(msg, (msg->l3h - msg->data) + l3len);
 371:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 372:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 373:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Allocate message buffer with specified headroom
 374:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] size size in bytes, including headroom
 375:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] headroom headroom in bytes
 376:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] name human-readable name
 377:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns allocated message buffer with specified headroom
 378:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 379:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function is a convenience wrapper around \ref msgb_alloc
 380:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * followed by \ref msgb_reserve in order to create a new \ref msgb with
 381:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * user-specified amount of headroom.
 382:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 383:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline struct msgb *msgb_alloc_headroom(int size, int headroom,
 384:../../shared/libosmocore/include/osmocom/core/msgb.h **** 						const char *name)
 385:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 386:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_static_assert(size > headroom, headroom_bigger);
 387:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 388:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct msgb *msg = msgb_alloc(size, name);
 248              		.loc 2 388 0
 249 0008 54109FE5 		ldr	r1, .L30
 250 000c D000A0E3 		mov	r0, #208
 251              	.LVL23:
 252              	.LBE3:
 253              	.LBE2:
 254              		.loc 3 162 0
 255 0010 FF5003E2 		and	r5, r3, #255
 256              	.LBB4:
 257              	.LBB5:
 258              		.loc 2 388 0
 259 0014 FEFFFFEB 		bl	msgb_alloc
 260              	.LVL24:
 389:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msg)
 261              		.loc 2 389 0
 262 0018 004050E2 		subs	r4, r0, #0
 263              	.LVL25:
 264 001c 0900001A 		bne	.L28
 265              	.L29:
 266              	.LBE5:
 267              	.LBE4:
 163:layer1/l23_api.c **** 	struct msgb *msg;
 164:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h;
 165:layer1/l23_api.c **** 
 166:layer1/l23_api.c **** 	msg = msgb_alloc_headroom(L3_MSG_SIZE, L3_MSG_HEAD, "l1ctl");
 167:layer1/l23_api.c **** 	if (!msg) {
 168:layer1/l23_api.c **** 		while (1) {
 169:layer1/l23_api.c **** 			puts("OOPS. Out of buffers...\n");
 268              		.loc 3 169 0
 269 0020 40009FE5 		ldr	r0, .L30+4
 270 0024 FEFFFFEB 		bl	puts
 271 0028 060000EA 		b	.L29
 272              	.L28:
 273              	.LBB6:
 274              	.LBB7:
 275              	.LBB8:
 276              	.LBB9:
 277              		.loc 2 343 0
 278 002c 3C2084E2 		add	r2, r4, #60
 279 0030 0C0092E8 		ldmia	r2, {r2, r3}	@ phole ldm
 280 0034 043083E2 		add	r3, r3, #4
 281              		.loc 2 344 0
 282 0038 042082E2 		add	r2, r2, #4
 283              		.loc 2 343 0
 284 003c 403084E5 		str	r3, [r4, #64]
 285              		.loc 2 344 0
 286 0040 3C2084E5 		str	r2, [r4, #60]
 287              	.LBE9:
 288              	.LBE8:
 289              	.LBE7:
 290              	.LBE6:
 170:layer1/l23_api.c **** 		}
 171:layer1/l23_api.c **** 
 172:layer1/l23_api.c **** 		return NULL;
 173:layer1/l23_api.c **** 	}
 174:layer1/l23_api.c **** 	l1h = (struct l1ctl_hdr *) msgb_put(msg, sizeof(*l1h));
 291              		.loc 3 174 0
 292 0044 0410A0E3 		mov	r1, #4
 293 0048 FEFFFFEB 		bl	msgb_put
 175:layer1/l23_api.c **** 	l1h->msg_type = msg_type;
 176:layer1/l23_api.c **** 	l1h->flags = 0;
 294              		.loc 3 176 0
 295 004c 0030A0E3 		mov	r3, #0
 296              		.loc 3 175 0
 297 0050 0050C0E5 		strb	r5, [r0, #0]
 298              		.loc 3 176 0
 299 0054 0130C0E5 		strb	r3, [r0, #1]
 177:layer1/l23_api.c **** 
 178:layer1/l23_api.c **** 	msg->l1h = (uint8_t *)l1h;
 300              		.loc 3 178 0
 301 0058 100084E5 		str	r0, [r4, #16]
 179:layer1/l23_api.c **** 
 180:layer1/l23_api.c **** 	return msg;
 181:layer1/l23_api.c **** }
 302              		.loc 3 181 0
 303 005c 0400A0E1 		mov	r0, r4
 304 0060 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 305              	.L31:
 306              		.align	2
 307              	.L30:
 308 0064 34000000 		.word	.LC1
 309 0068 3C000000 		.word	.LC2
 310              	.LFE64:
 312              		.section	.text.l1_create_l2_msg,"ax",%progbits
 313              		.align	2
 314              		.global	l1_create_l2_msg
 316              	l1_create_l2_msg:
 317              	.LFB65:
 182:layer1/l23_api.c **** 
 183:layer1/l23_api.c **** struct msgb *l1_create_l2_msg(int msg_type, uint32_t fn, uint16_t snr,
 184:layer1/l23_api.c **** 			      uint16_t arfcn)
 185:layer1/l23_api.c **** {
 318              		.loc 3 185 0
 319              		@ args = 0, pretend = 0, frame = 0
 320              		@ frame_needed = 0, uses_anonymous_args = 0
 321              	.LVL26:
 322 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 323              	.LCFI4:
 186:layer1/l23_api.c **** 	struct l1ctl_info_dl *dl;
 187:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 324              		.loc 3 187 0
 325 0004 FF0000E2 		and	r0, r0, #255
 326              	.LVL27:
 327              		.loc 3 185 0
 328 0008 0150A0E1 		mov	r5, r1
 329 000c 0268A0E1 		mov	r6, r2, asl #16
 330 0010 0378A0E1 		mov	r7, r3, asl #16
 331              		.loc 3 187 0
 332 0014 FEFFFFEB 		bl	l1ctl_msgb_alloc
 333              	.LVL28:
 188:layer1/l23_api.c **** 
 189:layer1/l23_api.c **** 	dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 334              		.loc 3 189 0
 335 0018 0C10A0E3 		mov	r1, #12
 336              		.loc 3 187 0
 337 001c 0080A0E1 		mov	r8, r0
 338              	.LVL29:
 339              		.loc 3 189 0
 340 0020 FEFFFFEB 		bl	msgb_put
 341              	.LBB10:
 342              	.LBB11:
 343              	.LBB12:
 344              	.LBB13:
 345              		.file 4 "include/asm/swab.h"
   1:include/asm/swab.h **** /*
   2:include/asm/swab.h ****  *  arch/arm/include/asm/byteorder.h
   3:include/asm/swab.h ****  *
   4:include/asm/swab.h ****  * ARM Endian-ness.  In little endian mode, the data bus is connected such
   5:include/asm/swab.h ****  * that byte accesses appear as:
   6:include/asm/swab.h ****  *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
   7:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
   8:include/asm/swab.h ****  *  d0...d31
   9:include/asm/swab.h ****  *
  10:include/asm/swab.h ****  * When in big endian mode, byte accesses appear as:
  11:include/asm/swab.h ****  *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
  12:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
  13:include/asm/swab.h ****  *  d0...d31
  14:include/asm/swab.h ****  */
  15:include/asm/swab.h **** #ifndef __ASM_ARM_SWAB_H
  16:include/asm/swab.h **** #define __ASM_ARM_SWAB_H
  17:include/asm/swab.h **** 
  18:include/asm/swab.h **** #include <stdint.h>
  19:include/asm/swab.h **** #include <defines.h>
  20:include/asm/swab.h **** 
  21:include/asm/swab.h **** static inline uint32_t __arch_swab32(uint32_t x)
  22:include/asm/swab.h **** {
  23:include/asm/swab.h **** 	uint32_t t;
  24:include/asm/swab.h **** 
  25:include/asm/swab.h **** #ifndef __thumb__
  26:include/asm/swab.h **** 	if (!__builtin_constant_p(x)) {
  27:include/asm/swab.h **** 		/*
  28:include/asm/swab.h **** 		 * The compiler needs a bit of a hint here to always do the
  29:include/asm/swab.h **** 		 * right thing and not screw it up to different degrees
  30:include/asm/swab.h **** 		 * depending on the gcc version.
  31:include/asm/swab.h **** 		 */
  32:include/asm/swab.h **** 		asm ("eor\t%0, %1, %1, ror #16" : "=r" (t) : "r" (x));
 346              		.loc 4 32 0
 347 0024 653825E0 		eor	r3, r5, r5, ror #16
 348              	.LVL30:
 349              	.LBE13:
 350              	.LBE12:
 351              	.LBE11:
 352              	.LBE10:
 190:layer1/l23_api.c **** 	dl->frame_nr = htonl(fn);
 353              		.loc 3 190 0
 354 0028 FF38C3E3 		bic	r3, r3, #16711680
 355              	.LVL31:
 356 002c 2334A0E1 		mov	r3, r3, lsr #8
 357 0030 653423E0 		eor	r3, r3, r5, ror #8
 358              		.loc 3 189 0
 359 0034 0040A0E1 		mov	r4, r0
 360              		.loc 3 190 0
 361 0038 2324A0E1 		mov	r2, r3, lsr #8
 362 003c 230CA0E1 		mov	r0, r3, lsr #24
 363 0040 2318A0E1 		mov	r1, r3, lsr #16
 364              		.loc 3 185 0
 365 0044 2668A0E1 		mov	r6, r6, lsr #16
 366              	.LVL32:
 367 0048 2778A0E1 		mov	r7, r7, lsr #16
 368              	.LVL33:
 369              		.loc 3 190 0
 370 004c 0700C4E5 		strb	r0, [r4, #7]
 371 0050 0430C4E5 		strb	r3, [r4, #4]
 372 0054 0520C4E5 		strb	r2, [r4, #5]
 373 0058 0610C4E5 		strb	r1, [r4, #6]
 191:layer1/l23_api.c **** 	dl->snr = snr;
 374              		.loc 3 191 0
 375 005c 0960C4E5 		strb	r6, [r4, #9]
 192:layer1/l23_api.c **** 	dl->band_arfcn = htons(arfcn);
 376              		.loc 3 192 0
 377 0060 0700A0E1 		mov	r0, r7
 378 0064 FEFFFFEB 		bl	__fswab16
 379 0068 2034A0E1 		mov	r3, r0, lsr #8
 380 006c 0200C4E5 		strb	r0, [r4, #2]
 193:layer1/l23_api.c **** 
 194:layer1/l23_api.c **** 	return msg;
 195:layer1/l23_api.c **** }
 381              		.loc 3 195 0
 382 0070 0800A0E1 		mov	r0, r8
 383              		.loc 3 192 0
 384 0074 0330C4E5 		strb	r3, [r4, #3]
 385              		.loc 3 195 0
 386 0078 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 387              	.LFE65:
 389              		.section	.text.l1ctl_tx_reset,"ax",%progbits
 390              		.align	2
 391              		.global	l1ctl_tx_reset
 393              	l1ctl_tx_reset:
 394              	.LFB75:
 196:layer1/l23_api.c **** 
 197:layer1/l23_api.c **** /* receive a L1CTL_FBSB_REQ from L23 */
 198:layer1/l23_api.c **** static void l1ctl_rx_fbsb_req(struct msgb *msg)
 199:layer1/l23_api.c **** {
 200:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 201:layer1/l23_api.c **** 	struct l1ctl_fbsb_req *sync_req = (struct l1ctl_fbsb_req *) l1h->data;
 202:layer1/l23_api.c **** 
 203:layer1/l23_api.c **** 	if (sizeof(*sync_req) > msg->len) {
 204:layer1/l23_api.c **** 		printf("Short sync msg. %u\n", msg->len);
 205:layer1/l23_api.c **** 		return;
 206:layer1/l23_api.c **** 	}
 207:layer1/l23_api.c **** 
 208:layer1/l23_api.c **** 	printd("L1CTL_FBSB_REQ (arfcn=%u, flags=0x%x)\n",
 209:layer1/l23_api.c **** 		ntohs(sync_req->band_arfcn), sync_req->flags);
 210:layer1/l23_api.c **** 
 211:layer1/l23_api.c **** 	/* reset scheduler and hardware */
 212:layer1/l23_api.c **** 	l1s_reset();
 213:layer1/l23_api.c **** 
 214:layer1/l23_api.c **** 	/* pre-set the CCCH mode */
 215:layer1/l23_api.c **** 	l1s.serving_cell.ccch_mode = sync_req->ccch_mode;
 216:layer1/l23_api.c **** 
 217:layer1/l23_api.c **** 	printd("Starting FCCH Recognition\n");
 218:layer1/l23_api.c **** 	l1s_fbsb_req(1, sync_req);
 219:layer1/l23_api.c **** }
 220:layer1/l23_api.c **** 
 221:layer1/l23_api.c **** /* receive a L1CTL_DM_EST_REQ from L23 */
 222:layer1/l23_api.c **** static void l1ctl_rx_dm_est_req(struct msgb *msg)
 223:layer1/l23_api.c **** {
 224:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 225:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 226:layer1/l23_api.c **** 	struct l1ctl_dm_est_req *est_req = (struct l1ctl_dm_est_req *) ul->payload;
 227:layer1/l23_api.c **** 
 228:layer1/l23_api.c **** 	printd("L1CTL_DM_EST_REQ (arfcn=%u, chan_nr=0x%02x, tsc=%u)\n",
 229:layer1/l23_api.c **** 		ntohs(est_req->h0.band_arfcn), ul->chan_nr, est_req->tsc);
 230:layer1/l23_api.c **** 
 231:layer1/l23_api.c **** 	/* disable neighbour cell measurement of C0 TS 0 */
 232:layer1/l23_api.c **** 	mframe_disable(MF_TASK_NEIGH_PM51_C0T0);
 233:layer1/l23_api.c **** 
 234:layer1/l23_api.c **** 	/* configure dedicated channel state */
 235:layer1/l23_api.c **** 	l1s.dedicated.type = chan_nr2dchan_type(ul->chan_nr);
 236:layer1/l23_api.c **** 	l1s.dedicated.tsc  = est_req->tsc;
 237:layer1/l23_api.c **** 	l1s.dedicated.tn   = ul->chan_nr & 0x7;
 238:layer1/l23_api.c **** 	l1s.dedicated.h    = est_req->h;
 239:layer1/l23_api.c **** 
 240:layer1/l23_api.c **** 	if (est_req->h) {
 241:layer1/l23_api.c **** 		int i;
 242:layer1/l23_api.c **** 		l1s.dedicated.h1.hsn  = est_req->h1.hsn;
 243:layer1/l23_api.c **** 		l1s.dedicated.h1.maio = est_req->h1.maio;
 244:layer1/l23_api.c **** 		l1s.dedicated.h1.n    = est_req->h1.n;
 245:layer1/l23_api.c **** 		for (i=0; i<est_req->h1.n; i++)
 246:layer1/l23_api.c **** 			l1s.dedicated.h1.ma[i] = ntohs(est_req->h1.ma[i]);
 247:layer1/l23_api.c **** 	} else {
 248:layer1/l23_api.c **** 		l1s.dedicated.h0.arfcn = ntohs(est_req->h0.band_arfcn);
 249:layer1/l23_api.c **** 	}
 250:layer1/l23_api.c **** 
 251:layer1/l23_api.c **** 	/* TCH config */
 252:layer1/l23_api.c **** 	if (chan_nr_is_tch(ul->chan_nr)) {
 253:layer1/l23_api.c **** 		/* Mode */
 254:layer1/l23_api.c **** 		l1a_tch_mode_set(est_req->tch_mode);
 255:layer1/l23_api.c **** 		l1a_audio_mode_set(est_req->audio_mode);
 256:layer1/l23_api.c **** 
 257:layer1/l23_api.c **** 		/* Sync */
 258:layer1/l23_api.c **** 		l1s.tch_sync = 1;	/* can be set without locking */
 259:layer1/l23_api.c **** 
 260:layer1/l23_api.c **** 		/* Audio path */
 261:layer1/l23_api.c **** 		audio_set_enabled(est_req->tch_mode, est_req->audio_mode);
 262:layer1/l23_api.c **** 	}
 263:layer1/l23_api.c **** 
 264:layer1/l23_api.c **** 	/* figure out which MF tasks to enable */
 265:layer1/l23_api.c **** 	l1a_mftask_set(chan_nr2mf_task_mask(ul->chan_nr, NEIGH_MODE_PM));
 266:layer1/l23_api.c **** }
 267:layer1/l23_api.c **** 
 268:layer1/l23_api.c **** /* receive a L1CTL_DM_FREQ_REQ from L23 */
 269:layer1/l23_api.c **** static void l1ctl_rx_dm_freq_req(struct msgb *msg)
 270:layer1/l23_api.c **** {
 271:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 272:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 273:layer1/l23_api.c **** 	struct l1ctl_dm_freq_req *freq_req =
 274:layer1/l23_api.c **** 			(struct l1ctl_dm_freq_req *) ul->payload;
 275:layer1/l23_api.c **** 
 276:layer1/l23_api.c **** 	printd("L1CTL_DM_FREQ_REQ (arfcn=%u, tsc=%u)\n",
 277:layer1/l23_api.c **** 		ntohs(freq_req->h0.band_arfcn), freq_req->tsc);
 278:layer1/l23_api.c **** 
 279:layer1/l23_api.c **** 	/* configure dedicated channel state */
 280:layer1/l23_api.c **** 	l1s.dedicated.st_tsc  = freq_req->tsc;
 281:layer1/l23_api.c **** 	l1s.dedicated.st_h    = freq_req->h;
 282:layer1/l23_api.c **** 
 283:layer1/l23_api.c **** 	if (freq_req->h) {
 284:layer1/l23_api.c **** 		int i;
 285:layer1/l23_api.c **** 		l1s.dedicated.st_h1.hsn  = freq_req->h1.hsn;
 286:layer1/l23_api.c **** 		l1s.dedicated.st_h1.maio = freq_req->h1.maio;
 287:layer1/l23_api.c **** 		l1s.dedicated.st_h1.n    = freq_req->h1.n;
 288:layer1/l23_api.c **** 		for (i=0; i<freq_req->h1.n; i++)
 289:layer1/l23_api.c **** 			l1s.dedicated.st_h1.ma[i] = ntohs(freq_req->h1.ma[i]);
 290:layer1/l23_api.c **** 	} else {
 291:layer1/l23_api.c **** 		l1s.dedicated.st_h0.arfcn = ntohs(freq_req->h0.band_arfcn);
 292:layer1/l23_api.c **** 	}
 293:layer1/l23_api.c **** 
 294:layer1/l23_api.c **** 	l1a_freq_req(ntohs(freq_req->fn));
 295:layer1/l23_api.c **** }
 296:layer1/l23_api.c **** 
 297:layer1/l23_api.c **** /* receive a L1CTL_CRYPTO_REQ from L23 */
 298:layer1/l23_api.c **** static void l1ctl_rx_crypto_req(struct msgb *msg)
 299:layer1/l23_api.c **** {
 300:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 301:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 302:layer1/l23_api.c **** 	struct l1ctl_crypto_req *cr = (struct l1ctl_crypto_req *) ul->payload;
 303:layer1/l23_api.c **** 	uint8_t key_len = msg->len - sizeof(*l1h) - sizeof(*ul) - sizeof(*cr);
 304:layer1/l23_api.c **** 
 305:layer1/l23_api.c **** 	printd("L1CTL_CRYPTO_REQ (algo=A5/%u, len=%u)\n", cr->algo, key_len);
 306:layer1/l23_api.c **** 
 307:layer1/l23_api.c **** 	if (cr->algo && key_len != 8) {
 308:layer1/l23_api.c **** 		printd("L1CTL_CRYPTO_REQ -> Invalid key\n");
 309:layer1/l23_api.c **** 		return;
 310:layer1/l23_api.c **** 	}
 311:layer1/l23_api.c **** 
 312:layer1/l23_api.c **** 	dsp_load_ciph_param(cr->algo, cr->key);
 313:layer1/l23_api.c **** }
 314:layer1/l23_api.c **** 
 315:layer1/l23_api.c **** /* receive a L1CTL_DM_REL_REQ from L23 */
 316:layer1/l23_api.c **** static void l1ctl_rx_dm_rel_req(struct msgb *msg)
 317:layer1/l23_api.c **** {
 318:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 319:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 320:layer1/l23_api.c **** 
 321:layer1/l23_api.c **** 	printd("L1CTL_DM_REL_REQ\n");
 322:layer1/l23_api.c **** 	l1a_mftask_set(0);
 323:layer1/l23_api.c **** 	l1s.dedicated.type = GSM_DCHAN_NONE;
 324:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_MAIN]);
 325:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_SACCH]);
 326:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 327:layer1/l23_api.c **** 	l1a_meas_msgb_set(NULL);
 328:layer1/l23_api.c **** 	dsp_load_ciph_param(0, NULL);
 329:layer1/l23_api.c **** 	l1a_tch_mode_set(GSM48_CMODE_SIGN);
 330:layer1/l23_api.c **** 	audio_set_enabled(GSM48_CMODE_SIGN, 0);
 331:layer1/l23_api.c **** 	l1s.neigh_pm.n = 0;
 332:layer1/l23_api.c **** }
 333:layer1/l23_api.c **** 
 334:layer1/l23_api.c **** /* receive a L1CTL_PARAM_REQ from L23 */
 335:layer1/l23_api.c **** static void l1ctl_rx_param_req(struct msgb *msg)
 336:layer1/l23_api.c **** {
 337:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 338:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 339:layer1/l23_api.c **** 	struct l1ctl_par_req *par_req = (struct l1ctl_par_req *) ul->payload;
 340:layer1/l23_api.c **** 
 341:layer1/l23_api.c **** 	printd("L1CTL_PARAM_REQ (ta=%d, tx_power=%d)\n", par_req->ta,
 342:layer1/l23_api.c **** 		par_req->tx_power);
 343:layer1/l23_api.c **** 
 344:layer1/l23_api.c **** 	l1s.ta = par_req->ta;
 345:layer1/l23_api.c **** 	l1s.tx_power = par_req->tx_power;
 346:layer1/l23_api.c **** }
 347:layer1/l23_api.c **** 
 348:layer1/l23_api.c **** /* receive a L1CTL_RACH_REQ from L23 */
 349:layer1/l23_api.c **** static void l1ctl_rx_rach_req(struct msgb *msg)
 350:layer1/l23_api.c **** {
 351:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 352:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 353:layer1/l23_api.c **** 	struct l1ctl_rach_req *rach_req = (struct l1ctl_rach_req *) ul->payload;
 354:layer1/l23_api.c **** 
 355:layer1/l23_api.c **** 	printd("L1CTL_RACH_REQ (ra=0x%02x, offset=%d combined=%d)\n",
 356:layer1/l23_api.c **** 		rach_req->ra, ntohs(rach_req->offset), rach_req->combined);
 357:layer1/l23_api.c **** 
 358:layer1/l23_api.c **** 	l1a_rach_req(ntohs(rach_req->offset), rach_req->combined,
 359:layer1/l23_api.c **** 		rach_req->ra);
 360:layer1/l23_api.c **** }
 361:layer1/l23_api.c **** 
 362:layer1/l23_api.c **** /* receive a L1CTL_DATA_REQ from L23 */
 363:layer1/l23_api.c **** static void l1ctl_rx_data_req(struct msgb *msg)
 364:layer1/l23_api.c **** {
 365:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 366:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 367:layer1/l23_api.c **** 	struct l1ctl_data_ind *data_ind = (struct l1ctl_data_ind *) ul->payload;
 368:layer1/l23_api.c **** 	struct llist_head *tx_queue;
 369:layer1/l23_api.c **** 
 370:layer1/l23_api.c **** 	printd("L1CTL_DATA_REQ (link_id=0x%02x)\n", ul->link_id);
 371:layer1/l23_api.c **** 
 372:layer1/l23_api.c **** 	msg->l3h = data_ind->data;
 373:layer1/l23_api.c **** 	if (ul->link_id & 0x40) {
 374:layer1/l23_api.c **** 		struct gsm48_hdr *gh = (struct gsm48_hdr *)(data_ind->data + 5);
 375:layer1/l23_api.c **** 		if (gh->proto_discr == GSM48_PDISC_RR
 376:layer1/l23_api.c **** 		 && gh->msg_type == GSM48_MT_RR_MEAS_REP) {
 377:layer1/l23_api.c **** 			printd("updating measurement report\n");
 378:layer1/l23_api.c **** 			l1a_meas_msgb_set(msg);
 379:layer1/l23_api.c **** 			return;
 380:layer1/l23_api.c **** 		}
 381:layer1/l23_api.c **** 		tx_queue = &l1s.tx_queue[L1S_CHAN_SACCH];
 382:layer1/l23_api.c **** 	} else
 383:layer1/l23_api.c **** 		tx_queue = &l1s.tx_queue[L1S_CHAN_MAIN];
 384:layer1/l23_api.c **** 
 385:layer1/l23_api.c **** 	printd("ul=%p, ul->payload=%p, data_ind=%p, data_ind->data=%p l3h=%p\n",
 386:layer1/l23_api.c **** 		ul, ul->payload, data_ind, data_ind->data, msg->l3h);
 387:layer1/l23_api.c **** 
 388:layer1/l23_api.c **** 	l1a_txq_msgb_enq(tx_queue, msg);
 389:layer1/l23_api.c **** }
 390:layer1/l23_api.c **** 
 391:layer1/l23_api.c **** /* receive a L1CTL_PM_REQ from L23 */
 392:layer1/l23_api.c **** static void l1ctl_rx_pm_req(struct msgb *msg)
 393:layer1/l23_api.c **** {
 394:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 395:layer1/l23_api.c **** 	struct l1ctl_pm_req *pm_req = (struct l1ctl_pm_req *) l1h->data;
 396:layer1/l23_api.c **** 
 397:layer1/l23_api.c **** 	switch (pm_req->type) {
 398:layer1/l23_api.c **** 	case 1:
 399:layer1/l23_api.c **** 		l1s.pm.mode = 1;
 400:layer1/l23_api.c **** 		l1s.pm.range.arfcn_start =
 401:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_from);
 402:layer1/l23_api.c **** 		l1s.pm.range.arfcn_next =
 403:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_from);
 404:layer1/l23_api.c **** 		l1s.pm.range.arfcn_end =
 405:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_to);
 406:layer1/l23_api.c **** 		printf("L1CTL_PM_REQ start=%u end=%u\n",
 407:layer1/l23_api.c **** 			l1s.pm.range.arfcn_start, l1s.pm.range.arfcn_end);
 408:layer1/l23_api.c **** 		break;
 409:layer1/l23_api.c **** 	}
 410:layer1/l23_api.c **** 	l1s_reset_hw(); /* must reset, otherwise measurement results are delayed */
 411:layer1/l23_api.c **** 	l1s_pm_test(1, l1s.pm.range.arfcn_next);
 412:layer1/l23_api.c **** }
 413:layer1/l23_api.c **** 
 414:layer1/l23_api.c **** /* Transmit a L1CTL_RESET_IND or L1CTL_RESET_CONF */
 415:layer1/l23_api.c **** void l1ctl_tx_reset(uint8_t msg_type, uint8_t reset_type)
 416:layer1/l23_api.c **** {
 395              		.loc 3 416 0
 396              		@ args = 0, pretend = 0, frame = 0
 397              		@ frame_needed = 0, uses_anonymous_args = 0
 398              	.LVL34:
 399 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 400              	.LCFI5:
 401              		.loc 3 416 0
 402 0004 FF0000E2 		and	r0, r0, #255
 403 0008 FF4001E2 		and	r4, r1, #255
 417:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 404              		.loc 3 417 0
 405 000c FEFFFFEB 		bl	l1ctl_msgb_alloc
 406              	.LVL35:
 418:layer1/l23_api.c **** 	struct l1ctl_reset *reset_resp;
 419:layer1/l23_api.c **** 	reset_resp = (struct l1ctl_reset *)
 407              		.loc 3 419 0
 408 0010 0410A0E3 		mov	r1, #4
 409              		.loc 3 417 0
 410 0014 0050A0E1 		mov	r5, r0
 411              	.LVL36:
 412              		.loc 3 419 0
 413 0018 FEFFFFEB 		bl	msgb_put
 420:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*reset_resp));
 421:layer1/l23_api.c **** 	reset_resp->type = reset_type;
 414              		.loc 3 421 0
 415 001c 0040C0E5 		strb	r4, [r0, #0]
 422:layer1/l23_api.c **** 
 423:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 416              		.loc 3 423 0
 417 0020 0500A0E1 		mov	r0, r5
 424:layer1/l23_api.c **** }
 418              		.loc 3 424 0
 419 0024 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 420              		.loc 3 423 0
 421 0028 FEFFFFEA 		b	l1_queue_for_l2
 422              	.LFE75:
 424              		.section	.text.l1a_l23_rx,"ax",%progbits
 425              		.align	2
 426              		.global	l1a_l23_rx
 428              	l1a_l23_rx:
 429              	.LFB84:
 425:layer1/l23_api.c **** 
 426:layer1/l23_api.c **** /* receive a L1CTL_RESET_REQ from L23 */
 427:layer1/l23_api.c **** static void l1ctl_rx_reset_req(struct msgb *msg)
 428:layer1/l23_api.c **** {
 429:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 430:layer1/l23_api.c **** 	struct l1ctl_reset *reset_req =
 431:layer1/l23_api.c **** 				(struct l1ctl_reset *) l1h->data;
 432:layer1/l23_api.c **** 
 433:layer1/l23_api.c **** 	switch (reset_req->type) {
 434:layer1/l23_api.c **** 	case L1CTL_RES_T_FULL:
 435:layer1/l23_api.c **** 		printf("L1CTL_RESET_REQ: FULL!\n");
 436:layer1/l23_api.c **** 		l1s_reset();
 437:layer1/l23_api.c **** 		l1s_reset_hw();
 438:layer1/l23_api.c **** 		audio_set_enabled(GSM48_CMODE_SIGN, 0);
 439:layer1/l23_api.c **** 		l1ctl_tx_reset(L1CTL_RESET_CONF, reset_req->type);
 440:layer1/l23_api.c **** 		break;
 441:layer1/l23_api.c **** 	case L1CTL_RES_T_SCHED:
 442:layer1/l23_api.c **** 		printf("L1CTL_RESET_REQ: SCHED!\n");
 443:layer1/l23_api.c **** 		l1ctl_tx_reset(L1CTL_RESET_CONF, reset_req->type);
 444:layer1/l23_api.c **** 		sched_gsmtime_reset();
 445:layer1/l23_api.c **** 		break;
 446:layer1/l23_api.c **** 	default:
 447:layer1/l23_api.c **** 		printf("unknown L1CTL_RESET_REQ type\n");
 448:layer1/l23_api.c **** 		break;
 449:layer1/l23_api.c **** 	}
 450:layer1/l23_api.c **** }
 451:layer1/l23_api.c **** 
 452:layer1/l23_api.c **** /* Transmit a L1CTL_CCCH_MODE_CONF */
 453:layer1/l23_api.c **** static void l1ctl_tx_ccch_mode_conf(uint8_t ccch_mode)
 454:layer1/l23_api.c **** {
 455:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(L1CTL_CCCH_MODE_CONF);
 456:layer1/l23_api.c **** 	struct l1ctl_ccch_mode_conf *mode_conf;
 457:layer1/l23_api.c **** 	mode_conf = (struct l1ctl_ccch_mode_conf *)
 458:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*mode_conf));
 459:layer1/l23_api.c **** 	mode_conf->ccch_mode = ccch_mode;
 460:layer1/l23_api.c **** 
 461:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 462:layer1/l23_api.c **** }
 463:layer1/l23_api.c **** 
 464:layer1/l23_api.c **** /* receive a L1CTL_CCCH_MODE_REQ from L23 */
 465:layer1/l23_api.c **** static void l1ctl_rx_ccch_mode_req(struct msgb *msg)
 466:layer1/l23_api.c **** {
 467:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 468:layer1/l23_api.c **** 	struct l1ctl_ccch_mode_req *ccch_mode_req =
 469:layer1/l23_api.c **** 		(struct l1ctl_ccch_mode_req *) l1h->data;
 470:layer1/l23_api.c **** 	uint8_t ccch_mode = ccch_mode_req->ccch_mode;
 471:layer1/l23_api.c **** 
 472:layer1/l23_api.c **** 	/* pre-set the CCCH mode */
 473:layer1/l23_api.c **** 	l1s.serving_cell.ccch_mode = ccch_mode;
 474:layer1/l23_api.c **** 
 475:layer1/l23_api.c **** 	/* Update task */
 476:layer1/l23_api.c **** 	mframe_disable(MF_TASK_CCCH_COMB);
 477:layer1/l23_api.c **** 	mframe_disable(MF_TASK_CCCH);
 478:layer1/l23_api.c **** 
 479:layer1/l23_api.c **** 	if (ccch_mode == CCCH_MODE_COMBINED)
 480:layer1/l23_api.c **** 		mframe_enable(MF_TASK_CCCH_COMB);
 481:layer1/l23_api.c **** 	else if (ccch_mode == CCCH_MODE_NON_COMBINED)
 482:layer1/l23_api.c **** 		mframe_enable(MF_TASK_CCCH);
 483:layer1/l23_api.c **** 
 484:layer1/l23_api.c **** 	l1ctl_tx_ccch_mode_conf(ccch_mode);
 485:layer1/l23_api.c **** }
 486:layer1/l23_api.c **** 
 487:layer1/l23_api.c **** /* Transmit a L1CTL_TCH_MODE_CONF */
 488:layer1/l23_api.c **** static void l1ctl_tx_tch_mode_conf(uint8_t tch_mode, uint8_t audio_mode)
 489:layer1/l23_api.c **** {
 490:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(L1CTL_TCH_MODE_CONF);
 491:layer1/l23_api.c **** 	struct l1ctl_tch_mode_conf *mode_conf;
 492:layer1/l23_api.c **** 	mode_conf = (struct l1ctl_tch_mode_conf *)
 493:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*mode_conf));
 494:layer1/l23_api.c **** 	mode_conf->tch_mode = tch_mode;
 495:layer1/l23_api.c **** 	mode_conf->audio_mode = audio_mode;
 496:layer1/l23_api.c **** 
 497:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 498:layer1/l23_api.c **** }
 499:layer1/l23_api.c **** 
 500:layer1/l23_api.c **** /* receive a L1CTL_TCH_MODE_REQ from L23 */
 501:layer1/l23_api.c **** static void l1ctl_rx_tch_mode_req(struct msgb *msg)
 502:layer1/l23_api.c **** {
 503:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 504:layer1/l23_api.c **** 	struct l1ctl_tch_mode_req *tch_mode_req =
 505:layer1/l23_api.c **** 		(struct l1ctl_tch_mode_req *) l1h->data;
 506:layer1/l23_api.c **** 	uint8_t tch_mode = tch_mode_req->tch_mode;
 507:layer1/l23_api.c **** 	uint8_t audio_mode = tch_mode_req->audio_mode;
 508:layer1/l23_api.c **** 
 509:layer1/l23_api.c **** 	printd("L1CTL_TCH_MODE_REQ (tch_mode=0x%02x audio_mode=0x%02x)\n",
 510:layer1/l23_api.c **** 		tch_mode, audio_mode);
 511:layer1/l23_api.c **** 	tch_mode = l1a_tch_mode_set(tch_mode);
 512:layer1/l23_api.c **** 	audio_mode = l1a_audio_mode_set(audio_mode);
 513:layer1/l23_api.c **** 
 514:layer1/l23_api.c **** 	audio_set_enabled(tch_mode, audio_mode);
 515:layer1/l23_api.c **** 
 516:layer1/l23_api.c **** 	l1s.tch_sync = 1; /* Needed for audio to work */
 517:layer1/l23_api.c **** 
 518:layer1/l23_api.c **** 	l1ctl_tx_tch_mode_conf(tch_mode, audio_mode);
 519:layer1/l23_api.c **** }
 520:layer1/l23_api.c **** 
 521:layer1/l23_api.c **** /* receive a L1CTL_NEIGH_PM_REQ from L23 */
 522:layer1/l23_api.c **** static void l1ctl_rx_neigh_pm_req(struct msgb *msg)
 523:layer1/l23_api.c **** {
 524:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 525:layer1/l23_api.c **** 	struct l1ctl_neigh_pm_req *pm_req =
 526:layer1/l23_api.c **** 		(struct l1ctl_neigh_pm_req *) l1h->data;
 527:layer1/l23_api.c **** 	int i;
 528:layer1/l23_api.c **** 
 529:layer1/l23_api.c **** 	/* reset list in order to prevent race condition */
 530:layer1/l23_api.c **** 	l1s.neigh_pm.n = 0; /* atomic */
 531:layer1/l23_api.c **** 	l1s.neigh_pm.second = 0;
 532:layer1/l23_api.c **** 	/* now reset pointer and fill list */
 533:layer1/l23_api.c **** 	l1s.neigh_pm.pos = 0;
 534:layer1/l23_api.c **** 	l1s.neigh_pm.running = 0;
 535:layer1/l23_api.c **** 	for (i = 0; i < pm_req->n; i++) {
 536:layer1/l23_api.c **** 		l1s.neigh_pm.band_arfcn[i] = ntohs(pm_req->band_arfcn[i]);
 537:layer1/l23_api.c **** 		l1s.neigh_pm.tn[i] = pm_req->tn[i];
 538:layer1/l23_api.c **** 	}
 539:layer1/l23_api.c **** 	printf("L1CTL_NEIGH_PM_REQ new list with %u entries\n", pm_req->n);
 540:layer1/l23_api.c **** 	l1s.neigh_pm.n = pm_req->n; /* atomic */
 541:layer1/l23_api.c **** 
 542:layer1/l23_api.c **** 	/* on C0 enable PM on frame 51 */
 543:layer1/l23_api.c **** 	if (l1s.dedicated.type == GSM_DCHAN_NONE)
 544:layer1/l23_api.c **** 		mframe_enable(MF_TASK_NEIGH_PM51_C0T0);
 545:layer1/l23_api.c **** }
 546:layer1/l23_api.c **** 
 547:layer1/l23_api.c **** /* receive a L1CTL_TRAFFIC_REQ from L23 */
 548:layer1/l23_api.c **** static void l1ctl_rx_traffic_req(struct msgb *msg)
 549:layer1/l23_api.c **** {
 550:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 551:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 552:layer1/l23_api.c **** 	struct l1ctl_traffic_req *tr = (struct l1ctl_traffic_req *) ul->payload;
 553:layer1/l23_api.c **** 	int num = 0;
 554:layer1/l23_api.c **** 
 555:layer1/l23_api.c **** 	/* printd("L1CTL_TRAFFIC_REQ\n"); */ /* Very verbose, can overwelm serial */
 556:layer1/l23_api.c **** 
 557:layer1/l23_api.c **** 	msg->l2h = tr->data;
 558:layer1/l23_api.c **** 
 559:layer1/l23_api.c **** 	num = l1a_txq_msgb_count(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 560:layer1/l23_api.c **** 	if (num >= 4) {
 561:layer1/l23_api.c **** 		printd("dropping traffic frame\n");
 562:layer1/l23_api.c **** 		msgb_free(msg);
 563:layer1/l23_api.c **** 		return;
 564:layer1/l23_api.c **** 	}
 565:layer1/l23_api.c **** 
 566:layer1/l23_api.c **** 	l1a_txq_msgb_enq(&l1s.tx_queue[L1S_CHAN_TRAFFIC], msg);
 567:layer1/l23_api.c **** }
 568:layer1/l23_api.c **** 
 569:layer1/l23_api.c **** static void l1ctl_sim_req(struct msgb *msg)
 570:layer1/l23_api.c **** {
 571:layer1/l23_api.c **** 	uint16_t len = msg->len - sizeof(struct l1ctl_hdr);
 572:layer1/l23_api.c **** 	uint8_t *data = msg->data + sizeof(struct l1ctl_hdr);
 573:layer1/l23_api.c **** 
 574:layer1/l23_api.c **** #if 1 /* for debugging only */
 575:layer1/l23_api.c **** 	{
 576:layer1/l23_api.c **** 		int i;
 577:layer1/l23_api.c **** 		printf("SIM Request (%u): ", len);
 578:layer1/l23_api.c **** 		for (i = 0; i < len; i++)
 579:layer1/l23_api.c **** 			printf("%02x ", data[i]);
 580:layer1/l23_api.c **** 		puts("\n");
 581:layer1/l23_api.c **** 	}
 582:layer1/l23_api.c **** #endif
 583:layer1/l23_api.c **** 
 584:layer1/l23_api.c ****    sim_apdu(len, data);
 585:layer1/l23_api.c **** }
 586:layer1/l23_api.c **** 
 587:layer1/l23_api.c **** static struct llist_head l23_rx_queue = LLIST_HEAD_INIT(l23_rx_queue);
 588:layer1/l23_api.c **** 
 589:layer1/l23_api.c **** /* callback from SERCOMM when L2 sends a message to L1 */
 590:layer1/l23_api.c **** void l1a_l23_rx(uint8_t dlci, struct msgb *msg)
 591:layer1/l23_api.c **** {
 430              		.loc 3 591 0
 431              		@ args = 0, pretend = 0, frame = 0
 432              		@ frame_needed = 0, uses_anonymous_args = 0
 433              	.LVL37:
 434 0000 10402DE9 		stmfd	sp!, {r4, lr}
 435              	.LCFI6:
 436              	.LBB14:
 592:layer1/l23_api.c **** 	unsigned long flags;
 593:layer1/l23_api.c **** 
 594:layer1/l23_api.c **** 	local_firq_save(flags);
 437              		.loc 3 594 0
 438 0004 00400FE1 		mrs	r4, cpsr		@ local_firq_save
 439 0008 C03084E3 		orr	r3, r4, #0xC0
 440 000c 03F021E1 		msr	cpsr_c, r3
 441              	.LVL38:
 442              	.LBE14:
 595:layer1/l23_api.c **** 	msgb_enqueue(&l23_rx_queue, msg);
 443              		.loc 3 595 0
 444 0010 08009FE5 		ldr	r0, .L38
 445              	.LVL39:
 446 0014 FEFFFFEB 		bl	msgb_enqueue
 447              	.LVL40:
 596:layer1/l23_api.c **** 	local_irq_restore(flags);
 448              		.loc 3 596 0
 449 0018 04F021E1 		msr	cpsr_c, r4		@ local_irq_restore
 450              	
 597:layer1/l23_api.c **** }
 451              		.loc 3 597 0
 452 001c 1080BDE8 		ldmfd	sp!, {r4, pc}
 453              	.L39:
 454              		.align	2
 455              	.L38:
 456 0020 00000000 		.word	l23_rx_queue
 457              	.LFE84:
 459              		.section	.rodata.str1.4
 460 0055 000000   		.align	2
 461              	.LC3:
 462 0058 6C31615F 		.ascii	"l1a_l23_cb: Short message. %u\012\000"
 462      6C32335F 
 462      63623A20 
 462      53686F72 
 462      74206D65 
 463 0077 00       		.align	2
 464              	.LC4:
 465 0078 53686F72 		.ascii	"Short sync msg. %u\012\000"
 465      74207379 
 465      6E63206D 
 465      73672E20 
 465      25750A00 
 466              		.align	2
 467              	.LC5:
 468 008c 4C314354 		.ascii	"L1CTL_FBSB_REQ (arfcn=%u, flags=0x%x)\012\000"
 468      4C5F4642 
 468      53425F52 
 468      45512028 
 468      61726663 
 469 00b3 00       		.align	2
 470              	.LC6:
 471 00b4 53746172 		.ascii	"Starting FCCH Recognition\000"
 471      74696E67 
 471      20464343 
 471      48205265 
 471      636F676E 
 472 00ce 0000     		.align	2
 473              	.LC7:
 474 00d0 4C314354 		.ascii	"L1CTL_DM_EST_REQ (arfcn=%u, chan_nr=0x%02x, tsc=%u)"
 474      4C5F444D 
 474      5F455354 
 474      5F524551 
 474      20286172 
 475 0103 0A00     		.ascii	"\012\000"
 476 0105 000000   		.align	2
 477              	.LC8:
 478 0108 4C314354 		.ascii	"L1CTL_DM_REL_REQ\000"
 478      4C5F444D 
 478      5F52454C 
 478      5F524551 
 478      00
 479 0119 000000   		.align	2
 480              	.LC9:
 481 011c 4C314354 		.ascii	"L1CTL_PARAM_REQ (ta=%d, tx_power=%d)\012\000"
 481      4C5F5041 
 481      52414D5F 
 481      52455120 
 481      2874613D 
 482 0142 0000     		.align	2
 483              	.LC10:
 484 0144 4C314354 		.ascii	"L1CTL_DM_FREQ_REQ (arfcn=%u, tsc=%u)\012\000"
 484      4C5F444D 
 484      5F465245 
 484      515F5245 
 484      51202861 
 485 016a 0000     		.align	2
 486              	.LC11:
 487 016c 4C314354 		.ascii	"L1CTL_CRYPTO_REQ (algo=A5/%u, len=%u)\012\000"
 487      4C5F4352 
 487      5950544F 
 487      5F524551 
 487      2028616C 
 488 0193 00       		.align	2
 489              	.LC12:
 490 0194 4C314354 		.ascii	"L1CTL_CRYPTO_REQ -> Invalid key\000"
 490      4C5F4352 
 490      5950544F 
 490      5F524551 
 490      202D3E20 
 491              		.align	2
 492              	.LC13:
 493 01b4 4C314354 		.ascii	"L1CTL_RACH_REQ (ra=0x%02x, offset=%d combined=%d)\012"
 493      4C5F5241 
 493      43485F52 
 493      45512028 
 493      72613D30 
 494 01e6 00       		.ascii	"\000"
 495 01e7 00       		.align	2
 496              	.LC14:
 497 01e8 4C314354 		.ascii	"L1CTL_DATA_REQ (link_id=0x%02x)\012\000"
 497      4C5F4441 
 497      54415F52 
 497      45512028 
 497      6C696E6B 
 498 0209 000000   		.align	2
 499              	.LC15:
 500 020c 75706461 		.ascii	"updating measurement report\000"
 500      74696E67 
 500      206D6561 
 500      73757265 
 500      6D656E74 
 501              		.align	2
 502              	.LC16:
 503 0228 756C3D25 		.ascii	"ul=%p, ul->payload=%p, data_ind=%p, data_ind->data="
 503      702C2075 
 503      6C2D3E70 
 503      61796C6F 
 503      61643D25 
 504 025b 2570206C 		.ascii	"%p l3h=%p\012\000"
 504      33683D25 
 504      700A00
 505 0266 0000     		.align	2
 506              	.LC17:
 507 0268 4C314354 		.ascii	"L1CTL_PM_REQ start=%u end=%u\012\000"
 507      4C5F504D 
 507      5F524551 
 507      20737461 
 507      72743D25 
 508 0286 0000     		.align	2
 509              	.LC18:
 510 0288 4C314354 		.ascii	"L1CTL_RESET_REQ: FULL!\000"
 510      4C5F5245 
 510      5345545F 
 510      5245513A 
 510      2046554C 
 511 029f 00       		.align	2
 512              	.LC19:
 513 02a0 4C314354 		.ascii	"L1CTL_RESET_REQ: SCHED!\000"
 513      4C5F5245 
 513      5345545F 
 513      5245513A 
 513      20534348 
 514              		.align	2
 515              	.LC20:
 516 02b8 756E6B6E 		.ascii	"unknown L1CTL_RESET_REQ type\000"
 516      6F776E20 
 516      4C314354 
 516      4C5F5245 
 516      5345545F 
 517 02d5 000000   		.align	2
 518              	.LC21:
 519 02d8 4C314354 		.ascii	"L1CTL_TCH_MODE_REQ (tch_mode=0x%02x audio_mode=0x%0"
 519      4C5F5443 
 519      485F4D4F 
 519      44455F52 
 519      45512028 
 520 030b 3278290A 		.ascii	"2x)\012\000"
 520      00
 521              		.align	2
 522              	.LC22:
 523 0310 4C314354 		.ascii	"L1CTL_NEIGH_PM_REQ new list with %u entries\012\000"
 523      4C5F4E45 
 523      4947485F 
 523      504D5F52 
 523      4551206E 
 524 033d 000000   		.align	2
 525              	.LC23:
 526 0340 64726F70 		.ascii	"dropping traffic frame\000"
 526      70696E67 
 526      20747261 
 526      66666963 
 526      20667261 
 527 0357 00       		.align	2
 528              	.LC24:
 529 0358 53494D20 		.ascii	"SIM Request (%u): \000"
 529      52657175 
 529      65737420 
 529      28257529 
 529      3A2000
 530 036b 00       		.align	2
 531              	.LC25:
 532 036c 25303278 		.ascii	"%02x \000"
 532      2000
 533 0372 0000     		.align	2
 534              	.LC26:
 535 0374 0A00     		.ascii	"\012\000"
 536 0376 0000     		.section	.text.l1a_l23_handler,"ax",%progbits
 537              		.align	2
 538              		.global	l1a_l23_handler
 540              	l1a_l23_handler:
 541              	.LFB85:
 598:layer1/l23_api.c **** 
 599:layer1/l23_api.c **** void l1a_l23_handler(void)
 600:layer1/l23_api.c **** {
 542              		.loc 3 600 0
 543              		@ args = 0, pretend = 0, frame = 0
 544              		@ frame_needed = 0, uses_anonymous_args = 0
 545              	.LVL41:
 546 0000 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 547              	.LCFI7:
 548 0004 08D04DE2 		sub	sp, sp, #8
 549              	.LCFI8:
 550              	.LVL42:
 551              	.LBB15:
 601:layer1/l23_api.c **** 	struct msgb *msg;
 602:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h;
 603:layer1/l23_api.c **** 	unsigned long flags;
 604:layer1/l23_api.c **** 
 605:layer1/l23_api.c **** 	local_firq_save(flags);
 552              		.loc 3 605 0
 553 0008 00400FE1 		mrs	r4, cpsr		@ local_firq_save
 554 000c C03084E3 		orr	r3, r4, #0xC0
 555 0010 03F021E1 		msr	cpsr_c, r3
 556              	.LVL43:
 557              	.LBE15:
 606:layer1/l23_api.c **** 	msg = msgb_dequeue(&l23_rx_queue);
 558              		.loc 3 606 0
 559 0014 94089FE5 		ldr	r0, .L136
 560 0018 FEFFFFEB 		bl	msgb_dequeue
 561              	.LVL44:
 562 001c 0080A0E1 		mov	r8, r0
 563              	.LVL45:
 607:layer1/l23_api.c **** 	local_irq_restore(flags);
 564              		.loc 3 607 0
 565 0020 04F021E1 		msr	cpsr_c, r4		@ local_irq_restore
 566              	
 608:layer1/l23_api.c **** 	if (!msg)
 567              		.loc 3 608 0
 568 0024 000050E3 		cmp	r0, #0
 569 0028 2802000A 		beq	.L128
 570              	.LVL46:
 609:layer1/l23_api.c **** 		return;
 610:layer1/l23_api.c **** 
 611:layer1/l23_api.c **** 	l1h = (struct l1ctl_hdr *) msg->data;
 612:layer1/l23_api.c **** 
 613:layer1/l23_api.c **** #if 0
 614:layer1/l23_api.c **** 	{
 615:layer1/l23_api.c **** 		int i;
 616:layer1/l23_api.c **** 		printf("l1a_l23_rx_cb (%u): ", msg->len);
 617:layer1/l23_api.c **** 		for (i = 0; i < msg->len; i++)
 618:layer1/l23_api.c **** 			printf("%02x ", msg->data[i]);
 619:layer1/l23_api.c **** 		puts("\n");
 620:layer1/l23_api.c **** 	}
 621:layer1/l23_api.c **** #endif
 622:layer1/l23_api.c **** 
 623:layer1/l23_api.c **** 	msg->l1h = msg->data;
 624:layer1/l23_api.c **** 
 625:layer1/l23_api.c **** 	if (sizeof(*l1h) > msg->len) {
 571              		.loc 3 625 0
 572 002c B613D0E1 		ldrh	r1, [r0, #54]
 573              		.loc 3 611 0
 574 0030 403090E5 		ldr	r3, [r0, #64]
 575              	.LVL47:
 576              		.loc 3 625 0
 577 0034 030051E3 		cmp	r1, #3
 578              		.loc 3 623 0
 579 0038 103080E5 		str	r3, [r0, #16]
 626:layer1/l23_api.c **** 		printf("l1a_l23_cb: Short message. %u\n", msg->len);
 580              		.loc 3 626 0
 581 003c 70089F95 		ldrls	r0, .L136+4
 582              	.LVL48:
 583              		.loc 3 625 0
 584 0040 3500009A 		bls	.L132
 627:layer1/l23_api.c **** 		goto exit_msgbfree;
 628:layer1/l23_api.c **** 	}
 629:layer1/l23_api.c **** 
 630:layer1/l23_api.c **** 	switch (l1h->msg_type) {
 585              		.loc 3 630 0
 586 0044 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 587              	.LVL49:
 588 0048 013043E2 		sub	r3, r3, #1
 589 004c 1B0053E3 		cmp	r3, #27
 590 0050 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 591 0054 240200EA 		b	.L45
 592              		.p2align 2
 593              	.L61:
 594 0058 C8000000 		.word	.L46
 595 005c 98080000 		.word	.L45
 596 0060 98080000 		.word	.L45
 597 0064 C8040000 		.word	.L47
 598 0068 2C010000 		.word	.L48
 599 006c 1C050000 		.word	.L49
 600 0070 98080000 		.word	.L45
 601 0074 A8050000 		.word	.L50
 602 0078 98080000 		.word	.L45
 603 007c 98080000 		.word	.L45
 604 0080 98080000 		.word	.L45
 605 0084 98080000 		.word	.L45
 606 0088 3C060000 		.word	.L51
 607 008c 98080000 		.word	.L45
 608 0090 98080000 		.word	.L45
 609 0094 AC060000 		.word	.L52
 610 0098 98080000 		.word	.L45
 611 009c 28030000 		.word	.L53
 612 00a0 8C030000 		.word	.L54
 613 00a4 C0030000 		.word	.L55
 614 00a8 88040000 		.word	.L56
 615 00ac 44080000 		.word	.L57
 616 00b0 98080000 		.word	.L45
 617 00b4 04070000 		.word	.L58
 618 00b8 98080000 		.word	.L45
 619 00bc 78070000 		.word	.L59
 620 00c0 98080000 		.word	.L45
 621 00c4 10080000 		.word	.L60
 622              	.L46:
 623              	.LBB16:
 624              	.LBB17:
 625              		.loc 3 201 0
 626 00c8 403098E5 		ldr	r3, [r8, #64]
 627              		.loc 3 203 0
 628 00cc 0C0051E3 		cmp	r1, #12
 629              		.loc 3 201 0
 630 00d0 044083E2 		add	r4, r3, #4
 631              	.LVL50:
 632              		.loc 3 203 0
 633 00d4 3700008A 		bhi	.L62
 634              		.loc 3 204 0
 635 00d8 D8079FE5 		ldr	r0, .L136+8
 636              	.LVL51:
 637              	.L132:
 638 00dc FEFFFFEB 		bl	printf
 639              	.LVL52:
 640 00e0 240200EA 		b	.L45
 641              	.LVL53:
 642              	.L62:
 643              		.loc 3 208 0
 644 00e4 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 645 00e8 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 646 00ec 000483E1 		orr	r0, r3, r0, asl #8
 647 00f0 FEFFFFEB 		bl	__fswab16
 648 00f4 0920D4E5 		ldrb	r2, [r4, #9]	@ zero_extendqisi2
 649 00f8 0010A0E1 		mov	r1, r0
 650 00fc B8079FE5 		ldr	r0, .L136+12
 651 0100 FEFFFFEB 		bl	printf
 652              		.loc 3 212 0
 653 0104 FEFFFFEB 		bl	l1s_reset
 654              		.loc 3 215 0
 655 0108 0B20D4E5 		ldrb	r2, [r4, #11]	@ zero_extendqisi2
 656 010c AC379FE5 		ldr	r3, .L136+16
 657              		.loc 3 217 0
 658 0110 AC079FE5 		ldr	r0, .L136+20
 659              		.loc 3 215 0
 660 0114 1B20C3E5 		strb	r2, [r3, #27]
 661              		.loc 3 217 0
 662 0118 FEFFFFEB 		bl	puts
 663              		.loc 3 218 0
 664 011c 0410A0E1 		mov	r1, r4
 665 0120 0100A0E3 		mov	r0, #1
 666 0124 FEFFFFEB 		bl	l1s_fbsb_req
 667 0128 240200EA 		b	.L45
 668              	.LVL54:
 669              	.L48:
 670              	.LBE17:
 671              	.LBE16:
 672              	.LBB18:
 673              	.LBB19:
 674              		.loc 3 225 0
 675 012c 404098E5 		ldr	r4, [r8, #64]
 676              	.LVL55:
 677 0130 04A084E2 		add	sl, r4, #4
 678              	.LVL56:
 679              		.loc 3 226 0
 680 0134 04508AE2 		add	r5, sl, #4
 681              	.LVL57:
 682              		.loc 3 228 0
 683 0138 0230D5E5 		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 684 013c 0300D5E5 		ldrb	r0, [r5, #3]	@ zero_extendqisi2
 685 0140 000483E1 		orr	r0, r3, r0, asl #8
 686 0144 FEFFFFEB 		bl	__fswab16
 687 0148 0420D4E5 		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 688 014c 0010A0E1 		mov	r1, r0
 689 0150 0430DAE5 		ldrb	r3, [sl, #4]	@ zero_extendqisi2
 690 0154 6C079FE5 		ldr	r0, .L136+24
 691 0158 FEFFFFEB 		bl	printf
 692              		.loc 3 232 0
 693 015c 1400A0E3 		mov	r0, #20
 694 0160 FEFFFFEB 		bl	mframe_disable
 695              	.LBB20:
 696              	.LBB21:
 697              		.loc 3 128 0
 698 0164 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 699 0168 A321A0E1 		mov	r2, r3, lsr #3
 700              		.loc 3 130 0
 701 016c 010052E3 		cmp	r2, #1
 702 0170 0430A003 		moveq	r3, #4
 703 0174 6800000A 		beq	.L66
 704              		.loc 3 132 0
 705 0178 1E3002E2 		and	r3, r2, #30
 706 017c 020053E3 		cmp	r3, #2
 707 0180 01308302 		addeq	r3, r3, #1
 708 0184 6800000A 		beq	.L66
 709              		.loc 3 134 0
 710 0188 1C3002E2 		and	r3, r2, #28
 711 018c 040053E3 		cmp	r3, #4
 712 0190 0130A003 		moveq	r3, #1
 713 0194 6800000A 		beq	.L66
 714              		.loc 3 136 0
 715 0198 183002E2 		and	r3, r2, #24
 716 019c 080053E3 		cmp	r3, #8
 717 01a0 0530A013 		movne	r3, #5
 718 01a4 0230A003 		moveq	r3, #2
 719              	.L66:
 720              	.LBE21:
 721              	.LBE20:
 722              		.loc 3 235 0
 723 01a8 10679FE5 		ldr	r6, .L136+16
 724 01ac 083B86E5 		str	r3, [r6, #2824]
 725              		.loc 3 236 0
 726 01b0 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 727 01b4 0D3BC6E5 		strb	r3, [r6, #2829]
 728              		.loc 3 237 0
 729 01b8 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 730 01bc 073003E2 		and	r3, r3, #7
 731 01c0 0E3BC6E5 		strb	r3, [r6, #2830]
 732              		.loc 3 238 0
 733 01c4 0130D5E5 		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 734 01c8 0F3BC6E5 		strb	r3, [r6, #2831]
 735              		.loc 3 240 0
 736 01cc 0130D5E5 		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 737 01d0 000053E3 		cmp	r3, #0
 738 01d4 0230D5E5 		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 739 01d8 8900000A 		beq	.L73
 740              	.LBB22:
 741              		.loc 3 242 0
 742 01dc 103BC6E5 		strb	r3, [r6, #2832]
 743              		.loc 3 243 0
 744 01e0 0330D5E5 		ldrb	r3, [r5, #3]	@ zero_extendqisi2
 745 01e4 113BC6E5 		strb	r3, [r6, #2833]
 746              		.loc 3 244 0
 747 01e8 DC969FE5 		ldr	r9, .L136+28
 748 01ec 0430D5E5 		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 749 01f0 0070A0E3 		mov	r7, #0
 750              	.LVL58:
 751 01f4 044085E2 		add	r4, r5, #4
 752 01f8 123BC6E5 		strb	r3, [r6, #2834]
 753 01fc 840000EA 		b	.L75
 754              	.L76:
 755              		.loc 3 246 0
 756 0200 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 757 0204 0300D4E5 		ldrb	r0, [r4, #3]	@ zero_extendqisi2
 758 0208 000483E1 		orr	r0, r3, r0, asl #8
 759 020c FEFFFFEB 		bl	__fswab16
 760 0210 B200C9E0 		strh	r0, [r9], #2	@ movhi
 761              		.loc 3 245 0
 762 0214 024084E2 		add	r4, r4, #2
 763              	.L75:
 764 0218 0430D5E5 		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 765 021c 030057E1 		cmp	r7, r3
 766 0220 017087E2 		add	r7, r7, #1
 767 0224 7E0000BA 		blt	.L76
 768 0228 8E0000EA 		b	.L77
 769              	.LVL59:
 770              	.L73:
 771              	.LBE22:
 772              		.loc 3 248 0
 773 022c 0300D5E5 		ldrb	r0, [r5, #3]	@ zero_extendqisi2
 774 0230 000483E1 		orr	r0, r3, r0, asl #8
 775 0234 FEFFFFEB 		bl	__fswab16
 776 0238 B13EA0E3 		mov	r3, #2832
 777 023c B30086E1 		strh	r0, [r6, r3]	@ movhi
 778              	.LVL60:
 779              	.L77:
 780              	.LBB23:
 781              	.LBB24:
 782              		.loc 3 144 0
 783 0240 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 784 0244 A331A0E1 		mov	r3, r3, lsr #3
 785 0248 010053E3 		cmp	r3, #1
 786 024c 9500000A 		beq	.L78
 787 0250 1E3003E2 		and	r3, r3, #30
 788 0254 020053E3 		cmp	r3, #2
 789 0258 9F00001A 		bne	.L80
 790              	.L78:
 791              	.LBE24:
 792              	.LBE23:
 793              		.loc 3 254 0
 794 025c 8600D5E5 		ldrb	r0, [r5, #134]	@ zero_extendqisi2
 795 0260 FEFFFFEB 		bl	l1a_tch_mode_set
 796              		.loc 3 255 0
 797 0264 8700D5E5 		ldrb	r0, [r5, #135]	@ zero_extendqisi2
 798 0268 FEFFFFEB 		bl	l1a_audio_mode_set
 799              		.loc 3 258 0
 800 026c 4C369FE5 		ldr	r3, .L136+16
 801 0270 0120A0E3 		mov	r2, #1
 802 0274 4B2AC3E5 		strb	r2, [r3, #2635]
 803              		.loc 3 261 0
 804 0278 8710D5E5 		ldrb	r1, [r5, #135]	@ zero_extendqisi2
 805 027c 8600D5E5 		ldrb	r0, [r5, #134]	@ zero_extendqisi2
 806 0280 FEFFFFEB 		bl	audio_set_enabled
 807              	.L80:
 808 0284 0040DAE5 		ldrb	r4, [sl, #0]	@ zero_extendqisi2
 809              	.LBB25:
 810              	.LBB26:
 811              		.loc 3 77 0
 812 0288 A421A0E1 		mov	r2, r4, lsr #3
 813              		.loc 3 84 0
 814 028c 010052E3 		cmp	r2, #1
 815 0290 A700001A 		bne	.L81
 816              		.loc 3 86 0
 817 0294 010014E3 		tst	r4, #1
 818              		.loc 3 116 0
 819 0298 1130A013 		movne	r3, #17
 820              	.LVL61:
 821              		.loc 3 86 0
 822 029c C300001A 		bne	.L94
 823 02a0 C00000EA 		b	.L129
 824              	.LVL62:
 825              	.L81:
 826              		.loc 3 88 0
 827 02a4 1E3002E2 		and	r3, r2, #30
 828 02a8 020053E3 		cmp	r3, #2
 829              		.loc 3 90 0
 830 02ac 01300202 		andeq	r3, r2, #1
 831 02b0 12308302 		addeq	r3, r3, #18
 832              	.LVL63:
 833              		.loc 3 88 0
 834 02b4 B700000A 		beq	.L87
 835              		.loc 3 91 0
 836 02b8 1C3002E2 		and	r3, r2, #28
 837              	.LVL64:
 838 02bc 040053E3 		cmp	r3, #4
 839              		.loc 3 93 0
 840 02c0 03300202 		andeq	r3, r2, #3
 841 02c4 04308302 		addeq	r3, r3, #4
 842              	.LVL65:
 843              		.loc 3 91 0
 844 02c8 BE00000A 		beq	.L90
 845              		.loc 3 95 0
 846 02cc 183002E2 		and	r3, r2, #24
 847              	.LVL66:
 848 02d0 080053E3 		cmp	r3, #8
 849              		.loc 3 97 0
 850 02d4 07300202 		andeq	r3, r2, #7
 851 02d8 08308302 		addeq	r3, r3, #8
 852              	.LVL67:
 853              		.loc 3 95 0
 854 02dc BE00000A 		beq	.L90
 855              		.loc 3 97 0
 856 02e0 0030A0E3 		mov	r3, #0
 857              	.L87:
 858              	.LVL68:
 859              		.loc 3 110 0
 860 02e4 020054E3 		cmp	r4, #2
 861 02e8 C300000A 		beq	.L94
 862 02ec 030054E3 		cmp	r4, #3
 863 02f0 C100000A 		beq	.L95
 864 02f4 010054E3 		cmp	r4, #1
 865 02f8 0020A013 		movne	r2, #0
 866              	.LVL69:
 867 02fc C400001A 		bne	.L96
 868              	.L90:
 869 0300 0226A0E3 		mov	r2, #2097152
 870 0304 C40000EA 		b	.L96
 871              	.LVL70:
 872              	.L129:
 873              		.loc 3 113 0
 874 0308 1030A0E3 		mov	r3, #16
 875              	.LVL71:
 876              	.L95:
 877 030c 0125A0E3 		mov	r2, #4194304
 878              	.LVL72:
 879 0310 C40000EA 		b	.L96
 880              	.LVL73:
 881              	.L94:
 882              		.loc 3 116 0
 883 0314 0225A0E3 		mov	r2, #8388608
 884              	.LVL74:
 885              	.L96:
 886              	.LBE26:
 887              	.LBE25:
 888              		.loc 3 265 0
 889 0318 0100A0E3 		mov	r0, #1
 890 031c 100382E1 		orr	r0, r2, r0, asl r3
 891 0320 FEFFFFEB 		bl	l1a_mftask_set
 892              	.LVL75:
 893 0324 240200EA 		b	.L45
 894              	.LVL76:
 895              	.L53:
 896              	.LBE19:
 897              	.LBE18:
 898              	.LBB27:
 899              	.LBB28:
 900              		.loc 3 323 0
 901 0328 90559FE5 		ldr	r5, .L136+16
 902              		.loc 3 321 0
 903 032c 9C059FE5 		ldr	r0, .L136+32
 904              		.loc 3 323 0
 905 0330 0040A0E3 		mov	r4, #0
 906              	.LVL77:
 907              		.loc 3 321 0
 908 0334 FEFFFFEB 		bl	puts
 909              		.loc 3 322 0
 910 0338 0000A0E3 		mov	r0, #0
 911 033c FEFFFFEB 		bl	l1a_mftask_set
 912              		.loc 3 324 0
 913 0340 A50E85E2 		add	r0, r5, #2640
 914              		.loc 3 323 0
 915 0344 084B85E5 		str	r4, [r5, #2824]
 916              		.loc 3 324 0
 917 0348 FEFFFFEB 		bl	l1a_txq_msgb_flush
 918              		.loc 3 325 0
 919 034c 80059FE5 		ldr	r0, .L136+36
 920 0350 FEFFFFEB 		bl	l1a_txq_msgb_flush
 921              		.loc 3 326 0
 922 0354 A60E85E2 		add	r0, r5, #2656
 923 0358 FEFFFFEB 		bl	l1a_txq_msgb_flush
 924              		.loc 3 327 0
 925 035c 0400A0E1 		mov	r0, r4
 926 0360 FEFFFFEB 		bl	l1a_meas_msgb_set
 927              		.loc 3 328 0
 928 0364 0410A0E1 		mov	r1, r4
 929 0368 0400A0E1 		mov	r0, r4
 930 036c FEFFFFEB 		bl	dsp_load_ciph_param
 931              		.loc 3 329 0
 932 0370 0400A0E1 		mov	r0, r4
 933 0374 FEFFFFEB 		bl	l1a_tch_mode_set
 934              		.loc 3 330 0
 935 0378 0400A0E1 		mov	r0, r4
 936 037c 0410A0E1 		mov	r1, r4
 937 0380 FEFFFFEB 		bl	audio_set_enabled
 938              		.loc 3 331 0
 939 0384 1C4CC5E5 		strb	r4, [r5, #3100]
 940 0388 240200EA 		b	.L45
 941              	.LVL78:
 942              	.L54:
 943              	.LBE28:
 944              	.LBE27:
 945              	.LBB29:
 946              	.LBB30:
 947              		.loc 3 339 0
 948 038c 404098E5 		ldr	r4, [r8, #64]
 949              	.LVL79:
 950 0390 044084E2 		add	r4, r4, #4
 951 0394 045084E2 		add	r5, r4, #4
 952              	.LVL80:
 953              		.loc 3 341 0
 954 0398 0120D5E5 		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 955 039c 34059FE5 		ldr	r0, .L136+40
 956 03a0 D410D4E1 		ldrsb	r1, [r4, #4]
 957 03a4 FEFFFFEB 		bl	printf
 958              		.loc 3 344 0
 959 03a8 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 960 03ac 0C259FE5 		ldr	r2, .L136+16
 961 03b0 483AC2E5 		strb	r3, [r2, #2632]
 962              		.loc 3 345 0
 963 03b4 0130D5E5 		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 964 03b8 493AC2E5 		strb	r3, [r2, #2633]
 965 03bc 240200EA 		b	.L45
 966              	.LVL81:
 967              	.L55:
 968              	.LBE30:
 969              	.LBE29:
 970              	.LBB31:
 971              	.LBB32:
 972              		.loc 3 274 0
 973 03c0 403098E5 		ldr	r3, [r8, #64]
 974 03c4 084083E2 		add	r4, r3, #8
 975              	.LVL82:
 976              		.loc 3 276 0
 977 03c8 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 978 03cc 0500D4E5 		ldrb	r0, [r4, #5]	@ zero_extendqisi2
 979 03d0 000483E1 		orr	r0, r3, r0, asl #8
 980 03d4 FEFFFFEB 		bl	__fswab16
 981 03d8 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 982 03dc 0010A0E1 		mov	r1, r0
 983 03e0 F4049FE5 		ldr	r0, .L136+44
 984 03e4 FEFFFFEB 		bl	printf
 985              		.loc 3 280 0
 986 03e8 D0649FE5 		ldr	r6, .L136+16
 987 03ec 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 988 03f0 943BC6E5 		strb	r3, [r6, #2964]
 989              		.loc 3 281 0
 990 03f4 0330D4E5 		ldrb	r3, [r4, #3]	@ zero_extendqisi2
 991 03f8 963BC6E5 		strb	r3, [r6, #2966]
 992              		.loc 3 283 0
 993 03fc 0330D4E5 		ldrb	r3, [r4, #3]	@ zero_extendqisi2
 994 0400 000053E3 		cmp	r3, #0
 995 0404 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 996 0408 1501000A 		beq	.L97
 997              	.LBB33:
 998              		.loc 3 285 0
 999 040c 983BC6E5 		strb	r3, [r6, #2968]
 1000              		.loc 3 286 0
 1001 0410 0530D4E5 		ldrb	r3, [r4, #5]	@ zero_extendqisi2
 1002 0414 993BC6E5 		strb	r3, [r6, #2969]
 1003              		.loc 3 287 0
 1004 0418 C0A49FE5 		ldr	sl, .L136+48
 1005 041c 0630D4E5 		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 1006 0420 0070A0E3 		mov	r7, #0
 1007              	.LVL83:
 1008 0424 0450A0E1 		mov	r5, r4
 1009 0428 9A3BC6E5 		strb	r3, [r6, #2970]
 1010 042c 100100EA 		b	.L99
 1011              	.L100:
 1012              		.loc 3 289 0
 1013 0430 0830D5E5 		ldrb	r3, [r5, #8]	@ zero_extendqisi2
 1014 0434 0900D5E5 		ldrb	r0, [r5, #9]	@ zero_extendqisi2
 1015 0438 000483E1 		orr	r0, r3, r0, asl #8
 1016 043c FEFFFFEB 		bl	__fswab16
 1017 0440 B200CAE0 		strh	r0, [sl], #2	@ movhi
 1018              		.loc 3 288 0
 1019 0444 025085E2 		add	r5, r5, #2
 1020              	.LVL84:
 1021              	.L99:
 1022 0448 0630D4E5 		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 1023 044c 030057E1 		cmp	r7, r3
 1024 0450 017087E2 		add	r7, r7, #1
 1025 0454 0A0100BA 		blt	.L100
 1026              	.LVL85:
 1027 0458 1A0100EA 		b	.L101
 1028              	.LVL86:
 1029              	.L97:
 1030              	.LBE33:
 1031              		.loc 3 291 0
 1032 045c 0500D4E5 		ldrb	r0, [r4, #5]	@ zero_extendqisi2
 1033 0460 000483E1 		orr	r0, r3, r0, asl #8
 1034 0464 FEFFFFEB 		bl	__fswab16
 1035 0468 74349FE5 		ldr	r3, .L136+52
 1036 046c B30086E1 		strh	r0, [r6, r3]	@ movhi
 1037              	.LVL87:
 1038              	.L101:
 1039              		.loc 3 294 0
 1040 0470 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1041 0474 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 1042 0478 030480E1 		orr	r0, r0, r3, asl #8
 1043 047c FEFFFFEB 		bl	__fswab16
 1044 0480 FEFFFFEB 		bl	l1a_freq_req
 1045 0484 240200EA 		b	.L45
 1046              	.LVL88:
 1047              	.L56:
 1048              	.LBE32:
 1049              	.LBE31:
 1050              	.LBB34:
 1051              	.LBB35:
 1052              		.loc 3 302 0
 1053 0488 406098E5 		ldr	r6, [r8, #64]
 1054              		.loc 3 303 0
 1055 048c 094041E2 		sub	r4, r1, #9
 1056              	.LVL89:
 1057 0490 FF4004E2 		and	r4, r4, #255
 1058              	.LVL90:
 1059              		.loc 3 302 0
 1060 0494 045086E2 		add	r5, r6, #4
 1061              		.loc 3 305 0
 1062 0498 48049FE5 		ldr	r0, .L136+56
 1063 049c 0410D5E5 		ldrb	r1, [r5, #4]	@ zero_extendqisi2
 1064 04a0 0420A0E1 		mov	r2, r4
 1065 04a4 FEFFFFEB 		bl	printf
 1066              		.loc 3 307 0
 1067 04a8 0400D5E5 		ldrb	r0, [r5, #4]	@ zero_extendqisi2
 1068 04ac 000050E3 		cmp	r0, #0
 1069 04b0 08005413 		cmpne	r4, #8
 1070              		.loc 3 308 0
 1071 04b4 30049F15 		ldrne	r0, .L136+60
 1072              		.loc 3 307 0
 1073 04b8 A701001A 		bne	.L133
 1074              		.loc 3 312 0
 1075 04bc 091086E2 		add	r1, r6, #9
 1076 04c0 FEFFFFEB 		bl	dsp_load_ciph_param
 1077 04c4 240200EA 		b	.L45
 1078              	.LVL91:
 1079              	.L47:
 1080              	.LBE35:
 1081              	.LBE34:
 1082              	.LBB36:
 1083              	.LBB37:
 1084              		.loc 3 353 0
 1085 04c8 406098E5 		ldr	r6, [r8, #64]
 1086 04cc 046086E2 		add	r6, r6, #4
 1087 04d0 044086E2 		add	r4, r6, #4
 1088              	.LVL92:
 1089              		.loc 3 355 0
 1090 04d4 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1091 04d8 0300D4E5 		ldrb	r0, [r4, #3]	@ zero_extendqisi2
 1092 04dc 000483E1 		orr	r0, r3, r0, asl #8
 1093 04e0 FEFFFFEB 		bl	__fswab16
 1094 04e4 0450D6E5 		ldrb	r5, [r6, #4]	@ zero_extendqisi2
 1095 04e8 0020A0E1 		mov	r2, r0
 1096 04ec 0510A0E1 		mov	r1, r5
 1097 04f0 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1098 04f4 F4039FE5 		ldr	r0, .L136+64
 1099 04f8 FEFFFFEB 		bl	printf
 1100              		.loc 3 358 0
 1101 04fc 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1102 0500 0300D4E5 		ldrb	r0, [r4, #3]	@ zero_extendqisi2
 1103 0504 000483E1 		orr	r0, r3, r0, asl #8
 1104 0508 FEFFFFEB 		bl	__fswab16
 1105 050c 0110D4E5 		ldrb	r1, [r4, #1]	@ zero_extendqisi2
 1106 0510 0420D6E5 		ldrb	r2, [r6, #4]	@ zero_extendqisi2
 1107 0514 FEFFFFEB 		bl	l1a_rach_req
 1108 0518 240200EA 		b	.L45
 1109              	.LVL93:
 1110              	.L49:
 1111              	.LBE37:
 1112              	.LBE36:
 1113              	.LBB38:
 1114              	.LBB39:
 1115              		.loc 3 366 0
 1116 051c 406098E5 		ldr	r6, [r8, #64]
 1117 0520 044086E2 		add	r4, r6, #4
 1118              	.LVL94:
 1119              		.loc 3 367 0
 1120 0524 045084E2 		add	r5, r4, #4
 1121              	.LVL95:
 1122              		.loc 3 370 0
 1123 0528 C4039FE5 		ldr	r0, .L136+68
 1124 052c 0110D4E5 		ldrb	r1, [r4, #1]	@ zero_extendqisi2
 1125 0530 FEFFFFEB 		bl	printf
 1126              		.loc 3 372 0
 1127 0534 185088E5 		str	r5, [r8, #24]
 1128              		.loc 3 373 0
 1129 0538 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1130 053c 400013E3 		tst	r3, #64
 1131 0540 B0639F05 		ldreq	r6, .L136+72
 1132              	.LVL96:
 1133 0544 5E01000A 		beq	.L106
 1134              	.LBB40:
 1135              		.loc 3 375 0
 1136 0548 0930D4E5 		ldrb	r3, [r4, #9]	@ zero_extendqisi2
 1137 054c 060053E3 		cmp	r3, #6
 1138              	.LVL97:
 1139              		.loc 3 374 0
 1140 0550 0D3086E2 		add	r3, r6, #13
 1141              	.LVL98:
 1142              		.loc 3 375 0
 1143 0554 5D01001A 		bne	.L107
 1144 0558 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1145              	.LVL99:
 1146 055c 150053E3 		cmp	r3, #21
 1147 0560 5D01001A 		bne	.L107
 1148              		.loc 3 377 0
 1149 0564 90039FE5 		ldr	r0, .L136+76
 1150 0568 FEFFFFEB 		bl	puts
 1151              		.loc 3 378 0
 1152 056c 0800A0E1 		mov	r0, r8
 1153              	.LBE40:
 1154              	.LBE39:
 1155              	.LBE38:
 631:layer1/l23_api.c **** 	case L1CTL_FBSB_REQ:
 632:layer1/l23_api.c **** 		l1ctl_rx_fbsb_req(msg);
 633:layer1/l23_api.c **** 		break;
 634:layer1/l23_api.c **** 	case L1CTL_DM_EST_REQ:
 635:layer1/l23_api.c **** 		l1ctl_rx_dm_est_req(msg);
 636:layer1/l23_api.c **** 		break;
 637:layer1/l23_api.c **** 	case L1CTL_DM_REL_REQ:
 638:layer1/l23_api.c **** 		l1ctl_rx_dm_rel_req(msg);
 639:layer1/l23_api.c **** 		break;
 640:layer1/l23_api.c **** 	case L1CTL_PARAM_REQ:
 641:layer1/l23_api.c **** 		l1ctl_rx_param_req(msg);
 642:layer1/l23_api.c **** 		break;
 643:layer1/l23_api.c **** 	case L1CTL_DM_FREQ_REQ:
 644:layer1/l23_api.c **** 		l1ctl_rx_dm_freq_req(msg);
 645:layer1/l23_api.c **** 		break;
 646:layer1/l23_api.c **** 	case L1CTL_CRYPTO_REQ:
 647:layer1/l23_api.c **** 		l1ctl_rx_crypto_req(msg);
 648:layer1/l23_api.c **** 		break;
 649:layer1/l23_api.c **** 	case L1CTL_RACH_REQ:
 650:layer1/l23_api.c **** 		l1ctl_rx_rach_req(msg);
 651:layer1/l23_api.c **** 		break;
 652:layer1/l23_api.c **** 	case L1CTL_DATA_REQ:
 653:layer1/l23_api.c **** 		l1ctl_rx_data_req(msg);
 654:layer1/l23_api.c **** 		/* we have to keep the msgb, not free it! */
 655:layer1/l23_api.c **** 		goto exit_nofree;
 656:layer1/l23_api.c **** 	case L1CTL_PM_REQ:
 657:layer1/l23_api.c **** 		l1ctl_rx_pm_req(msg);
 658:layer1/l23_api.c **** 		break;
 659:layer1/l23_api.c **** 	case L1CTL_RESET_REQ:
 660:layer1/l23_api.c **** 		l1ctl_rx_reset_req(msg);
 661:layer1/l23_api.c **** 		break;
 662:layer1/l23_api.c **** 	case L1CTL_CCCH_MODE_REQ:
 663:layer1/l23_api.c **** 		l1ctl_rx_ccch_mode_req(msg);
 664:layer1/l23_api.c **** 		break;
 665:layer1/l23_api.c **** 	case L1CTL_TCH_MODE_REQ:
 666:layer1/l23_api.c **** 		l1ctl_rx_tch_mode_req(msg);
 667:layer1/l23_api.c **** 		break;
 668:layer1/l23_api.c **** 	case L1CTL_NEIGH_PM_REQ:
 669:layer1/l23_api.c **** 		l1ctl_rx_neigh_pm_req(msg);
 670:layer1/l23_api.c **** 		break;
 671:layer1/l23_api.c **** 	case L1CTL_TRAFFIC_REQ:
 672:layer1/l23_api.c **** 		l1ctl_rx_traffic_req(msg);
 673:layer1/l23_api.c **** 		/* we have to keep the msgb, not free it! */
 674:layer1/l23_api.c **** 		goto exit_nofree;
 675:layer1/l23_api.c **** 	case L1CTL_SIM_REQ:
 676:layer1/l23_api.c **** 		l1ctl_sim_req(msg);
 677:layer1/l23_api.c **** 		break;
 678:layer1/l23_api.c **** 	}
 679:layer1/l23_api.c **** 
 680:layer1/l23_api.c **** exit_msgbfree:
 681:layer1/l23_api.c **** 	msgb_free(msg);
 682:layer1/l23_api.c **** exit_nofree:
 683:layer1/l23_api.c **** 	return;
 684:layer1/l23_api.c **** }
 1156              		.loc 3 684 0
 1157 0570 08D08DE2 		add	sp, sp, #8
 1158 0574 F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1159              	.LBB41:
 1160              	.LBB42:
 1161              	.LBB43:
 1162              		.loc 3 378 0
 1163 0578 FEFFFFEA 		b	l1a_meas_msgb_set
 1164              	.LVL100:
 1165              	.L107:
 1166 057c 50639FE5 		ldr	r6, .L136+36
 1167              	.LVL101:
 1168              	.L106:
 1169              	.LBE43:
 1170              		.loc 3 385 0
 1171 0580 0410A0E1 		mov	r1, r4
 1172 0584 0530A0E1 		mov	r3, r5
 1173              	.LVL102:
 1174 0588 70039FE5 		ldr	r0, .L136+80
 1175 058c 042084E2 		add	r2, r4, #4
 1176 0590 00508DE5 		str	r5, [sp, #0]
 1177 0594 04508DE5 		str	r5, [sp, #4]
 1178 0598 FEFFFFEB 		bl	printf
 1179              		.loc 3 388 0
 1180 059c 0600A0E1 		mov	r0, r6
 1181 05a0 0810A0E1 		mov	r1, r8
 1182 05a4 0C0200EA 		b	.L135
 1183              	.LVL103:
 1184              	.L50:
 1185              	.LBE42:
 1186              	.LBE41:
 1187              	.LBB44:
 1188              	.LBB45:
 1189              		.loc 3 395 0
 1190 05a8 403098E5 		ldr	r3, [r8, #64]
 1191              		.loc 3 397 0
 1192 05ac 0420D3E5 		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1193 05b0 010052E3 		cmp	r2, #1
 1194              		.loc 3 395 0
 1195 05b4 046083E2 		add	r6, r3, #4
 1196              	.LVL104:
 1197              		.loc 3 397 0
 1198 05b8 8601001A 		bne	.L110
 1199              		.loc 3 399 0
 1200 05bc FC429FE5 		ldr	r4, .L136+16
 1201              	.LVL105:
 1202 05c0 F42A84E5 		str	r2, [r4, #2804]
 1203              		.loc 3 400 0
 1204 05c4 0430D6E5 		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 1205 05c8 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 1206 05cc 000483E1 		orr	r0, r3, r0, asl #8
 1207 05d0 FEFFFFEB 		bl	__fswab16
 1208 05d4 28539FE5 		ldr	r5, .L136+84
 1209 05d8 B50084E1 		strh	r0, [r4, r5]	@ movhi
 1210              		.loc 3 402 0
 1211 05dc 0430D6E5 		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 1212 05e0 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 1213 05e4 000483E1 		orr	r0, r3, r0, asl #8
 1214 05e8 FEFFFFEB 		bl	__fswab16
 1215 05ec 14339FE5 		ldr	r3, .L136+88
 1216 05f0 B30084E1 		strh	r0, [r4, r3]	@ movhi
 1217              		.loc 3 404 0
 1218 05f4 0730D6E5 		ldrb	r3, [r6, #7]	@ zero_extendqisi2
 1219 05f8 0600D6E5 		ldrb	r0, [r6, #6]	@ zero_extendqisi2
 1220 05fc 030480E1 		orr	r0, r0, r3, asl #8
 1221 0600 FEFFFFEB 		bl	__fswab16
 1222 0604 00339FE5 		ldr	r3, .L136+92
 1223 0608 00C0A0E1 		mov	ip, r0
 1224              		.loc 3 406 0
 1225 060c 0020A0E1 		mov	r2, r0
 1226 0610 B51094E1 		ldrh	r1, [r4, r5]
 1227 0614 F4029FE5 		ldr	r0, .L136+96
 1228              		.loc 3 404 0
 1229 0618 B3C084E1 		strh	ip, [r4, r3]	@ movhi
 1230              		.loc 3 406 0
 1231 061c FEFFFFEB 		bl	printf
 1232              	.LVL106:
 1233              	.L110:
 1234              		.loc 3 410 0
 1235 0620 FEFFFFEB 		bl	l1s_reset_hw
 1236              		.loc 3 411 0
 1237 0624 94229FE5 		ldr	r2, .L136+16
 1238 0628 D8329FE5 		ldr	r3, .L136+88
 1239 062c 0100A0E3 		mov	r0, #1
 1240 0630 B31092E1 		ldrh	r1, [r2, r3]
 1241 0634 FEFFFFEB 		bl	l1s_pm_test
 1242 0638 240200EA 		b	.L45
 1243              	.LVL107:
 1244              	.L51:
 1245              	.LBE45:
 1246              	.LBE44:
 1247              	.LBB46:
 1248              	.LBB47:
 1249              		.loc 3 431 0
 1250 063c 404098E5 		ldr	r4, [r8, #64]
 1251              	.LVL108:
 1252              		.loc 3 433 0
 1253 0640 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1254 0644 010053E3 		cmp	r3, #1
 1255 0648 9501000A 		beq	.L113
 1256 064c 020053E3 		cmp	r3, #2
 1257              		.loc 3 447 0
 1258 0650 BC029F15 		ldrne	r0, .L136+100
 1259              		.loc 3 433 0
 1260 0654 A701001A 		bne	.L133
 1261 0658 A00100EA 		b	.L114
 1262              	.L113:
 1263              		.loc 3 435 0
 1264 065c B4029FE5 		ldr	r0, .L136+104
 1265 0660 FEFFFFEB 		bl	puts
 1266              		.loc 3 436 0
 1267 0664 FEFFFFEB 		bl	l1s_reset
 1268              		.loc 3 437 0
 1269 0668 FEFFFFEB 		bl	l1s_reset_hw
 1270              		.loc 3 438 0
 1271 066c 0000A0E3 		mov	r0, #0
 1272 0670 0010A0E1 		mov	r1, r0
 1273 0674 FEFFFFEB 		bl	audio_set_enabled
 1274              		.loc 3 439 0
 1275 0678 0410D4E5 		ldrb	r1, [r4, #4]	@ zero_extendqisi2
 1276 067c 0E00A0E3 		mov	r0, #14
 1277 0680 FEFFFFEB 		bl	l1ctl_tx_reset
 1278 0684 240200EA 		b	.L45
 1279              	.L114:
 1280              		.loc 3 442 0
 1281 0688 8C029FE5 		ldr	r0, .L136+108
 1282 068c FEFFFFEB 		bl	puts
 1283              		.loc 3 443 0
 1284 0690 0410D4E5 		ldrb	r1, [r4, #4]	@ zero_extendqisi2
 1285 0694 0E00A0E3 		mov	r0, #14
 1286 0698 FEFFFFEB 		bl	l1ctl_tx_reset
 1287              		.loc 3 444 0
 1288 069c FEFFFFEB 		bl	sched_gsmtime_reset
 1289 06a0 240200EA 		b	.L45
 1290              	.LVL109:
 1291              	.L133:
 1292              		.loc 3 447 0
 1293 06a4 FEFFFFEB 		bl	puts
 1294 06a8 240200EA 		b	.L45
 1295              	.LVL110:
 1296              	.L52:
 1297              	.LBE47:
 1298              	.LBE46:
 1299              	.LBB48:
 1300              	.LBB49:
 1301              		.loc 3 470 0
 1302 06ac 403098E5 		ldr	r3, [r8, #64]
 1303 06b0 0450D3E5 		ldrb	r5, [r3, #4]	@ zero_extendqisi2
 1304              	.LVL111:
 1305              		.loc 3 473 0
 1306 06b4 04329FE5 		ldr	r3, .L136+16
 1307              		.loc 3 476 0
 1308 06b8 0300A0E3 		mov	r0, #3
 1309              		.loc 3 473 0
 1310 06bc 1B50C3E5 		strb	r5, [r3, #27]
 1311              		.loc 3 476 0
 1312 06c0 FEFFFFEB 		bl	mframe_disable
 1313              		.loc 3 477 0
 1314 06c4 0200A0E3 		mov	r0, #2
 1315 06c8 FEFFFFEB 		bl	mframe_disable
 1316              		.loc 3 479 0
 1317 06cc 020055E3 		cmp	r5, #2
 1318              		.loc 3 480 0
 1319 06d0 0300A003 		moveq	r0, #3
 1320              		.loc 3 479 0
 1321 06d4 B701000A 		beq	.L131
 1322              		.loc 3 481 0
 1323 06d8 010055E3 		cmp	r5, #1
 1324 06dc B801001A 		bne	.L117
 1325              		.loc 3 482 0
 1326 06e0 0200A0E3 		mov	r0, #2
 1327              	.L131:
 1328 06e4 FEFFFFEB 		bl	mframe_enable
 1329              	.L117:
 1330              	.LBB50:
 1331              	.LBB51:
 1332              		.loc 3 455 0
 1333 06e8 1100A0E3 		mov	r0, #17
 1334 06ec FEFFFFEB 		bl	l1ctl_msgb_alloc
 1335              		.loc 3 457 0
 1336 06f0 0410A0E3 		mov	r1, #4
 1337              		.loc 3 455 0
 1338 06f4 0040A0E1 		mov	r4, r0
 1339              	.LVL112:
 1340              		.loc 3 457 0
 1341 06f8 FEFFFFEB 		bl	msgb_put
 1342              		.loc 3 459 0
 1343 06fc 0050C0E5 		strb	r5, [r0, #0]
 1344 0700 D90100EA 		b	.L134
 1345              	.LVL113:
 1346              	.L58:
 1347              	.LBE51:
 1348              	.LBE50:
 1349              	.LBE49:
 1350              	.LBE48:
 1351              	.LBB52:
 1352              	.LBB53:
 1353              		.loc 3 505 0
 1354 0704 403098E5 		ldr	r3, [r8, #64]
 1355              		.loc 3 509 0
 1356 0708 0550D3E5 		ldrb	r5, [r3, #5]	@ zero_extendqisi2
 1357 070c 0440D3E5 		ldrb	r4, [r3, #4]	@ zero_extendqisi2
 1358              	.LVL114:
 1359 0710 0520A0E1 		mov	r2, r5
 1360 0714 0410A0E1 		mov	r1, r4
 1361 0718 00029FE5 		ldr	r0, .L136+112
 1362 071c FEFFFFEB 		bl	printf
 1363              		.loc 3 511 0
 1364 0720 0400A0E1 		mov	r0, r4
 1365 0724 FEFFFFEB 		bl	l1a_tch_mode_set
 1366 0728 0060A0E1 		mov	r6, r0
 1367              		.loc 3 512 0
 1368 072c 0500A0E1 		mov	r0, r5
 1369 0730 FEFFFFEB 		bl	l1a_audio_mode_set
 1370 0734 0050A0E1 		mov	r5, r0
 1371              		.loc 3 514 0
 1372 0738 0510A0E1 		mov	r1, r5
 1373 073c 0600A0E1 		mov	r0, r6
 1374 0740 FEFFFFEB 		bl	audio_set_enabled
 1375              		.loc 3 516 0
 1376 0744 74319FE5 		ldr	r3, .L136+16
 1377 0748 0120A0E3 		mov	r2, #1
 1378 074c 4B2AC3E5 		strb	r2, [r3, #2635]
 1379              	.LBB54:
 1380              	.LBB55:
 1381              		.loc 3 490 0
 1382 0750 1900A0E3 		mov	r0, #25
 1383 0754 FEFFFFEB 		bl	l1ctl_msgb_alloc
 1384              		.loc 3 492 0
 1385 0758 0410A0E3 		mov	r1, #4
 1386              		.loc 3 490 0
 1387 075c 0040A0E1 		mov	r4, r0
 1388              	.LVL115:
 1389              		.loc 3 492 0
 1390 0760 FEFFFFEB 		bl	msgb_put
 1391              		.loc 3 495 0
 1392 0764 0150C0E5 		strb	r5, [r0, #1]
 1393              		.loc 3 494 0
 1394 0768 0060C0E5 		strb	r6, [r0, #0]
 1395              	.LVL116:
 1396              	.L134:
 1397              	.LVL117:
 1398              		.loc 3 497 0
 1399 076c 0400A0E1 		mov	r0, r4
 1400 0770 FEFFFFEB 		bl	l1_queue_for_l2
 1401 0774 240200EA 		b	.L45
 1402              	.LVL118:
 1403              	.L59:
 1404              	.LBE55:
 1405              	.LBE54:
 1406              	.LBE53:
 1407              	.LBE52:
 1408              	.LBB56:
 1409              	.LBB57:
 1410              		.loc 3 526 0
 1411 0778 403098E5 		ldr	r3, [r8, #64]
 1412              		.loc 3 530 0
 1413 077c 3C219FE5 		ldr	r2, .L136+16
 1414              		.loc 3 526 0
 1415 0780 046083E2 		add	r6, r3, #4
 1416              	.LVL119:
 1417              		.loc 3 530 0
 1418 0784 0030A0E3 		mov	r3, #0
 1419              		.loc 3 534 0
 1420 0788 0370A0E1 		mov	r7, r3
 1421              	.LVL120:
 1422 078c CA9E82E2 		add	r9, r2, #3232
 1423 0790 0650A0E1 		mov	r5, r6
 1424 0794 C2AE82E2 		add	sl, r2, #3104
 1425 0798 0640A0E1 		mov	r4, r6
 1426              	.LVL121:
 1427              		.loc 3 530 0
 1428 079c 1C3CC2E5 		strb	r3, [r2, #3100]
 1429              		.loc 3 531 0
 1430 07a0 1D3CC2E5 		strb	r3, [r2, #3101]
 1431              		.loc 3 533 0
 1432 07a4 1E3CC2E5 		strb	r3, [r2, #3102]
 1433              		.loc 3 534 0
 1434 07a8 1F3CC2E5 		strb	r3, [r2, #3103]
 1435 07ac F30100EA 		b	.L119
 1436              	.L120:
 1437              		.loc 3 536 0
 1438 07b0 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1439 07b4 0300D4E5 		ldrb	r0, [r4, #3]	@ zero_extendqisi2
 1440 07b8 000483E1 		orr	r0, r3, r0, asl #8
 1441 07bc FEFFFFEB 		bl	__fswab16
 1442 07c0 B200CAE0 		strh	r0, [sl], #2	@ movhi
 1443              		.loc 3 537 0
 1444 07c4 8230D5E5 		ldrb	r3, [r5, #130]	@ zero_extendqisi2
 1445 07c8 0130C9E4 		strb	r3, [r9], #1
 1446              		.loc 3 535 0
 1447 07cc 024084E2 		add	r4, r4, #2
 1448 07d0 015085E2 		add	r5, r5, #1
 1449              	.LVL122:
 1450              	.L119:
 1451 07d4 0010D6E5 		ldrb	r1, [r6, #0]	@ zero_extendqisi2
 1452 07d8 010057E1 		cmp	r7, r1
 1453 07dc 017087E2 		add	r7, r7, #1
 1454 07e0 EA0100BA 		blt	.L120
 1455              	.LVL123:
 1456              		.loc 3 539 0
 1457 07e4 38019FE5 		ldr	r0, .L136+116
 1458 07e8 FEFFFFEB 		bl	printf
 1459              		.loc 3 540 0
 1460 07ec CC309FE5 		ldr	r3, .L136+16
 1461              		.loc 3 543 0
 1462 07f0 082B93E5 		ldr	r2, [r3, #2824]
 1463              		.loc 3 540 0
 1464 07f4 0010D6E5 		ldrb	r1, [r6, #0]	@ zero_extendqisi2
 1465              		.loc 3 543 0
 1466 07f8 000052E3 		cmp	r2, #0
 1467              		.loc 3 540 0
 1468 07fc 1C1CC3E5 		strb	r1, [r3, #3100]
 1469              		.loc 3 543 0
 1470 0800 2402001A 		bne	.L45
 1471              		.loc 3 544 0
 1472 0804 1400A0E3 		mov	r0, #20
 1473 0808 FEFFFFEB 		bl	mframe_enable
 1474 080c 240200EA 		b	.L45
 1475              	.LVL124:
 1476              	.L60:
 1477              	.LBE57:
 1478              	.LBE56:
 1479              	.LBB58:
 1480              	.LBB59:
 1481              		.loc 3 557 0
 1482 0810 403098E5 		ldr	r3, [r8, #64]
 1483 0814 083083E2 		add	r3, r3, #8
 1484 0818 143088E5 		str	r3, [r8, #20]
 1485              		.loc 3 559 0
 1486 081c 04019FE5 		ldr	r0, .L136+120
 1487 0820 FEFFFFEB 		bl	l1a_txq_msgb_count
 1488              		.loc 3 560 0
 1489 0824 030050E3 		cmp	r0, #3
 1490              		.loc 3 561 0
 1491 0828 FC009FC5 		ldrgt	r0, .L136+124
 1492              		.loc 3 560 0
 1493 082c A70100CA 		bgt	.L133
 1494              		.loc 3 566 0
 1495 0830 F0009FE5 		ldr	r0, .L136+120
 1496 0834 0810A0E1 		mov	r1, r8
 1497              	.LVL125:
 1498              	.L135:
 1499              	.LBE59:
 1500              	.LBE58:
 1501              		.loc 3 684 0
 1502 0838 08D08DE2 		add	sp, sp, #8
 1503 083c F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1504              	.LBB60:
 1505              	.LBB61:
 1506              		.loc 3 566 0
 1507 0840 FEFFFFEA 		b	l1a_txq_msgb_enq
 1508              	.LVL126:
 1509              	.L57:
 1510              	.LBE61:
 1511              	.LBE60:
 1512              	.LBB62:
 1513              	.LBB63:
 1514              	.LBB64:
 1515              		.loc 3 577 0
 1516 0844 043041E2 		sub	r3, r1, #4
 1517 0848 0338A0E1 		mov	r3, r3, asl #16
 1518 084c 2348A0E1 		mov	r4, r3, lsr #16
 1519              	.LVL127:
 1520              	.LBE64:
 1521              		.loc 3 572 0
 1522 0850 403098E5 		ldr	r3, [r8, #64]
 1523              	.LBB65:
 1524              		.loc 3 577 0
 1525 0854 D4009FE5 		ldr	r0, .L136+128
 1526 0858 0410A0E1 		mov	r1, r4
 1527              	.LBE65:
 1528              		.loc 3 572 0
 1529 085c 046083E2 		add	r6, r3, #4
 1530              	.LVL128:
 1531              	.LBB66:
 1532              		.loc 3 577 0
 1533 0860 FEFFFFEB 		bl	printf
 1534 0864 0050A0E3 		mov	r5, #0
 1535              	.LVL129:
 1536 0868 1C0200EA 		b	.L125
 1537              	.L126:
 1538              		.loc 3 579 0
 1539 086c 0610D5E7 		ldrb	r1, [r5, r6]	@ zero_extendqisi2
 1540              		.loc 3 578 0
 1541 0870 015085E2 		add	r5, r5, #1
 1542              		.loc 3 579 0
 1543 0874 FEFFFFEB 		bl	printf
 1544              	.L125:
 1545              		.loc 3 578 0
 1546 0878 040055E1 		cmp	r5, r4
 1547              		.loc 3 579 0
 1548 087c B0009FE5 		ldr	r0, .L136+132
 1549              		.loc 3 578 0
 1550 0880 190200BA 		blt	.L126
 1551              		.loc 3 580 0
 1552 0884 AC009FE5 		ldr	r0, .L136+136
 1553 0888 FEFFFFEB 		bl	puts
 1554              	.LBE66:
 1555              		.loc 3 584 0
 1556 088c 0400A0E1 		mov	r0, r4
 1557 0890 0610A0E1 		mov	r1, r6
 1558 0894 FEFFFFEB 		bl	sim_apdu
 1559              	.LVL130:
 1560              	.L45:
 1561              	.LBE63:
 1562              	.LBE62:
 1563              		.loc 3 681 0
 1564 0898 0800A0E1 		mov	r0, r8
 1565              		.loc 3 684 0
 1566 089c 08D08DE2 		add	sp, sp, #8
 1567 08a0 F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1568              		.loc 3 681 0
 1569 08a4 FEFFFFEA 		b	msgb_free
 1570              	.LVL131:
 1571              	.L128:
 1572              		.loc 3 684 0
 1573 08a8 08D08DE2 		add	sp, sp, #8
 1574 08ac F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1575              	.L137:
 1576              		.align	2
 1577              	.L136:
 1578 08b0 00000000 		.word	l23_rx_queue
 1579 08b4 58000000 		.word	.LC3
 1580 08b8 78000000 		.word	.LC4
 1581 08bc 8C000000 		.word	.LC5
 1582 08c0 00000000 		.word	l1s
 1583 08c4 B4000000 		.word	.LC6
 1584 08c8 D0000000 		.word	.LC7
 1585 08cc 140B0000 		.word	l1s+2836
 1586 08d0 08010000 		.word	.LC8
 1587 08d4 580A0000 		.word	l1s+2648
 1588 08d8 1C010000 		.word	.LC9
 1589 08dc 44010000 		.word	.LC10
 1590 08e0 9C0B0000 		.word	l1s+2972
 1591 08e4 980B0000 		.word	2968
 1592 08e8 6C010000 		.word	.LC11
 1593 08ec 94010000 		.word	.LC12
 1594 08f0 B4010000 		.word	.LC13
 1595 08f4 E8010000 		.word	.LC14
 1596 08f8 500A0000 		.word	l1s+2640
 1597 08fc 0C020000 		.word	.LC15
 1598 0900 28020000 		.word	.LC16
 1599 0904 F80A0000 		.word	2808
 1600 0908 FA0A0000 		.word	2810
 1601 090c FC0A0000 		.word	2812
 1602 0910 68020000 		.word	.LC17
 1603 0914 B8020000 		.word	.LC20
 1604 0918 88020000 		.word	.LC18
 1605 091c A0020000 		.word	.LC19
 1606 0920 D8020000 		.word	.LC21
 1607 0924 10030000 		.word	.LC22
 1608 0928 600A0000 		.word	l1s+2656
 1609 092c 40030000 		.word	.LC23
 1610 0930 58030000 		.word	.LC24
 1611 0934 6C030000 		.word	.LC25
 1612 0938 74030000 		.word	.LC26
 1613              	.LFE85:
 1615              		.section	.text.l1a_l23api_init,"ax",%progbits
 1616              		.align	2
 1617              		.global	l1a_l23api_init
 1619              	l1a_l23api_init:
 1620              	.LFB86:
 685:layer1/l23_api.c **** 
 686:layer1/l23_api.c **** void l1a_l23api_init(void)
 687:layer1/l23_api.c **** {
 1621              		.loc 3 687 0
 1622              		@ args = 0, pretend = 0, frame = 0
 1623              		@ frame_needed = 0, uses_anonymous_args = 0
 1624              		@ link register save eliminated.
 1625              	.LVL132:
 688:layer1/l23_api.c **** 	sercomm_register_rx_cb(SC_DLCI_L1A_L23, l1a_l23_rx);
 1626              		.loc 3 688 0
 1627 0000 04109FE5 		ldr	r1, .L140
 1628 0004 0500A0E3 		mov	r0, #5
 1629              		.loc 3 687 0
 1630              		@ lr needed for prologue
 689:layer1/l23_api.c **** }
 1631              		.loc 3 689 0
 1632              		.loc 3 688 0
 1633 0008 FEFFFFEA 		b	sercomm_register_rx_cb
 1634              	.L141:
 1635              		.align	2
 1636              	.L140:
 1637 000c 00000000 		.word	l1a_l23_rx
 1638              	.LFE86:
 1848              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 l23_api.c
     /tmp/ccwHovug.s:15     .bss:0000000000000000 l1a_l23_tx_cb
                             .bss:0000000000000000 $d
     /tmp/ccwHovug.s:21     .data:0000000000000000 l23_rx_queue
     /tmp/ccwHovug.s:22     .data:0000000000000000 $d
     /tmp/ccwHovug.s:27     .text.__fswab16:0000000000000000 __fswab16
     /tmp/ccwHovug.s:35     .text.__fswab16:0000000000000000 $a
     /tmp/ccwHovug.s:54     .text.msgb_tailroom:0000000000000000 msgb_tailroom
     /tmp/ccwHovug.s:62     .text.msgb_tailroom:0000000000000000 $a
     /tmp/ccwHovug.s:83     .text.msgb_put:0000000000000000 msgb_put
     /tmp/ccwHovug.s:89     .text.msgb_put:0000000000000000 $a
     /tmp/ccwHovug.s:131    .text.msgb_put:000000000000004c $d
     /tmp/ccwHovug.s:138    .text.l1_queue_for_l2:0000000000000000 l1_queue_for_l2
     /tmp/ccwHovug.s:145    .text.l1_queue_for_l2:0000000000000000 $a
     /tmp/ccwHovug.s:174    .text.l1_queue_for_l2:0000000000000030 $d
     /tmp/ccwHovug.s:180    .text.audio_set_enabled:0000000000000000 audio_set_enabled
     /tmp/ccwHovug.s:186    .text.audio_set_enabled:0000000000000000 $a
     /tmp/ccwHovug.s:236    .text.l1ctl_msgb_alloc:0000000000000000 l1ctl_msgb_alloc
     /tmp/ccwHovug.s:242    .text.l1ctl_msgb_alloc:0000000000000000 $a
     /tmp/ccwHovug.s:308    .text.l1ctl_msgb_alloc:0000000000000064 $d
     /tmp/ccwHovug.s:316    .text.l1_create_l2_msg:0000000000000000 l1_create_l2_msg
     /tmp/ccwHovug.s:322    .text.l1_create_l2_msg:0000000000000000 $a
     /tmp/ccwHovug.s:393    .text.l1ctl_tx_reset:0000000000000000 l1ctl_tx_reset
     /tmp/ccwHovug.s:399    .text.l1ctl_tx_reset:0000000000000000 $a
     /tmp/ccwHovug.s:428    .text.l1a_l23_rx:0000000000000000 l1a_l23_rx
     /tmp/ccwHovug.s:434    .text.l1a_l23_rx:0000000000000000 $a
     /tmp/ccwHovug.s:456    .text.l1a_l23_rx:0000000000000020 $d
     /tmp/ccwHovug.s:540    .text.l1a_l23_handler:0000000000000000 l1a_l23_handler
     /tmp/ccwHovug.s:546    .text.l1a_l23_handler:0000000000000000 $a
     /tmp/ccwHovug.s:594    .text.l1a_l23_handler:0000000000000058 $d
     /tmp/ccwHovug.s:626    .text.l1a_l23_handler:00000000000000c8 $a
     /tmp/ccwHovug.s:1578   .text.l1a_l23_handler:00000000000008b0 $d
     /tmp/ccwHovug.s:1619   .text.l1a_l23api_init:0000000000000000 l1a_l23api_init
     /tmp/ccwHovug.s:1627   .text.l1a_l23api_init:0000000000000000 $a
     /tmp/ccwHovug.s:1637   .text.l1a_l23api_init:000000000000000c $d

UNDEFINED SYMBOLS
osmo_panic
sercomm_sendmsg
twl3025_unit_enable
msgb_alloc
puts
msgb_enqueue
msgb_dequeue
printf
l1s_reset
l1s_fbsb_req
mframe_disable
l1a_tch_mode_set
l1a_audio_mode_set
l1a_mftask_set
l1a_txq_msgb_flush
l1a_meas_msgb_set
dsp_load_ciph_param
l1a_freq_req
l1a_rach_req
l1s_reset_hw
l1s_pm_test
sched_gsmtime_reset
mframe_enable
l1a_txq_msgb_count
l1a_txq_msgb_enq
sim_apdu
msgb_free
l1s
sercomm_register_rx_cb
